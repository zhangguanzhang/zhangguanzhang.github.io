<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhangguanzhang</title>
  
  <subtitle>站在巨人的肩膀上</subtitle>
  <link href="http://zhangguanzhang.github.io/atom.xml" rel="self"/>
  
  <link href="http://zhangguanzhang.github.io/"/>
  <updated>2025-10-31T17:30:30.000Z</updated>
  <id>http://zhangguanzhang.github.io/</id>
  
  <author>
    <name>Zhangguanzhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程执行skopeo copy panic的一次解决过程</title>
    <link href="http://zhangguanzhang.github.io/2025/10/31/skopeo-copy-panic/"/>
    <id>http://zhangguanzhang.github.io/2025/10/31/skopeo-copy-panic/</id>
    <published>2025-10-31T17:30:30.000Z</published>
    <updated>2025-10-31T17:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>多线程执行skopeo copy panic的一次解决过程</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>内部构建出包存在大概以下逻辑：</p><ol><li>起一个 registry 容器，假设随机端口为 45678</li><li>然后把相关镜像 skopeo copy 从缓存的 harbor 同步到 registry容器</li><li>打包registry的目录成为 <code>iamge-xxx.tgz</code></li></ol><p>然后发现这几天打包有问题，多线程 skopeo copy 报错没处理，最后 <code>iamge-xxx.tgz</code> 大小不对。</p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><h3 id="调用链分析"><a href="#调用链分析" class="headerlink" title="调用链分析"></a>调用链分析</h3><p>查看出包日志一堆panic，由于多线程调用的，golang 的 panic 堆栈的顺序都错乱了，构建机器都是 centos7，都不维护了，上面的 skopeo 通过包管理安装的，版本比较低：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">skopeo --version</span></span><br><span class="line">skopeo version 0.1.40</span><br></pre></td></tr></table></figure><p>根据版本去查看源码找调用链，skopeo 使用了 cobra 库，从 <code>cmd/skopeo/copy.go</code> 找到堆栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/builddir/build/BUILD/skopeo-be6146b0a8471b02e776134119a2c37dfb70d414/cmd/skopeo/copy.go:159 +0x94b fp=0xc0005f3920 sp=0xc0005f3678 pc=0x559635b91b0b</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/containers/image/v5/copy&quot;</span></span><br><span class="line">    ....</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/containers/skopeo/blob/v0.1.40/cmd/skopeo/copy.go#L159-L167</span></span><br><span class="line">    _, err = <span class="built_in">copy</span>.Image(ctx, policyContext, destRef, srcRef, &amp;<span class="built_in">copy</span>.Options&#123;</span><br><span class="line">        RemoveSignatures:      opts.removeSignatures,</span><br><span class="line">        SignBy:                opts.signByFingerprint,</span><br><span class="line">        ReportWriter:          stdout,</span><br><span class="line">        SourceCtx:             sourceCtx,</span><br><span class="line">        DestinationCtx:        destinationCtx,</span><br><span class="line">        ForceManifestMIMEType: manifestType,</span><br><span class="line">        ImageListSelection:    imageListSelection,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>根据导包找到：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containers/skopeo/blob/v0.1.40/vendor/github.com/containers/image/v5/copy/copy.go#L173</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Image</span><span class="params">(ctx context.Context, policyContext *signature.PolicyContext, destRef, srcRef types.ImageReference, options *Options)</span></span> (copiedManifest []<span class="type">byte</span>, retErr <span class="type">error</span>) &#123;</span><br></pre></td></tr></table></figure><p>便于查找，给所有堆栈字符串保存到文件里，从输出混乱的堆栈字符串里搜索 <code>copy/copy.go:</code> 找到:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ grep -Po <span class="string">&#x27;vendor.*?/copy/copy.go:\d+&#x27;</span> txt | sort -u</span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">1337</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">258</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">578</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">740</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">755</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">765</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">766</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">770</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">771</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">860</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">948</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">949</span></span><br><span class="line">vendor/src/github.com/containers/image/v5/pkg/blobinfocache/boltdb/boltdb.go0x105/builddir/build/BUILD/skopeo-be6146b0a8471b02e776134119a2c37dfb70d414/vendor/src/github.com/containers/image/v5/<span class="built_in">copy</span>/<span class="built_in">copy</span>.<span class="keyword">go</span>:<span class="number">174</span></span><br></pre></td></tr></table></figure><p>根据上面信息和源码，调用链为：</p><ul><li><code>copy/copy.go#L173</code> 的 <code>func Image(ctx context.Context,</code></li><li><code>copy/copy.go#L258</code> 的 <code>if copiedManifest, _, _, err = c.copyOneImage(</code></li><li><code>copy/copy.go#L473</code> 的 <code>func (c *copier) copyOneImage</code></li><li><code>copy/copy.go#L578</code> 的 <code>if err := ic.copyLayers(ctx);</code></li><li><code>copy/copy.go#L704</code> 的 <code>func (ic *imageCopier) copyLayers(ctx context.Context)</code></li><li><code>copy/copy.go:766</code> 的 <code>go copyLayerHelper(i, srcLayer, progressPool)，而该方法是下面闭包声明的</code></li><li><code>copy/copy.go:755</code> 的 <code>cld.destInfo, cld.diffID, cld.err = ic.copyLayer(ctx, srcLayer, pool) </code></li><li><code>copy/copy.go:948</code> 的 <code>func (ic *imageCopier) copyLayer(ctx，然后走到内部第一行</code></li><li><code>copy/copy.go:949</code> 的 <code>cachedDiffID := ic.c.blobInfoCache.UncompressedDigest(srcInfo.Digest)</code></li></ul><p>而方法 <code>UncompressedDigest</code> 是接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containers/skopeo/blob/v0.1.40/vendor/github.com/containers/image/v5/types/types.go#L177-L198</span></span><br><span class="line"><span class="keyword">type</span> BlobInfoCache <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">    UncompressedDigest(anyDigest digest.Digest) digest.Digest</span><br><span class="line"></span><br><span class="line">    RecordDigestUncompressedPair(anyDigest digest.Digest, uncompressed digest.Digest)</span><br><span class="line">    RecordKnownLocation(transport ImageTransport, scope BICTransportScope, digest digest.Digest, location BICLocationReference)</span><br><span class="line">    CandidateLocations(transport ImageTransport, scope BICTransportScope, digest digest.Digest, canSubstitute <span class="type">bool</span>) []BICReplacementCandidate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜 <code>ic.c.blobInfoCache</code> 里的 <code>blobInfoCache</code> 赋值，搜到：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containers/skopeo/blob/v0.1.40/vendor/github.com/containers/image/v5/copy/copy.go#L173-L233</span></span><br><span class="line">blobInfoCache: blobinfocache.DefaultCache(options.DestinationCtx)</span><br></pre></td></tr></table></figure><p>然后发现是 boltdb 存储 cache：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containers/skopeo/blob/v0.1.40/vendor/github.com/containers/image/v5/pkg/blobinfocache/default.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultCache</span><span class="params">(sys *types.SystemContext)</span></span> types.BlobInfoCache &#123;</span><br><span class="line">    dir, err := blobInfoCacheDir(sys, getRootlessUID())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logrus.Debugf(<span class="string">&quot;Error determining a location for %s, using a memory-only cache&quot;</span>, blobInfoCacheFilename)</span><br><span class="line">        <span class="keyword">return</span> memory.New()</span><br><span class="line">    &#125;</span><br><span class="line">    path := filepath.Join(dir, blobInfoCacheFilename)</span><br><span class="line">    <span class="keyword">if</span> err := os.MkdirAll(dir, <span class="number">0700</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logrus.Debugf(<span class="string">&quot;Error creating parent directories for %s, using a memory-only cache: %v&quot;</span>, blobInfoCacheFilename, err)</span><br><span class="line">        <span class="keyword">return</span> memory.New()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logrus.Debugf(<span class="string">&quot;Using blob info cache at %s&quot;</span>, path)</span><br><span class="line">    <span class="keyword">return</span> boltdb.New(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看失败构建的构建机器上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /var/lib/containers/cache</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">total 25740</span><br><span class="line">-rw------- 1 root root 43134976 Oct 28 12:31 blob-info-cache-v1.boltdb</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al</span></span><br><span class="line">total 25740</span><br><span class="line">drwx------ 2 root root       39 Aug 27 14:18 .</span><br><span class="line">drwxr-xr-x 4 root root       35 Aug 27 14:18 ..</span><br><span class="line">-rw------- 1 root root 43134976 Oct 28 12:31 blob-info-cache-v1.boltdb</span><br></pre></td></tr></table></figure><p>和堆栈里的 boltdb 相关堆栈也对的上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -Po <span class="string">&#x27;blobinfocache/boltdb/boltdb.go:\d+&#x27;</span> txt  | <span class="built_in">sort</span> -u</span></span><br><span class="line">blobinfocache/boltdb/boltdb.go:108</span><br><span class="line">blobinfocache/boltdb/boltdb.go:112</span><br><span class="line">blobinfocache/boltdb/boltdb.go:114</span><br><span class="line">blobinfocache/boltdb/boltdb.go:119</span><br><span class="line">blobinfocache/boltdb/boltdb.go:124</span><br><span class="line">blobinfocache/boltdb/boltdb.go:146</span><br><span class="line">blobinfocache/boltdb/boltdb.go:172</span><br><span class="line">blobinfocache/boltdb/boltdb.go:174</span><br><span class="line">blobinfocache/boltdb/boltdb.go:175</span><br><span class="line">blobinfocache/boltdb/boltdb.go:3010</span><br><span class="line">blobinfocache/boltdb/boltdb.go:54</span><br><span class="line">blobinfocache/boltdb/boltdb.go:56</span><br><span class="line">blobinfocache/boltdb/boltdb.go:58</span><br><span class="line">blobinfocache/boltdb/boltdb.go:65</span><br><span class="line">blobinfocache/boltdb/boltdb.go:66</span><br><span class="line">blobinfocache/boltdb/boltdb.go:67</span><br><span class="line">blobinfocache/boltdb/boltdb.go:84</span><br></pre></td></tr></table></figure><p>这里调用链就不细致分析了，确定是 <code>uncompressedDigest</code> 方法里 boltdb 问题：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containers/skopeo/blob/v0.1.40/vendor/github.com/containers/image/v5/pkg/blobinfocache/boltdb/boltdb.go#L145C1-L146C57</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bdc *cache)</span></span> uncompressedDigest(tx *bolt.Tx, anyDigest digest.Digest) digest.Digest &#123;</span><br><span class="line">    <span class="keyword">if</span> b := tx.Bucket(uncompressedDigestBucket); b != <span class="literal">nil</span> &#123;</span><br></pre></td></tr></table></figure><p>这里有问题的话就说明 boltdb 文件损坏，boltdb 文件损坏的话，docker 和 etcd 都能遇到，搜关键字就知道了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep invalid txt</span></span><br><span class="line">panic: invalid page type: 6432: 10</span><br></pre></td></tr></table></figure><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>写个 boltdb 查看 Bucket 的 cli 复现下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    bolt <span class="string">&quot;go.etcd.io/bbolt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;Usage: %s &lt;bolt-db-file&gt;\n&quot;</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    filename := os.Args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    db, err := bolt.Open(filename, <span class="number">0600</span>, &amp;bolt.Options&#123;ReadOnly: <span class="literal">true</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to open %s: %v&quot;</span>, filename, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">    err = db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Top-level buckets in %s:\n&quot;</span>, filename)</span><br><span class="line">        <span class="keyword">return</span> tx.ForEach(<span class="function"><span class="keyword">func</span><span class="params">(name []<span class="type">byte</span>, _ *bolt.Bucket)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;- %s\n&quot;</span>, name)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝到构建机器上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bbolt-tool blob-info-cache-v1.boltdb</span></span><br><span class="line">Top-level buckets in blob-info-cache-v1.boltdb:</span><br><span class="line">panic: invalid page type: 6432: 10</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">go.etcd.io/bbolt.(*Cursor).search(0xc0000a5cd8, &#123;0x7ff6b8ff8130, 0x47, 0x47&#125;, 0x0?)</span><br><span class="line">        /root/go/pkg/mod/go.etcd.io/bbolt@v1.4.3/cursor.go:286 +0x279</span><br><span class="line">go.etcd.io/bbolt.(*Cursor).seek(0xc0000a5cd8, &#123;0x7ff6b8ff8130?, 0xc000080140?, 0xc0000ac040?&#125;)</span><br><span class="line">        /root/go/pkg/mod/go.etcd.io/bbolt@v1.4.3/cursor.go:162 +0x2e</span><br><span class="line">go.etcd.io/bbolt.(*Bucket).Bucket(0xc0000aa018, &#123;0x7ff6b8ff8130, 0x47, 0x4e8c40?&#125;)</span><br><span class="line">        /root/go/pkg/mod/go.etcd.io/bbolt@v1.4.3/bucket.go:97 +0xb6</span><br><span class="line">main.main.func1.(*Tx).ForEach.2(&#123;0x7ff6b8ff8130, 0x47, 0x47&#125;, &#123;0xc0000a5dd8?, 0x1?, 0x1?&#125;)</span><br><span class="line">        /root/go/pkg/mod/go.etcd.io/bbolt@v1.4.3/tx.go:158 +0x45</span><br><span class="line">go.etcd.io/bbolt.(*Bucket).ForEach(0x51c268?, 0xc0000a5de8)</span><br><span class="line">        /root/go/pkg/mod/go.etcd.io/bbolt@v1.4.3/bucket.go:591 +0x89</span><br><span class="line">go.etcd.io/bbolt.(*Tx).ForEach(...)</span><br><span class="line">        /root/go/pkg/mod/go.etcd.io/bbolt@v1.4.3/tx.go:157</span><br><span class="line">main.main.func1(0xc0000aa000)</span><br><span class="line">        /root/code/golang/bbolt/main.go:26 +0x9d</span><br><span class="line">go.etcd.io/bbolt.(*DB).View(0x7ffca6c567a8?, 0xc0000a5f00)</span><br><span class="line">        /root/go/pkg/mod/go.etcd.io/bbolt@v1.4.3/db.go:939 +0x6c</span><br><span class="line">main.main()</span><br><span class="line">        /root/code/golang/bbolt/main.go:24 +0x1f0</span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>正常构建机器上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bbolt-tool blob-info-cache-v1.boltdb</span> </span><br><span class="line">Top-level buckets in blob-info-cache-v1.boltdb:</span><br><span class="line">- knownLocations</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>根据上面方法 <code>DefaultCache</code> 可以把 path 创建成文件，让走内存缓存，但是查看了下新版本 skopeo 已经默认使用 <code>sqlite</code> 缓存了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the format changes in an incompatible way, increase the version number.</span></span><br><span class="line">blobInfoCacheFilename = <span class="string">&quot;blob-info-cache-v1.sqlite&quot;</span></span><br><span class="line"><span class="comment">// systemBlobInfoCacheDir is the directory containing the blob info cache (in blobInfocacheFilename) for root-running processes.</span></span><br><span class="line">systemBlobInfoCacheDir = <span class="string">&quot;/var/lib/containers/cache&quot;</span></span><br></pre></td></tr></table></figure><p>改为使用新版本 skopeo ，以及相关多线程的输出也加了前缀，避免下次类似问题堆栈混乱。然后发现老版本分支还是会走老逻辑，构建机器上把这个 boltdb 文件 mv 下避免影响其他分支，</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;多线程执行skopeo copy panic的一次解决过程&lt;/p&gt;</summary>
    
    
    
    
    <category term="skopeo" scheme="http://zhangguanzhang.github.io/tags/skopeo/"/>
    
    <category term="boltdb" scheme="http://zhangguanzhang.github.io/tags/boltdb/"/>
    
  </entry>
  
  <entry>
    <title>离线安装docker和包管理安装docker下containerd的启动相关</title>
    <link href="http://zhangguanzhang.github.io/2025/10/23/docker-bin-containerd/"/>
    <id>http://zhangguanzhang.github.io/2025/10/23/docker-bin-containerd/</id>
    <published>2025-10-23T17:10:30.000Z</published>
    <updated>2025-10-23T17:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单科普下 docker 启动时候和 contaienrd 相关</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>昨天处理了一个现场 docker 起不来的问题，借着处理过程科普下。docker 无法启动日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journarlctl -xe --no-pager -u docker</span></span><br><span class="line">Oct 23 17:28:33 XXX251023S00P systemd[1]: docker.service: Unit entered failed state.</span><br><span class="line">Oct 23 17:28:33 XXX251023S00P systemd[1]: docker.service: Failed with result &#x27;exit-code&#x27;.</span><br><span class="line">Oct 23 17:28:43 XXX251023S00P systemd[1]: docker.service: Service RestartSec=10s expired, scheduling restart.</span><br><span class="line">Oct 23 17:28:43 XXX251023S00P systemd[1]: Stopped Docker Application Container Engine.</span><br><span class="line">-- Subject: Unit docker.service has finished shutting down</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">-- </span><br><span class="line">-- Unit docker.service has finished shutting down.</span><br><span class="line">Oct 23 17:28:43 XXX251023S00P systemd[1]: Starting Docker Application Container Engine...</span><br><span class="line">-- Subject: Unit docker.service has begun start-up</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">-- </span><br><span class="line">-- Unit docker.service has begun starting up.</span><br><span class="line">Oct 23 17:28:43 XXX251023S00P dockerd[7355]: time=&quot;2025-10-23T17:28:43+08:00&quot; level=info msg=&quot;SUSE:secrets :: enabled&quot;</span><br><span class="line">Oct 23 17:28:44 XXX251023S00P dockerd[7355]: time=&quot;2025-10-23T17:28:44.000689797+08:00&quot; level=warning msg=&quot;The \&quot;graph\&quot; config file option is deprecated. Please use \&quot;data-root\&quot; instead.&quot;</span><br><span class="line">Oct 23 17:28:44 XXX251023S00P dockerd[7355]: time=&quot;2025-10-23T17:28:44.064839553+08:00&quot; level=warning msg=&quot;grpc: addrConn.createTransport failed to connect to &#123;unix:///run/containerd/containerd.sock 0  &lt;nil&gt;&#125;. Err :connection error: desc = \&quot;transport: Error while dialing dial unix /run/containerd/containerd.sock: connect: connection refused\&quot;. Reconnecting...&quot; module=grpc</span><br><span class="line">Oct 23 17:28:45 XXX251023S00P dockerd[7355]: time=&quot;2025-10-23T17:28:45.065163178+08:00&quot; level=warning msg=&quot;grpc: addrConn.createTransport failed to connect to &#123;unix:///run/containerd/containerd.sock 0  &lt;nil&gt;&#125;. Err :connection error: desc = \&quot;transport: Error while dialing dial unix /run/containerd/containerd.sock: connect: connection refused\&quot;. Reconnecting...&quot; module=grpc</span><br></pre></td></tr></table></figure><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>上面日志右边滑动查看，核心报错是 <code>Error while dialing dial unix /run/containerd/containerd.sock: connect: connection refused</code> ，解决这个问题要先了解下 docker 和 containerd 启动相关。</p><h3 id="包管理下的-docker-和-containerd"><a href="#包管理下的-docker-和-containerd" class="headerlink" title="包管理下的 docker 和 containerd"></a>包管理下的 docker 和 containerd</h3><p>docker damon 和 containerd 是存在交互而工作的，如果是包管理安装的 docker，会有两个 systemd service 文件：</p><ul><li>containerd 包提供 <code>containerd.service</code> 文件</li><li>docker-ce 的 <code>docker.service</code></li></ul><p>这里以 rpm 包举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep -P <span class="string">&#x27;containerd&#x27;</span></span></span><br><span class="line">containerd.io-1.6.33-3.1.el7.x86_64</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -ql containerd.io | grep -Ev <span class="string">&#x27;/(doc|licen|man)&#x27;</span></span></span><br><span class="line">/etc/containerd</span><br><span class="line">/etc/containerd/config.toml</span><br><span class="line">/usr/bin/containerd</span><br><span class="line">/usr/bin/containerd-shim</span><br><span class="line">/usr/bin/containerd-shim-runc-v1</span><br><span class="line">/usr/bin/containerd-shim-runc-v2</span><br><span class="line">/usr/bin/ctr</span><br><span class="line">/usr/bin/runc</span><br><span class="line">/usr/lib/systemd/system/containerd.service</span><br></pre></td></tr></table></figure><p>而包管理 docker.service 有依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">cat</span> --no-pager  docker | grep containerd.service</span></span><br><span class="line">After=network-online.target docker.socket firewalld.service containerd.service time-set.target</span><br><span class="line">Wants=network-online.target containerd.service</span><br></pre></td></tr></table></figure><h3 id="二进制安装-docker"><a href="#二进制安装-docker" class="headerlink" title="二进制安装 docker"></a>二进制安装 docker</h3><p>我们私有化就是 docker 离线安装的，根据官方文档 <a href="https://docs.docker.com/engine/install/binaries/">https://docs.docker.com/engine/install/binaries/</a> 下载二进制安装，但是官方文档没有说 systemd service 文件获取。以及我接手后发现也没有创建 containerd.service 纳管 containerd，但是 docker 也能运行，查看 docker 子进程能看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl status docker</span></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/docker.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 三 2025-10-22 16:44:38 CST; 1 day 1h ago</span><br><span class="line">     Docs: http://docs.docker.io</span><br><span class="line"> Main PID: 16487 (dockerd)</span><br><span class="line">    Tasks: 167</span><br><span class="line">   Memory: 6.1G</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">...</span><br><span class="line">           ├─16506 containerd --config /var/run/docker/containerd/containerd.toml --log-level warn</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>说明 docker 肯定内部协程起了 containerd 进程，低版本 containerd 名字可能是 <code>docker-containerd</code> 。<br>逆向思维查下源码，因为协程起 containerd 进程，肯定会拼接 cmdline，源码搜索 <code>--config</code> 找到：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/moby/moby/blob/v19.03.15/libcontainerd/supervisor/remote_daemon.go#L165C1-L212C5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *remote)</span></span> startContainerd() <span class="type">error</span> &#123;</span><br><span class="line">    pid, err := r.getContainerdPid()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pid != <span class="number">-1</span> &#123;</span><br><span class="line">        r.daemonPid = pid</span><br><span class="line">        logrus.WithField(<span class="string">&quot;pid&quot;</span>, pid).</span><br><span class="line">            Infof(<span class="string">&quot;libcontainerd: %s is still running&quot;</span>, binaryName)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configFile, err := r.getContainerdConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    args := []<span class="type">string</span>&#123;<span class="string">&quot;--config&quot;</span>, configFile&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> r.Debug.Level != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        args = <span class="built_in">append</span>(args, <span class="string">&quot;--log-level&quot;</span>, r.Debug.Level)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmd := exec.Command(binaryName, args...)</span><br><span class="line">    <span class="comment">// redirect containerd logs to docker logs</span></span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line">    cmd.SysProcAttr = containerdSysProcAttr()</span><br><span class="line">    <span class="comment">// clear the NOTIFY_SOCKET from the env when starting containerd</span></span><br><span class="line">    cmd.Env = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> os.Environ() &#123;</span><br><span class="line">        <span class="keyword">if</span> !strings.HasPrefix(e, <span class="string">&quot;NOTIFY_SOCKET&quot;</span>) &#123;</span><br><span class="line">            cmd.Env = <span class="built_in">append</span>(cmd.Env, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.daemonWaitCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Reap our child when needed</span></span><br><span class="line">        <span class="keyword">if</span> err := cmd.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            r.logger.WithError(err).Errorf(<span class="string">&quot;containerd did not exit successfully&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(r.daemonWaitCh)</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure><p>然后反向找 <code>startContainerd()</code> 的调用链：</p><ul><li>同文件的 <code>func (r *remote) monitorDaemon(ctx context.Context) { </code></li><li>同文件的 <code>func Start(</code></li><li>因为 <code>Start</code> 方法大写，肯定在其他地方包导入，搜 <code>supervisor.Start</code> 找到</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/moby/moby/blob/v19.03.15/cmd/dockerd/daemon_unix.go#L152C1-L171</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *DaemonCli)</span></span> initContainerD(ctx context.Context) (<span class="function"><span class="keyword">func</span><span class="params">(time.Duration)</span></span> <span class="type">error</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> waitForShutdown <span class="function"><span class="keyword">func</span><span class="params">(time.Duration)</span></span> <span class="type">error</span></span><br><span class="line">    <span class="keyword">if</span> cli.Config.ContainerdAddr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        systemContainerdAddr, ok, err := systemContainerdRunning(honorXDG)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;could not determine whether the system containerd is running&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            logrus.Debug(<span class="string">&quot;Containerd not running, starting daemon managed containerd&quot;</span>)</span><br><span class="line">        opts, err := cli.getContainerdDaemonOpts()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;failed to generate containerd options&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r, err := supervisor.Start(ctx, filepath.Join(cli.Config.Root, <span class="string">&quot;containerd&quot;</span>), filepath.Join(cli.Config.ExecRoot, <span class="string">&quot;containerd&quot;</span>), opts...)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;failed to start containerd&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        logrus.Debug(<span class="string">&quot;Started daemon managed containerd&quot;</span>)</span><br><span class="line">        cli.Config.ContainerdAddr = r.Address()</span><br></pre></td></tr></table></figure><p>上面代码逻辑就是 <code>systemContainerdRunning</code> 方法判断 <code>containerd</code> 是否运行，没有运行就调用 <code>supervisor.Start</code> 启动 containerd，查看 <code>systemContainerdRunning</code> 内部实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/moby/moby/blob/v19.03.15/cmd/dockerd/daemon.go#L691C1-L702C2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">systemContainerdRunning</span><span class="params">(honorXDG <span class="type">bool</span>)</span></span> (<span class="type">string</span>, <span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    addr := containerddefaults.DefaultAddress</span><br><span class="line">    <span class="keyword">if</span> honorXDG &#123;</span><br><span class="line">        runtimeDir, err := homedir.GetRuntimeDir()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">false</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        addr = filepath.Join(runtimeDir, <span class="string">&quot;containerd&quot;</span>, <span class="string">&quot;containerd.sock&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    _, err := os.Lstat(addr)</span><br><span class="line">    <span class="keyword">return</span> addr, err == <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是查看连接 containerd 的 grpc sock 文件 <code>/run/containerd/containerd.sock</code> 存在否判断是否运行的，也就是说如果 systemd 启动了 containerd，docker daemon 就不 <code>supervisor.Start</code> 启动 containerd 子进程。</p><p>现场的是 suse docker rpm 包安装的，有 containerd 的 rpm 包，才发现里面没 service 文件，也就是走源码子进程逻辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -ql containerd</span></span><br><span class="line">/etc/containerd</span><br><span class="line">/etc/containerd/config.toml/usr/sbin/containerd</span><br><span class="line">/usr/sbin/containerd-shim</span><br><span class="line">/usr/sbin/docker-containerd</span><br><span class="line">/usr/sbin/docker-containerd-shim</span><br><span class="line">/usr/share/doc/packages/containerd</span><br><span class="line">/usr/share/doc/packages/containerd/README</span><br><span class="line">/usr/share/licenses/containerd</span><br><span class="line">/usr/share/licenses/containerd/LICENSE</span><br></pre></td></tr></table></figure><p>查看果然是有 sock 文件而没 containerd 进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /run/containerd/</span></span><br><span class="line">total 28</span><br><span class="line">srw-rw---- 1 root root     0 Oct 23 15:20 containerd.sock</span><br><span class="line">-rwxr-xr-x 1 root root 25651 Oct 23 15:26 events.log</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef | grep container[d]</span></span><br></pre></td></tr></table></figure><p>删掉该文件后重起 docker 解决。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单科普下 docker 启动时候和 contaienrd 相关&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://zhangguanzhang.github.io/tags/docker/"/>
    
    <category term="containerd" scheme="http://zhangguanzhang.github.io/tags/containerd/"/>
    
  </entry>
  
  <entry>
    <title>keepalived Locking pid file error 22 - Invalid argument</title>
    <link href="http://zhangguanzhang.github.io/2025/10/17/keepalived-locking-pid-file-invalid/"/>
    <id>http://zhangguanzhang.github.io/2025/10/17/keepalived-locking-pid-file-invalid/</id>
    <published>2025-10-17T18:10:30.000Z</published>
    <updated>2025-10-17T18:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>现场部署业务后发现访问有问题，排查后发现业务网关访问 etcd 的 <a href="https://zhangguanzhang.github.io/2021/09/28/ipvs-svc/">keepalived IPVS svc</a> 不通</p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><h3 id="基础排查"><a href="#基础排查" class="headerlink" title="基础排查"></a>基础排查</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl 169.254.20.4:12379</span></span><br><span class="line">curl: (7) Failed to connect to 169.254.20.4 port 12379: Connection refused</span><br></pre></td></tr></table></figure><p>这个是我们 etcd 的 svc 的，curl <code>real server</code> 正常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl &lt;本机IP&gt;:12379</span><br></pre></td></tr></table></figure><p>然后看了下 <code>iptables -t filter -S</code> 无额外规则，怕客户安全加固啥的前面 insert 了规则影响。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysctl --all |&amp; grep vs.conn</span></span><br><span class="line">net.ipv4.vs.conn_reuse_mode = 1</span><br><span class="line">net.ipv4.vs.conntrack = 1</span><br></pre></td></tr></table></figure><p><code>vs.conntrack</code> 正常，不是 0，查看下 ipvs 规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> keepalived-ipvs ipvsadm -<span class="built_in">ln</span> | grep -A3 169.254.20.4</span></span><br></pre></td></tr></table></figure><p>现场说为空，让去掉 grep 直接看也是为空：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> keepalived-ipvs ipvsadm -<span class="built_in">ln</span></span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br></pre></td></tr></table></figure><p>让看下 keepalived 日志，发现有个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">daemon is already running</span><br><span class="line">Locking pid file /run/keepalived.pid error 22 - Invalid argument</span><br><span class="line">Opening file &#x27;/etc/keepalived/conf.d/xxx.conf&#x27;.</span><br><span class="line">Opening file &#x27;/etc/keepalived/conf.d/xxx2.conf&#x27;.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>因为 keepalived 容器需要操作 lvs 规则，所以是有 <code>privileged: true</code> 的，感觉还是内核相关问题导致的，那就看源码了。我们用的 keepalived 版本是最新的 <code>v2.3.4</code> ，搜索源码 <code>Locking pid file</code> 搜到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/acassen/keepalived/blob/v2.3.4/keepalived/core/pidfile.c#L183-L194</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_DECL_F_OFD_SETLK == 1</span></span><br><span class="line">    fl.l_pid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ret = fcntl(pidf-&gt;fd, F_OFD_SETLK, &amp;fl)) &amp;&amp; errno == EINTR);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">        log_message(LOG_INFO, <span class="string">&quot;Another process has pid file %s locked&quot;</span>, pidf-&gt;path);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        log_message(LOG_INFO, <span class="string">&quot;Locking pid file %s error %d - %m&quot;</span>, pidf-&gt;path, errno);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>看这个宏定义内的代码就是 fcntl 使用 <code>F_OFD_SETLK</code> 针对 Pid 文件上锁，这个特性是内核特性，现场是 CentOS 7.4 ，内核版本 <code>3.10.0-693.el7.x86_64</code>，想看下这块提交，于是下载源码后找到下面俩个 commmit：</p><ul><li><a href="https://github.com/acassen/keepalived/commit/2c4cd3b927e5f12f59c62481261621b70375a304">https://github.com/acassen/keepalived/commit/2c4cd3b927e5f12f59c62481261621b70375a304</a></li><li><a href="https://github.com/acassen/keepalived/commit/7d2b85d1f03d3ae2944237c60c3eeb5edc4fa12a">https://github.com/acassen/keepalived/commit/7d2b85d1f03d3ae2944237c60c3eeb5edc4fa12a</a></li></ul><p>第一个 commit 是增加 Pid 锁，第二个是允许宏定义不用这个特性在老系统上构建，利用 autoconf 检测支持 <code>F_OFD_SETLK</code> 不。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>因为我们使用的是容器化部署，基础镜像换成欧拉了，而欧拉的包管理安装的 keepalived 版本太低，所以我是 Dockerfile 内编译安装的 keepalived，而构建这个镜像的机器的内核比较高，只能构建的时候传递选项关闭了。</p><p>影响面也不需要关注，因为是容器，并且镜像的启动脚本内我在启动的时候先删除 pid 文件的，无脑编译关闭即可，不要 hack 修改代码，autoconf 啥的都是大家遵守的规范，主要是 <code>configure.ac</code> 下面的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dnl -- Linux 3.15</span><br><span class="line">AC_CHECK_DECLS([F_OFD_SETLK], [], [],</span><br><span class="line">  [[</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    #include &lt;fcntl.h&gt;</span><br><span class="line">  ]])</span><br><span class="line">for flag in F_OFD_SETLK; do</span><br><span class="line">  AS_VAR_COPY([decl_var], [ac_cv_have_decl_$flag])</span><br><span class="line">  if test $&#123;decl_var&#125; = yes; then</span><br><span class="line">    add_system_opt[$&#123;flag&#125;]</span><br><span class="line">  fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>看下面逻辑，<code>&quot;ac_cv_have_decl_&quot;+&quot;F_OFD_SETLK&quot;=&quot;yes&quot;</code> ，在 <code>./configure</code> 后面加就行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    ./autogen.sh; \</span><br><span class="line">    ./configure ac_cv_have_decl_F_OFD_SETLK=no \</span><br><span class="line">        --disable-dynamic-linking \</span><br><span class="line">        --prefix=/usr \</span><br><span class="line">        --exec-prefix=/usr \</span><br><span class="line">        --bindir=/usr/bin \</span><br><span class="line">        --sbindir=/usr/sbin \</span><br><span class="line">        --sysconfdir=/etc \</span><br><span class="line">        --enable-nftables \</span><br><span class="line">        --enable-regex \</span><br><span class="line">        --disable-systemd \</span><br><span class="line">        ; \</span><br></pre></td></tr></table></figure><p>编译打包镜像后测试没问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;由来&quot;&gt;&lt;a href=&quot;#由来&quot; class=&quot;headerlink&quot; title=&quot;由来&quot;&gt;&lt;/a&gt;由来&lt;/h2&gt;&lt;p&gt;现场部署业务后发现访问有问题，排查后发现业务网关访问 etcd 的 &lt;a href=&quot;https://zhangguanzhang.gith</summary>
      
    
    
    
    
    <category term="keepalived" scheme="http://zhangguanzhang.github.io/tags/keepalived/"/>
    
    <category term="fnctl" scheme="http://zhangguanzhang.github.io/tags/fnctl/"/>
    
  </entry>
  
  <entry>
    <title>从自己造轮子NodePort白名单到参考 calico 规则</title>
    <link href="http://zhangguanzhang.github.io/2025/10/15/k8s-NodePort-filter/"/>
    <id>http://zhangguanzhang.github.io/2025/10/15/k8s-NodePort-filter/</id>
    <published>2025-10-15T10:10:30.000Z</published>
    <updated>2025-10-15T10:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>研究下 calico 如何实现 nodePort 白名单。</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>由于我们做私有化，很多客户注重安全，需要有类似 <code>NetworkPolicy</code> 那样做白名单限制来源，而 calico 最小化部署的话下面配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.tigera.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Installation</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># https://docs.tigera.io/calico/latest/reference/installation/api#installationspec</span></span><br><span class="line">  <span class="attr">calicoNetwork:</span> <span class="comment"># https://docs.tigera.io/calico/latest/reference/installation/api#caliconetworkspec</span></span><br><span class="line">    <span class="attr">ipPools:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default-ipv4-ippool</span></span><br><span class="line">      <span class="attr">blockSize:</span> <span class="number">24</span> <span class="comment"># node 上分配到的 PodIP 的掩码，默认26，我喜欢改成24方便阅读</span></span><br><span class="line">      <span class="attr">cidr:</span> <span class="number">10.187</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">      <span class="attr">encapsulation:</span> <span class="string">VXLANCrossSubnet</span> <span class="comment"># https://docs.tigera.io/calico/latest/reference/installation/api#encapsulationtype</span></span><br><span class="line">      <span class="attr">natOutgoing:</span> <span class="string">Enabled</span></span><br><span class="line">      <span class="attr">nodeSelector:</span> <span class="string">all()</span></span><br><span class="line">    <span class="attr">nodeAddressAutodetectionV4:</span> <span class="comment"># https://docs.tigera.io/calico/latest/reference/installation/api#nodeaddressautodetection</span></span><br><span class="line">      <span class="attr">canReach:</span> <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="string">m.daocloud.io/quay.io</span> <span class="comment"># https://docs.tigera.io/calico/latest/operations/image-options/alternate-registry</span></span><br><span class="line">  <span class="attr">flexVolumePath:</span> <span class="string">None</span> <span class="comment"># 设置为None 不安装 CSI 相关</span></span><br><span class="line">  <span class="attr">kubeletVolumePluginPath:</span> <span class="string">None</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">operator.tigera.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">APIServer</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>下都会部署很多组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl -n calico-system get deploy</span></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">calico-kube-controllers   1/1     1            1           6d3h</span><br><span class="line">calico-typha              1/1     1            1           6d3h</span><br><span class="line">goldmane                  1/1     1            1           6d1h</span><br><span class="line">whisker                   1/1     1            1           6d1h</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl -n calico-apiserver get deploy</span></span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">calico-apiserver   2/2     2            2           6d1h</span><br></pre></td></tr></table></figure><p>而且很多客户机器配置不高，所以我们使用 flannel，而网络策略这块有实现一个 agent 容器做 iptables 规则白名单，非 K8S 下 docker 也可以用。某个版本开始有部分业务需要 NodePort 暴漏用于外部上传备份文件，但是考虑到客户安全要求，所以需要 <code>NodePort</code> 做白名单限制。<br>如果对 iptables 不熟悉，可能会下意识的去 <code>INPUT</code> 链去做，实际是不行的，NodePort 在 nat 表里 <code>PREROUTING</code> 先匹配做 nat 的，拿如下 svc 做说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Name:                     my-service</span><br><span class="line">Namespace:                default</span><br><span class="line">Labels:                   &lt;none&gt;</span><br><span class="line">Annotations:              &lt;none&gt;</span><br><span class="line">Selector:                 nodePort=test</span><br><span class="line">Type:                     NodePort</span><br><span class="line">IP Family Policy:         SingleStack</span><br><span class="line">IP Families:              IPv4</span><br><span class="line">IP:                       10.186.158.205</span><br><span class="line">IPs:                      10.186.158.205</span><br><span class="line">Port:                     &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:               80/TCP</span><br><span class="line">NodePort:                 &lt;unset&gt;  30008/TCP</span><br><span class="line">Endpoints:                10.187.220.19:80</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br></pre></td></tr></table></figure><p>相关 nat 表下的 <code>PRETOUTING</code> 链如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">入口</span></span><br><span class="line">-A PREROUTING -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line">-A KUBE-SERVICES -m comment --comment &quot;kubernetes service nodeports; NOTE: this must be the last rule in this chain&quot; -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS</span><br><span class="line">-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/my-service&quot; -m tcp --dport 30008 -j KUBE-EXT-FXIYY6OHUSNBITIX</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nodePort 匹配之前先打 snat mark，再是下面的 KUBE-SVC-FXIYY6OHUSNBITIX svc 的 dnat 链</span></span><br><span class="line">-A KUBE-EXT-FXIYY6OHUSNBITIX -m comment --comment &quot;masquerade traffic for default/my-service external destinations&quot; -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-EXT-FXIYY6OHUSNBITIX -j KUBE-SVC-FXIYY6OHUSNBITIX</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">svc 的 dnat 链</span></span><br><span class="line">-A KUBE-SVC-FXIYY6OHUSNBITIX -d 10.186.158.205/32 -p tcp -m comment --comment &quot;default/my-service cluster IP&quot; -m tcp --dport 80 -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SVC-FXIYY6OHUSNBITIX -m comment --comment &quot;default/my-service -&gt; 10.187.220.19:80&quot; -j KUBE-SEP-DPGHCWFA3YQKRCGQ</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">svc 的 endpoint 链</span></span><br><span class="line">-A KUBE-SEP-DPGHCWFA3YQKRCGQ -s 10.187.220.19/32 -m comment --comment &quot;default/my-service&quot; -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-DPGHCWFA3YQKRCGQ -p tcp -m comment --comment &quot;default/my-service&quot; -m tcp -j DNAT --to-destination 10.187.220.19:80</span><br></pre></td></tr></table></figure><p>等走到 INPUT 后，目标 IP 和 port 都经过了 dnat了，所以不能在 INPUT 拦截匹配，同理 docker -p 暴漏的端口也是一样。所以之前我是在 raw 表的 <code>PREROUTING</code> 里做的。</p><h2 id="规则问题"><a href="#规则问题" class="headerlink" title="规则问题"></a>规则问题</h2><p>设计的规则是一个 ipset 存白名单端口列表，一个是 ip 白名单，规则如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t raw -S PREROUTING</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回程 conntrack 状态放行</span></span><br><span class="line">-A PREROUTING -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">来源 IP 不是白名单 IP，但是目标端口是白名单端口就拒绝</span></span><br><span class="line">-A PREROUTING -m set ! --match-set whiteiplist src -m set --match-set whiteportlist dst -j DROP</span><br></pre></td></tr></table></figure><p>然后测了下发现没问题，后面时不时收到实施反馈客户现场环境上，服务作为客户端访问外部低概率超时，抓包发现本机上访问外部 server，server 回包被阻断：</p><ul><li>本机上作为 client 访问外部，发送 SYN 包</li><li>外部 server 给本机发送 SYN-ACK 被阻断</li></ul><p>根据 iptables 统计数据看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t raw -nvL PREROUTING</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"> 162M   64G ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line"> 20   1604 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ! match-set whiteiplist src match-set whiteportlist dst</span><br></pre></td></tr></table></figure><p>发现就是 raw 的这个规则匹配 DROP 的，排查发现，某个版本开始后，把白名单端口增加很多，例如 <code>49100-49500</code> 之类的（INPUT 链我们也在用 whiteportlist），在 <code>ip_local_port_range</code> 范围内，刚好客户端使用就会发生：</p><ul><li>本机请求外部 server，分配的 <code>local_port</code> 是 <code>whiteportlist</code> 例如：<code>49123</code></li><li>外部回包，此刻没有被 <code>conntrack</code> 标记为 <code>ESTABLISHED</code> 状态，走到下一条规则</li><li>然后命中下一条就被 DROP</li></ul><p>使用 tcp 编程复现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">49123</span>))</span><br><span class="line">s.connect((<span class="string">&#x27;39.156.70.37&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">s.send(<span class="string">b&#x27;GET / HTTP/1.1\r\nHost: www.baidu.com\r\n\r\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.recv(<span class="number">1024</span>))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p><code>39.156.70.37</code> 为百度域名 IP，执行后卡住，查看统计信息增加了也符合：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清空 PREROUTING 统计信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t raw -Z PREROUTING</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python test.py</span></span><br><span class="line">^C</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t raw -nvL PREROUTING</span></span><br></pre></td></tr></table></figure><p>看来 raw 如字面意思，太原始了。</p><h2 id="calico"><a href="#calico" class="headerlink" title="calico"></a>calico</h2><p>研究下 calico 如何实现的，单机干净 K8S 集群上部署了 calico ，看了下 operator 安装的 calico 版本为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images | grep calico/node</span></span><br><span class="line">m.daocloud.io/quay.io/calico/node                           v3.30.3                                  ce9c4ac0f175   7 weeks ago    401MB</span><br></pre></td></tr></table></figure><p>本文的规则研究以 <code>v3.30.3</code> 版本为准。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>先部署一个 NodePort：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-hostname</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">m.daocloud.io/docker.io/library/nginx:alpine</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30008</span></span><br></pre></td></tr></table></figure><p>相关信息存档，后续生效的策略对比：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -w -t raw -S &gt; raw</span><br><span class="line">iptables -w -t nat -S &gt; nat</span><br><span class="line">iptables -w -t mangle -S &gt; mangle</span><br><span class="line">iptables -w -S &gt; filter</span><br><span class="line">ipset list &gt; ipset</span><br></pre></td></tr></table></figure><h3 id="GlobalNetworkPolicy"><a href="#GlobalNetworkPolicy" class="headerlink" title="GlobalNetworkPolicy"></a>GlobalNetworkPolicy</h3><p>谷歌搜到官方文档<a href="https://docs.tigera.io/calico/latest/network-policy/services/kubernetes-node-ports">network-policy kubernetes-node-ports</a>，使用的是 <code>GlobalNetworkPolicy</code>，看了下文档，calico 的这个 CRD 相对于 <code>NetworkPolicy</code> 范围更广，它可以控制主机层面，而非 <code>NetworkPolicy</code> 只控制 ns 和 Pod 策略，根据文档例子写了下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">projectcalico.org/v3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">GlobalNetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">allow-cluster-nodeport-only</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="comment"># 常规使用是配合兜底策略，优先级高的前面放行，优先级最低的是拒绝，也就是白名单策略。或者优先级最低的是放行，优先级高的是DROP，也就是黑名单策略</span></span><br><span class="line"><span class="comment"># 这里我是只测试，写出下面规则</span></span><br><span class="line">  <span class="attr">order:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">preDNAT:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">applyOnForward:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">Allow</span></span><br><span class="line">      <span class="attr">source:</span></span><br><span class="line">        <span class="attr">nets:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="number">10.</span><span class="string">xxx.41.110/32</span> <span class="comment"># 自身 IP</span></span><br><span class="line">         <span class="bullet">-</span> <span class="number">10.</span><span class="string">xxx.195.118/32</span> <span class="comment"># 外部测试 IP</span></span><br><span class="line">         <span class="bullet">-</span> <span class="number">10.187</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span> <span class="comment"># Pod CIDR</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">Deny</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">ports:</span> [<span class="number">30008</span>]</span><br><span class="line">  <span class="attr">selector:</span> <span class="string">has(kubernetes.io/os)</span></span><br></pre></td></tr></table></figure><p>apply 后发现 iptables 的所有表里都没有规则增加，官方文档说选择器可以选 node 的，但是实际测试不行，看官方文档其他地方有使用 <code>kind: HostEndpoint</code> 配合 <code>selector</code> ，设置下自动创建 hep 还是不行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl patch kubecontrollersconfigurations default \</span></span><br><span class="line"><span class="language-bash">  --<span class="built_in">type</span>=merge -p <span class="string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;controllers&quot;: &#123;&quot;node&quot;:&#123;&quot;hostEndpoint&quot;:&#123;&quot;autoCreate&quot;: &quot;Enabled&quot;&#125;&#125;&#125;&#125;&#125;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get hep -l kubernetes.io/os</span></span><br><span class="line">NAME                     CREATED AT</span><br><span class="line">10.xxx.xx.170-auto-hep   2025-10-15T09:18:37</span><br></pre></td></tr></table></figure><p>看了下选择器文档，直接改成 <code>selector: all()</code> 后可以了，外部 IP 不在上面的白名单里 curl nodeport 不通</p><h2 id="规则研究"><a href="#规则研究" class="headerlink" title="规则研究"></a>规则研究</h2><p>导出现在规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -w -t raw -S &gt; raw2</span><br><span class="line">iptables -w -t nat -S &gt; nat2</span><br><span class="line">iptables -w -t mangle -S &gt; mangle2</span><br><span class="line">iptables -w -S &gt; filter2</span><br></pre></td></tr></table></figure><h3 id="新增规则"><a href="#新增规则" class="headerlink" title="新增规则"></a>新增规则</h3><p>对比：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff mangle*</span></span><br><span class="line">10a11</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-N cali-failsafe-in</span></span><br><span class="line">11a13</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-N cali-fh-any-interface-at-all</span></span><br><span class="line">12a15</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-N cali-pi-_Ddz2TLFtYPs0Zt3iUZs</span></span><br><span class="line">25a29,37</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-failsafe-in -p tcp -m comment --comment <span class="string">&quot;cali:wWFQM43tJU7wwnFZ&quot;</span> -m multiport --dports 22 -j ACCEPT</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-failsafe-in -p udp -m comment --comment <span class="string">&quot;cali:LwNV--R8MjeUYacw&quot;</span> -m multiport --dports 68 -j ACCEPT</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-failsafe-in -p tcp -m comment --comment <span class="string">&quot;cali:QOO5NUOqOSS1_Iw0&quot;</span> -m multiport --dports 179 -j ACCEPT</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-failsafe-in -p tcp -m comment --comment <span class="string">&quot;cali:cwZWoBSwVeIAZmVN&quot;</span> -m multiport --dports 2379 -j ACCEPT</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-failsafe-in -p tcp -m comment --comment <span class="string">&quot;cali:7FbNXT91kugE_upR&quot;</span> -m multiport --dports 2380 -j ACCEPT</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-failsafe-in -p tcp -m comment --comment <span class="string">&quot;cali:8Ftbkk2dRH2eEeq1&quot;</span> -m multiport --dports 5473 -j ACCEPT</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-failsafe-in -p tcp -m comment --comment <span class="string">&quot;cali:-JoRSaAQZPJAegMo&quot;</span> -m multiport --dports 6443 -j ACCEPT</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-failsafe-in -p tcp -m comment --comment <span class="string">&quot;cali:PUKij4Rn9njHfVTi&quot;</span> -m multiport --dports 6666 -j ACCEPT</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-failsafe-in -p tcp -m comment --comment <span class="string">&quot;cali:vSprVE-4rient0wc&quot;</span> -m multiport --dports 6667 -j ACCEPT</span></span><br><span class="line">34a47,64</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-fh-any-interface-at-all -m comment --comment <span class="string">&quot;cali:CCbcqJXqEISzSqnH&quot;</span> -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-fh-any-interface-at-all -m comment --comment <span class="string">&quot;cali:mmvu-cTJXJ7YH9Lp&quot;</span> -m conntrack --ctstate INVALID -j DROP</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-fh-any-interface-at-all -m comment --comment <span class="string">&quot;cali:NnqjZhu9yccY4C7-&quot;</span> -j cali-failsafe-in</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-fh-any-interface-at-all -m comment --comment <span class="string">&quot;cali:AtciE88iDfq0ah2L&quot;</span> -j MARK --set-xmark 0x0/0x30000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-fh-any-interface-at-all -m comment --comment <span class="string">&quot;cali:BZMMxJKaVi8hIM9r&quot;</span> -m comment --comment <span class="string">&quot;Start of tier default&quot;</span> -j MARK --set-xmark 0x0/0x20000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-fh-any-interface-at-all -m comment --comment <span class="string">&quot;cali:_hnIU4TYdSt--CFh&quot;</span> -m mark --mark 0x0/0x20000 -j cali-pi-_Ddz2TLFtYPs0Zt3iUZs</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-fh-any-interface-at-all -m comment --comment <span class="string">&quot;cali:-n3Ama1WlBcv-Yv9&quot;</span> -m comment --comment <span class="string">&quot;Return if policy accepted&quot;</span> -m mark --mark 0x10000/0x10000 -j RETURN</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-from-host-endpoint -m comment --comment <span class="string">&quot;cali:0MLuqUx2SPsTwgBS&quot;</span> -g cali-fh-any-interface-at-all</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment <span class="string">&quot;cali:5eFTXO3b0B-Tbiq8&quot;</span> -m comment --comment <span class="string">&quot;Policy default.allow-cluster-nodeport-only ingress&quot;</span> -j MARK --set-xmark 0x0/0x180000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -s 10.xxx.41.110/32 -m comment --comment <span class="string">&quot;cali:L5TwSbHWsELZIAEd&quot;</span> -j MARK --set-xmark 0x80000/0x80000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -s 10.xxx.195.118/32 -m comment --comment <span class="string">&quot;cali:noUEAlswvbgG5j7d&quot;</span> -j MARK --set-xmark 0x80000/0x80000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -s 10.187.0.0/16 -m comment --comment <span class="string">&quot;cali:TxEjJz-IsLiJzVDK&quot;</span> -j MARK --set-xmark 0x80000/0x80000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment <span class="string">&quot;cali:SBosizM5mtjxTsOe&quot;</span> -m mark --mark 0x80000/0x80000 -j MARK --set-xmark 0x10000/0x10000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment <span class="string">&quot;cali:5w4NEetZaXhF7wjm&quot;</span> -m mark --mark 0x10000/0x10000 -j NFLOG --nflog-prefix  <span class="string">&quot;API0|default.allow-cluster-nodeport-only&quot;</span> --nflog-group 1 --nflog-range 80</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment <span class="string">&quot;cali:NMym66CfdBVWGhc6&quot;</span> -m mark --mark 0x10000/0x10000 -j RETURN</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -p tcp -m comment --comment <span class="string">&quot;cali:HONlGpSGnitWLUh-&quot;</span> -m multiport --dports 30008 -j MARK --set-xmark 0x40000/0x40000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment <span class="string">&quot;cali:9vcFh92OaOMP06xg&quot;</span> -m mark --mark 0x40000/0x40000 -j NFLOG --nflog-prefix  <span class="string">&quot;DPI1|default.allow-cluster-nodeport-only&quot;</span> --nflog-group 1 --nflog-range 80</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">-A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment <span class="string">&quot;cali:URAeOCUsDbThanFp&quot;</span> -m mark --mark 0x40000/0x40000 -j DROP</span></span><br></pre></td></tr></table></figure><p>主要是多了三个链：</p><ul><li><code>cali-failsafe-in</code></li><li><code>cali-fh-any-interface-at-all</code></li><li><code>cali-pi-_Ddz2TLFtYPs0Zt3iUZs</code></li></ul><p><code>cali-failsafe-in</code> 链如名字所示，兜底策略，先放行 ssh&#x2F;etcd&#x2F;kube-apiserver 之类端口 ，避免配置错误网络策略后导致机器集群无法连上，涉及到的端口见官方文档 <a href="https://docs.tigera.io/calico/latest/reference/host-endpoints/failsafe">failsafe</a>，对于新增过滤规则的都会先跳到这个链。</p><p>后面俩链是具体 <code>cali-pi-_Ddz2TLFtYPs0Zt3iUZs</code> 里做处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; -A cali-fh-any-interface-at-all -m comment --comment &quot;cali:_hnIU4TYdSt--CFh&quot; -m mark --mark 0x0/0x20000 -j cali-pi-_Ddz2TLFtYPs0Zt3iUZs</span><br></pre></td></tr></table></figure><p>来懒人办法，清理掉链的统计信息看生效在哪块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t mangle -Z cali-pi-_Ddz2TLFtYPs0Zt3iUZs</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t mangle -nvL cali-pi-_Ddz2TLFtYPs0Zt3iUZs</span></span><br><span class="line">Chain cali-pi-_Ddz2TLFtYPs0Zt3iUZs (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">   10   600 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:5eFTXO3b0B-Tbiq8 */ /* Policy default.allow-cluster-nodeport-only ingress */ MARK and 0xffe7ffff</span><br><span class="line">    0     0 MARK       all  --  *      *       10.xxx.41.110        0.0.0.0/0            /* cali:L5TwSbHWsELZIAEd */ MARK or 0x80000</span><br><span class="line">    0     0 MARK       all  --  *      *       10.xxx.195.118       0.0.0.0/0            /* cali:noUEAlswvbgG5j7d */ MARK or 0x80000</span><br><span class="line">    0     0 MARK       all  --  *      *       10.187.0.0/16        0.0.0.0/0            /* cali:TxEjJz-IsLiJzVDK */ MARK or 0x80000</span><br><span class="line">    0     0 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:SBosizM5mtjxTsOe */ mark match 0x80000/0x80000 MARK or 0x10000</span><br><span class="line">    0     0 NFLOG      all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:5w4NEetZaXhF7wjm */ mark match 0x10000/0x10000 nflog-prefix  &quot;API0|default.allow-cluster-nodeport-only&quot; nflog-group 1 nflog-range 80</span><br><span class="line">    0     0 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:NMym66CfdBVWGhc6 */ mark match 0x10000/0x10000</span><br><span class="line">    0     0 MARK       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:HONlGpSGnitWLUh- */ multiport dports 30008 MARK or 0x40000</span><br><span class="line">    0     0 NFLOG      all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:9vcFh92OaOMP06xg */ mark match 0x40000/0x40000 nflog-prefix  &quot;DPI1|default.allow-cluster-nodeport-only&quot; nflog-group 1 nflog-range 80</span><br><span class="line">    0     0 DROP       all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:URAeOCUsDbThanFp */ mark match 0x40000/0x40000</span><br></pre></td></tr></table></figure><p>然后外部的不在白名单里的 curl 下 NodePort，再看下统计信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t mangle -nvL cali-pi-_Ddz2TLFtYPs0Zt3iUZs</span></span><br><span class="line">Chain cali-pi-_Ddz2TLFtYPs0Zt3iUZs (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">   44  2640 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:5eFTXO3b0B-Tbiq8 */ /* Policy default.allow-cluster-nodeport-only ingress */ MARK and 0xffe7ffff</span><br><span class="line">    0     0 MARK       all  --  *      *       10.xxx.41.110        0.0.0.0/0            /* cali:L5TwSbHWsELZIAEd */ MARK or 0x80000</span><br><span class="line">    0     0 MARK       all  --  *      *       10.xxx.195.118       0.0.0.0/0            /* cali:noUEAlswvbgG5j7d */ MARK or 0x80000</span><br><span class="line">    0     0 MARK       all  --  *      *       10.187.0.0/16        0.0.0.0/0            /* cali:TxEjJz-IsLiJzVDK */ MARK or 0x80000</span><br><span class="line">    0     0 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:SBosizM5mtjxTsOe */ mark match 0x80000/0x80000 MARK or 0x10000</span><br><span class="line">    0     0 NFLOG      all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:5w4NEetZaXhF7wjm */ mark match 0x10000/0x10000 nflog-prefix  &quot;API0|default.allow-cluster-nodeport-only&quot; nflog-group 1 nflog-range 80</span><br><span class="line">    0     0 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:NMym66CfdBVWGhc6 */ mark match 0x10000/0x10000</span><br><span class="line">    2   120 MARK       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:HONlGpSGnitWLUh- */ multiport dports 30008 MARK or 0x40000</span><br><span class="line">    2   120 NFLOG      all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:9vcFh92OaOMP06xg */ mark match 0x40000/0x40000 nflog-prefix  &quot;DPI1|default.allow-cluster-nodeport-only&quot; nflog-group 1 nflog-range 80</span><br><span class="line">    2   120 DROP       all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* cali:URAeOCUsDbThanFp */ mark match 0x40000/0x40000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实就是用 mark 做条件 flag 匹配处理，主要看这几个规则就行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; -A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment &quot;cali:5eFTXO3b0B-Tbiq8&quot; -m comment --comment &quot;Policy default.allow-cluster-nodeport-only ingress&quot; -j MARK --set-xmark 0x0/0x180000</span><br><span class="line">&gt; -A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -s 10.xxx.41.110/32 -m comment --comment &quot;cali:L5TwSbHWsELZIAEd&quot; -j MARK --set-xmark 0x80000/0x80000</span><br><span class="line">&gt; -A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -s 10.xxx.195.118/32 -m comment --comment &quot;cali:noUEAlswvbgG5j7d&quot; -j MARK --set-xmark 0x80000/0x80000</span><br><span class="line">&gt; -A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -s 10.187.0.0/16 -m comment --comment &quot;cali:TxEjJz-IsLiJzVDK&quot; -j MARK --set-xmark 0x80000/0x80000</span><br><span class="line">&gt; -A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment &quot;cali:SBosizM5mtjxTsOe&quot; -m mark --mark 0x80000/0x80000 -j MARK --set-xmark 0x10000/0x10000</span><br><span class="line">&gt; -A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment &quot;cali:5w4NEetZaXhF7wjm&quot; -m mark --mark 0x10000/0x10000 -j NFLOG --nflog-prefix  &quot;API0|default.allow-cluster-nodeport-only&quot; --nflog-group 1 --nflog-range 80</span><br><span class="line">&gt; -A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment &quot;cali:NMym66CfdBVWGhc6&quot; -m mark --mark 0x10000/0x10000 -j RETURN</span><br><span class="line">&gt; -A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -p tcp -m comment --comment &quot;cali:HONlGpSGnitWLUh-&quot; -m multiport --dports 30008 -j MARK --set-xmark 0x40000/0x40000</span><br><span class="line">&gt; -A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment &quot;cali:9vcFh92OaOMP06xg&quot; -m mark --mark 0x40000/0x40000 -j NFLOG --nflog-prefix  &quot;DPI1|default.allow-cluster-nodeport-only&quot; --nflog-group 1 --nflog-range 80</span><br><span class="line">&gt; -A cali-pi-_Ddz2TLFtYPs0Zt3iUZs -m comment --comment &quot;cali:URAeOCUsDbThanFp&quot; -m mark --mark 0x40000/0x40000 -j DROP</span><br></pre></td></tr></table></figure><ul><li>白名单会打上 <code>0x80000/0x80000</code> 标记</li><li><code>-m mark --mark 0x80000/0x80000 -j MARK --set-xmark 0x10000/0x10000</code> 匹配上 <code>0x80000/0x80000</code> 的打新 mark <code>0x10000/0x10000</code> ，这里按照二进制理解，两者都存在</li><li><code>--mark 0x10000/0x10000 -j NFLOG</code> 匹配 <code>0x10000/0x10000</code> 的在 NFLOG 上记录，可以用 <code>tcpdump -i nflog:1</code> 抓包，配合前面一条也就是命中规则的才会 NFLOG</li><li><code>--mark 0x10000/0x10000 -j RETURN</code> 白名单命中放行的此刻不往下走</li><li><code>-m multiport --dports 30008 -j MARK --set-xmark 0x40000/0x40000</code> 访问的是 NodePort 打上标记</li><li><code>--mark 0x40000/0x40000 -j NFLOG</code> 记录，再往下走</li><li><code>--mark 0x40000/0x40000 -j DROP</code> 扔掉报文</li></ul><h3 id="mangle-的-PREROUTING"><a href="#mangle-的-PREROUTING" class="headerlink" title="mangle 的 PREROUTING"></a>mangle 的 PREROUTING</h3><p>相关流程都在 mangle 里:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t mangle -S PREROUTING</span></span><br><span class="line">-P PREROUTING ACCEPT</span><br><span class="line">-A PREROUTING -m comment --comment &quot;cali:6gwbT8clXdHdC1b1&quot; -j cali-PREROUTING</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t mangle -S cali-PREROUTING</span></span><br><span class="line">-N cali-PREROUTING</span><br><span class="line">-A cali-PREROUTING -m comment --comment &quot;cali:6BJqBjBC7crtA-7-&quot; -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A cali-PREROUTING -m comment --comment &quot;cali:KX7AGNd6rMcDUai6&quot; -m mark --mark 0x10000/0x10000 -j ACCEPT</span><br><span class="line">-A cali-PREROUTING -m comment --comment &quot;cali:wNH7KsA3ILKJBsY9&quot; -j cali-from-host-endpoint</span><br><span class="line">-A cali-PREROUTING -m comment --comment &quot;cali:Cg96MgVuoPm7UMRo&quot; -m comment --comment &quot;Host endpoint policy accepted packet.&quot; -m mark --mark 0x10000/0x10000 -j ACCEPT</span><br></pre></td></tr></table></figure><p>然后是 <code>cali-from-host-endpoint</code> 里，如果没有 return 就无法走到下面的 <code>&quot;Host endpoint policy accepted packet.&quot; -m mark --mark 0x10000/0x10000 -j ACCEPT</code>，而它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t mangle -S cali-from-host-endpoint</span></span><br><span class="line">-N cali-from-host-endpoint</span><br><span class="line">-A cali-from-host-endpoint -m comment --comment &quot;cali:0MLuqUx2SPsTwgBS&quot; -g cali-fh-any-interface-at-all</span><br></pre></td></tr></table></figure><p>可以看到它会走到上面新增的 diff 规则里，这是整个流程。</p><h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><p>calico 负责 iptables 规则的是 felix</p><h3 id="链名字"><a href="#链名字" class="headerlink" title="链名字"></a>链名字</h3><p><a href="https://github.com/projectcalico/calico/blob/v3.30.3/felix/rules/rule_defs.go">https://github.com/projectcalico/calico/blob/v3.30.3/felix/rules/rule_defs.go</a></p><h3 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h3><p>相关 mark 值源码里找到：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/projectcalico/calico/blob/v3.30.3/felix/dataplane/driver.go#L156-L164</span></span><br><span class="line">log.WithFields(log.Fields&#123;</span><br><span class="line"><span class="string">&quot;acceptMark&quot;</span>:          markAccept,</span><br><span class="line"><span class="string">&quot;passMark&quot;</span>:            markPass,</span><br><span class="line"><span class="string">&quot;dropMark&quot;</span>:            markDrop,</span><br><span class="line"><span class="string">&quot;scratch0Mark&quot;</span>:        markScratch0,</span><br><span class="line"><span class="string">&quot;scratch1Mark&quot;</span>:        markScratch1,</span><br><span class="line"><span class="string">&quot;endpointMark&quot;</span>:        markEndpointMark,</span><br><span class="line"><span class="string">&quot;endpointMarkNonCali&quot;</span>: markEndpointNonCaliEndpoint,</span><br><span class="line">&#125;).Info(<span class="string">&quot;Calculated iptables mark bits&quot;</span>)</span><br></pre></td></tr></table></figure><p>查看日志，下面便于阅读加几个换行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs d96d | grep <span class="string">&#x27;Calculated iptables mark bits&#x27;</span></span></span><br><span class="line">2025-10-15 08:54:06.100 [INFO][85] felix/driver.go 164: Calculated iptables mark bits </span><br><span class="line">acceptMark=0x10000 </span><br><span class="line">dropMark=0x40000 </span><br><span class="line">endpointMark=0xffe00000 </span><br><span class="line">endpointMarkNonCali=0x0 </span><br><span class="line">passMark=0x20000 </span><br><span class="line">scratch0Mark=0x80000 </span><br><span class="line">scratch1Mark=0x100000</span><br></pre></td></tr></table></figure><h3 id="host-ipset"><a href="#host-ipset" class="headerlink" title="host ipset"></a>host ipset</h3><p>发现 calico 有一个 ipset 存储了本机上的网卡 IP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Name: cali40this-host</span><br><span class="line">Type: hash:ip</span><br><span class="line">Revision: 4</span><br><span class="line">Header: family inet hashsize 1024 maxelem 1048576</span><br><span class="line">Size in memory: 456</span><br><span class="line">References: 0</span><br><span class="line">Number of entries: 7</span><br><span class="line">Members:</span><br><span class="line">127.0.0.1</span><br><span class="line">169.254.20.10</span><br><span class="line">10.187.220.0</span><br><span class="line">10.185.0.1</span><br><span class="line">10.xxx.xx.xxx #本机IP</span><br><span class="line">10.186.0.2</span><br></pre></td></tr></table></figure><p>相关代码在：</p><p><a href="https://github.com/projectcalico/calico/blob/v3.30.3/felix/daemon/daemon.go#L179">https://github.com/projectcalico/calico/blob/v3.30.3/felix/daemon/daemon.go#L179</a><br><a href="https://github.com/projectcalico/calico/blob/v3.30.3/felix/config/config_params.go#L1067">https://github.com/projectcalico/calico/blob/v3.30.3/felix/config/config_params.go#L1067</a></p><p>查看相关日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs calico-node | grep int_dataplane.go</span></span><br><span class="line">2025-10-15 08:54:06.562 [INFO][85] felix/int_dataplane.go 2063: Started internal iptables dataplane driver loop</span><br><span class="line">2025-10-15 08:54:06.562 [INFO][85] felix/int_dataplane.go 2180: Will refresh IP sets on timer interval=1m30s</span><br><span class="line">2025-10-15 08:54:06.562 [INFO][85] felix/int_dataplane.go 2180: Will refresh routes on timer interval=1m30s</span><br><span class="line">2025-10-15 08:54:06.562 [INFO][85] felix/int_dataplane.go 2618: Started internal status report thread</span><br><span class="line">2025-10-15 08:54:06.562 [INFO][85] felix/int_dataplane.go 2620: Process status reports disabled</span><br><span class="line">2025-10-15 08:54:06.565 [INFO][85] felix/int_dataplane.go 1590: Linux interface state changed. ifIndex=1 ifaceName=&quot;lo&quot; state=&quot;up&quot;</span><br><span class="line">2025-10-15 08:54:06.565 [INFO][85] felix/int_dataplane.go 2259: Received interface update msg=&amp;intdataplane.ifaceStateUpdate&#123;Name:&quot;lo&quot;, State:&quot;up&quot;, Index:1&#125;</span><br><span class="line">2025-10-15 08:54:06.565 [INFO][85] felix/int_dataplane.go 1634: Linux interface addrs changed. addrs=set.Set&#123;127.0.0.0,127.0.0.1,::1,fe80::ecee:eeff:feee:eeee&#125; ifaceName=&quot;lo&quot;</span><br><span class="line">2025-10-15 08:54:06.565 [INFO][85] felix/int_dataplane.go 1590: Linux interface state changed. ifIndex=2 ifaceName=&quot;ens192&quot; state=&quot;up&quot;</span><br><span class="line">2025-10-15 08:54:06.565 [INFO][85] felix/int_dataplane.go 2286: Received interface addresses update msg=&amp;intdataplane.ifaceAddrsUpdate&#123;Name:&quot;lo&quot;, Addrs:set.Typed[string]&#123;&quot;127.0.0.0&quot;:set.v&#123;&#125;, &quot;127.0.0.1&quot;:set.v&#123;&#125;, &quot;::1&quot;:set.v&#123;&#125;, &quot;fe80::ecee:eeff:feee:eeee&quot;:set.v&#123;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>看了下源码获取网卡 IP 逻辑在 <a href="https://github.com/projectcalico/calico/blob/v3.30.3/felix/ifacemonitor/iface_monitor.go">felix&#x2F;ifacemonitor&#x2F;iface_monitor.go</a> ，主要是使用 Linux netlink 接口获取网卡和变更添加删除消息监听，然后执行 OnUpdate ：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/projectcalico/calico/blob/v3.30.3/felix/dataplane/linux/hostip_mgr.go#L81-L103</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *hostIPManager)</span></span> OnUpdate(msg <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="keyword">switch</span> msg := msg.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *ifaceAddrsUpdate:</span><br><span class="line">log.WithField(<span class="string">&quot;update&quot;</span>, msg).Info(<span class="string">&quot;Interface addrs changed.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> m.nonHostIfacesRegexp.MatchString(msg.Name) &#123;</span><br><span class="line">log.WithField(<span class="string">&quot;update&quot;</span>, msg).Debug(<span class="string">&quot;Not a real host interface, ignoring.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msg.Addrs != <span class="literal">nil</span> &#123;</span><br><span class="line">m.hostIfaceToAddrs[msg.Name] = msg.Addrs</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(m.hostIfaceToAddrs, msg.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Host ip update is a relative rare event. Flush entire ipsets to make it simple.</span></span><br><span class="line">metadata := ipsets.IPSetMetadata&#123;</span><br><span class="line">Type:    ipsets.IPSetTypeHashIP,</span><br><span class="line">SetID:   m.hostIPSetID,</span><br><span class="line">MaxSize: m.maxSize,</span><br><span class="line">&#125;</span><br><span class="line">m.ipsetsDataplane.AddOrReplaceIPSet(metadata, m.getCurrentMembers())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul><li>一个 ipset 存储白名单 <code>whiteiplist</code>，匹配上就 ACCEPT</li><li>一个 ipset 存储 Port <code>whiteportlist</code>，此刻还匹配就说明不是白名单走过来，打 mark 2</li><li>匹配到 mark 2 则 DROP</li></ul><p>如果有问题，可以某个地方再加一个规则打上 mark 1 来热修。</p><h3 id="mangle-表"><a href="#mangle-表" class="headerlink" title="mangle 表"></a>mangle 表</h3><p>由于我们只使用 flannel，并且也不需要各种情况，所以就不用 mark 处理了，所以也只是像 calico 那样在 mangle 的 PRETOUTING 做链 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先创建链</span></span><br><span class="line">iptables --wait --table mangle --new test-PREROUTING</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插入 mangle 表的 PREROUTING 链前面</span></span><br><span class="line">iptables --wait --table mangle --insert PREROUTING --jump test-PREROUTING</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放行已建立的连接</span></span><br><span class="line">iptables --wait --table mangle --insert test-PREROUTING -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建单独的链</span></span><br><span class="line">iptables --wait --table mangle --new test-from-host-endpoint</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配行为在 test-from-host-endpoint 里做，有问题在它前面 INSERT 规则即可</span></span><br><span class="line">iptables --wait --table mangle --append test-PREROUTING -j test-from-host-endpoint</span><br></pre></td></tr></table></figure><h3 id="test-from-host-endpoint-链"><a href="#test-from-host-endpoint-链" class="headerlink" title="test-from-host-endpoint 链"></a>test-from-host-endpoint 链</h3><p>拆成两个是可以后续再 <code>test-from-host-endpoint</code> 前 insert 本机网卡 IP 或者可以添加类似 <code>failsafe-in</code> 之类的 ipset 之类的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">白名单 IP 直接放行</span></span><br><span class="line">iptables --wait --table mangle --append test-from-host-endpoint -m set --match-set whiteiplist src -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">非白名单 ip 访问白名单端口拒绝</span></span><br><span class="line">iptables --wait --table mangle --append test-from-host-endpoint -m set --match-set whiteportlist dst -j DROP</span><br></pre></td></tr></table></figure><p>filter 表的 INPUT 链里我们也加了下类似 this-host 的逻辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -j BASE-RULE</span><br><span class="line"></span><br><span class="line">-A BASE-RULE -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A BASE-RULE -m set --match-set whiteiplist src -j ACCEPT</span><br><span class="line">-A BASE-RULE -m set --match-set this-host src -j ACCEPT</span><br><span class="line">-A BASE-RULE -m set --match-set whiteportlist dst -j DROP</span><br></pre></td></tr></table></figure><h2 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h2><p>支持双栈，支持获取网卡IP，ipv6 根据 ipv6list 和 <code>cat /proc/sys/net/ipv6/conf/all/disable_ipv6</code> 值做开关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Name: this-host</span><br><span class="line">Type: hash:net</span><br><span class="line">Revision: 6</span><br><span class="line">Header: family inet hashsize 1024 maxelem 1000000</span><br><span class="line">Size in memory: 568</span><br><span class="line">References: 1</span><br><span class="line">Number of entries: 3</span><br><span class="line">Members:</span><br><span class="line">127.0.0.0/24</span><br><span class="line">10.xx.94.189</span><br><span class="line">169.254.0.0/16</span><br><span class="line"></span><br><span class="line">Name: whiteipv6list</span><br><span class="line">Type: hash:net</span><br><span class="line">Revision: 6</span><br><span class="line">Header: family inet6 hashsize 1024 maxelem 1000000</span><br><span class="line">Size in memory: 1608</span><br><span class="line">References: 2</span><br><span class="line">Number of entries: 4</span><br><span class="line">Members:</span><br><span class="line">2408:8656:22df:ff01::14:1620</span><br><span class="line">2408:8656:22df:ff01::14:1621</span><br><span class="line">::1</span><br><span class="line">2408:8656:22df:ff01::14:1622</span><br><span class="line"></span><br><span class="line">Name: this-host6</span><br><span class="line">Type: hash:net</span><br><span class="line">Revision: 6</span><br><span class="line">Header: family inet6 hashsize 1024 maxelem 1000000</span><br><span class="line">Size in memory: 1496</span><br><span class="line">References: 1</span><br><span class="line">Number of entries: 3</span><br><span class="line">Members:</span><br><span class="line">ee80:169:254:20::/64</span><br><span class="line">2408:8656:22df:ff01::14:1620</span><br><span class="line">::1</span><br><span class="line"></span><br><span class="line">Name: whiteportlist</span><br><span class="line">Type: bitmap:port</span><br><span class="line">Revision: 3</span><br><span class="line">Header: range 0-65535</span><br><span class="line">Size in memory: 8296</span><br><span class="line">References: 4</span><br><span class="line">Number of entries: 230</span><br><span class="line">Members:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一些仅供他人参考的 shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function get_if_inet()&#123;</span><br><span class="line">  local if=$1</span><br><span class="line">  ip -4 -o a s $if | awk &#x27;&#123;print $4&#125;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function this_host()&#123;</span><br><span class="line">  ipset create this-host hash:net maxelem 1000000 -exist</span><br><span class="line">  ipset add this-host 127.0.0.1/24 -exist</span><br><span class="line">  ipset add this-host 169.254.0.0/16 -exist</span><br><span class="line"></span><br><span class="line">  if [ -d /sys/devices/virtual/net/cni0/ ];then</span><br><span class="line">    ipset add this-host $(get_if_inet cni0| sed &#x27;s#/\d+#/16#&#x27;) -exist</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  ip -o -4 a s scope global | grep -Ev &#x27;:\s+(cali|tunl|vxlan|flannel|docker0|veth|wireguard|wg|cni0|kube|dummy|veth)&#x27; | awk -F&#x27;[ /]+&#x27; &#x27;&#123;print $4&#125;&#x27;| \</span><br><span class="line">  while read ip;do</span><br><span class="line">    ipset add this-host $ip -exist</span><br><span class="line">  done</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_if_inet6()&#123;</span><br><span class="line">  local if=$1 ignore=$2 inet6</span><br><span class="line">  inet6=ip -6 -o a s $if | awk &#x27;&#123;print $4&#125;&#x27;</span><br><span class="line">  if [ -n &quot;$ignore&quot; ];then</span><br><span class="line">    inet6=$(echo $inet6 | grep -Ev &quot;$2&quot;)</span><br><span class="line">  fi</span><br><span class="line">  echo $inet6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function this_host6()&#123;</span><br><span class="line">  ipset create this-host6 hash:net maxelem 1000000 family inet6 -exist</span><br><span class="line">  ipset add this-host6 ::1 -exist</span><br><span class="line"></span><br><span class="line">  if [ -d /sys/devices/virtual/net/cni0/ ];then</span><br><span class="line">    cni0_inet6=$(get_if_inet6 cni0| sed &#x27;s#/\d+#/56#&#x27;)</span><br><span class="line">    if [ -n &quot;$cni0_inet6&quot; ];then</span><br><span class="line">      ipset add this-host6 $cni0_inet6 -exist</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  ip -o -6 a s scope global | grep -Ev &#x27;:\s+(cali|tunl|vxlan|flannel|docker0|veth|wireguard|wg|cni0|kube|dummy|veth)&#x27; |\</span><br><span class="line">   grep -Ev &#x27;^fe80::.+/64&#x27; | awk -F&#x27;[ /]+&#x27; &#x27;&#123;print $4&#125;&#x27;| \</span><br><span class="line">  while read ip;do</span><br><span class="line">    ipset add this-host6 $ip -exist</span><br><span class="line">  done</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;研究下 calico 如何实现 nodePort 白名单。&lt;/p&gt;</summary>
    
    
    
    
    <category term="kubernetes" scheme="http://zhangguanzhang.github.io/tags/kubernetes/"/>
    
    <category term="nodeport" scheme="http://zhangguanzhang.github.io/tags/nodeport/"/>
    
  </entry>
  
  <entry>
    <title>hostNetwork下hostname的坑</title>
    <link href="http://zhangguanzhang.github.io/2025/10/13/k8s-hostNetwork-hostname/"/>
    <id>http://zhangguanzhang.github.io/2025/10/13/k8s-hostNetwork-hostname/</id>
    <published>2025-10-13T10:10:30.000Z</published>
    <updated>2025-10-13T10:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级和压测遇到的 hostNetwork 下 hostname 的坑问题</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>性能压测团队压测后发现 kafka 的数据目录下有俩个很大的目录给机器目录占满：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total 88</span><br><span class="line">drwxr-xr-x 568 nfsnobody nfsnobody 28672 Oct  1 17:42 kafka-logs-kafka-1</span><br><span class="line">drwxr-xr-x 535 nfsnobody nfsnobody 28672 Sep 26 19:51 kafka-logs-vm10-7-131-94</span><br></pre></td></tr></table></figure><h2 id="大小问题"><a href="#大小问题" class="headerlink" title="大小问题"></a>大小问题</h2><p>大小问题是因为 kafka 默认配置 <code>log.retention.bytes = -1</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> docker logs 2d21e7 |&amp; grep -P <span class="string">&#x27;^\s+log\.retention&#x27;</span></span></span><br><span class="line">log.retention.bytes = -1</span><br><span class="line">log.retention.check.interval.ms = 150000</span><br><span class="line">log.retention.hours = 168</span><br><span class="line">log.retention.minutes = null</span><br><span class="line">log.retention.ms = null</span><br></pre></td></tr></table></figure><p>查看了下 kafka 的启动脚本，支持 env 配置，配置下 <code>KAFKA_LOG_RETENTION_BYTES: &quot;1073741824&quot;</code> 后测试没问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终端1写入topic</span></span><br><span class="line">for i in &#123;1..1000&#125;; do head -c 102400000 /dev/urandom | base64 |kafka-console-producer.sh --bootstrap-server 127.0.0.1:9092  --topic test; done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终端2 观察</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -shx *; <span class="built_in">ls</span> -lh test-0</span></span><br><span class="line">0cleaner-offset-checkpoint</span><br><span class="line">4.0Klog-start-offset-checkpoint</span><br><span class="line">4.0Kmeta.properties</span><br><span class="line">4.0Krecovery-point-offset-checkpoint</span><br><span class="line">4.0Kreplication-offset-checkpoint</span><br><span class="line">3.5Gtest-0</span><br><span class="line">3.5Gtest-1</span><br><span class="line">总用量 3.5G</span><br><span class="line">-rwxr-xr-x 1 65534 65534 514K 10月 13 17:58 00000000000012487638.index.deleted</span><br><span class="line">-rwxr-xr-x 1 65534 65534 1.0G 10月 13 17:58 00000000000012487638.log.deleted</span><br><span class="line">-rwxr-xr-x 1 65534 65534 355K 10月 13 17:58 00000000000012487638.timeindex.deleted</span><br><span class="line">-rwxr-xr-x 1 65534 65534 517K 10月 13 19:02 00000000000024975185.index</span><br><span class="line">-rwxr-xr-x 1 65534 65534 1.0G 10月 13 19:02 00000000000024975185.log</span><br><span class="line">-rwxr-xr-x 1 65534 65534 4.0K 10月 13 17:58 00000000000024975185.snapshot</span><br><span class="line">-rwxr-xr-x 1 65534 65534 372K 10月 13 19:02 00000000000024975185.timeindex</span><br><span class="line">-rwxr-xr-x 1 65534 65534 4.1K 10月 13 18:02 00000000000027453871.snapshot</span><br><span class="line">-rw-r--r-- 1 65534 65534  10M 10月 13 19:02 00000000000037462545.index</span><br><span class="line">-rw-r--r-- 1 65534 65534 430M 10月 13 19:02 00000000000037462545.log</span><br><span class="line">-rw-r--r-- 1 65534 65534 4.6K 10月 13 19:02 00000000000037462545.snapshot</span><br><span class="line">-rw-r--r-- 1 65534 65534  10M 10月 13 19:02 00000000000037462545.timeindex</span><br><span class="line">-rw-r--r-- 1 65534 65534   15 10月 13 19:03 leader-epoch-checkpoint</span><br><span class="line">-rwxr-xr-x 1 65534 65534   43 10月 13 17:33 partition.metadata</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -shx *; <span class="built_in">ls</span> -lh test-0</span></span><br><span class="line">0cleaner-offset-checkpoint</span><br><span class="line">4.0Klog-start-offset-checkpoint</span><br><span class="line">4.0Kmeta.properties</span><br><span class="line">4.0Krecovery-point-offset-checkpoint</span><br><span class="line">4.0Kreplication-offset-checkpoint</span><br><span class="line">1.5Gtest-0</span><br><span class="line">1.5Gtest-1</span><br><span class="line">总用量 1.5G</span><br><span class="line">-rwxr-xr-x 1 65534 65534 517K 10月 13 19:02 00000000000024975185.index</span><br><span class="line">-rwxr-xr-x 1 65534 65534 1.0G 10月 13 19:02 00000000000024975185.log</span><br><span class="line">-rwxr-xr-x 1 65534 65534 4.0K 10月 13 17:58 00000000000024975185.snapshot</span><br><span class="line">-rwxr-xr-x 1 65534 65534 372K 10月 13 19:02 00000000000024975185.timeindex</span><br><span class="line">-rwxr-xr-x 1 65534 65534 4.1K 10月 13 18:02 00000000000027453871.snapshot</span><br><span class="line">-rw-r--r-- 1 65534 65534  10M 10月 13 19:02 00000000000037462545.index</span><br><span class="line">-rw-r--r-- 1 65534 65534 430M 10月 13 19:02 00000000000037462545.log</span><br><span class="line">-rw-r--r-- 1 65534 65534 4.6K 10月 13 19:02 00000000000037462545.snapshot</span><br><span class="line">-rw-r--r-- 1 65534 65534  10M 10月 13 19:02 00000000000037462545.timeindex</span><br><span class="line">-rw-r--r-- 1 65534 65534   15 10月 13 19:03 leader-epoch-checkpoint</span><br><span class="line">-rwxr-xr-x 1 65534 65534   43 10月 13 17:33 partition.metadata</span><br></pre></td></tr></table></figure><h2 id="hostname-问题"><a href="#hostname-问题" class="headerlink" title="hostname 问题"></a>hostname 问题</h2><h3 id="两个带-hostname-目录的问题"><a href="#两个带-hostname-目录的问题" class="headerlink" title="两个带 hostname 目录的问题"></a>两个带 hostname 目录的问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://github.com/wurstmeister/kafka-docker/blob/master/start-kafka.sh#L43C1-L45C3</span></span><br><span class="line">if [[ -z &quot;$KAFKA_LOG_DIRS&quot; ]]; then</span><br><span class="line">    export KAFKA_LOG_DIRS=&quot;/kafka/kafka-logs-$HOSTNAME&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>从启动脚本看到上面逻辑，没有设置就拼接 hostname，指定 <code>KAFKA_LOG_DIRS</code> 成固定，再修改启动脚本支持升级后把老目录 mv 成不带 hostname 的唯一目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ -n &quot;$KAFKA_LOG_DIRS&quot; ] &amp;&amp; ! [ -d &quot;$KAFKA_LOG_DIRS&quot; ];then</span><br><span class="line">latest_log_dir=$(ls -1 -t -d /kafka/kafka-logs-* | head -n1)</span><br><span class="line">if [ -n &quot;$latest_log_dir&quot; ];then</span><br><span class="line">echo &quot;found old kafka-logs-: $&#123;latest_log_dir&#125;&quot;</span><br><span class="line">mv -v $latest_log_dir $KAFKA_LOG_DIRS</span><br><span class="line">fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="hostname-问题-1"><a href="#hostname-问题-1" class="headerlink" title="hostname 问题"></a>hostname 问题</h3><p>两个目录问题还是要查找原因的，出现的场景是在我们 kafka 之前是 staticPod + hostPath 部署的，后面切成 docker-compose 部署后发生的，相关配置为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># staticPod</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostname:</span> <span class="string">kafka-&#123;&#123;</span> <span class="string">MY_ID</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker-compose</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka-&#123;&#123;</span> <span class="string">kafka.MY_ID</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>而仔细看 mtime：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total 88</span><br><span class="line">drwxr-xr-x 568 nfsnobody nfsnobody 28672 Oct  1 17:42 kafka-logs-kafka-1</span><br><span class="line">drwxr-xr-x 535 nfsnobody nfsnobody 28672 Sep 26 19:51 kafka-logs-vm10-7-131-94</span><br></pre></td></tr></table></figure><p><code>-kafka-1</code> 是最新的，也就是说 docker-compose 没问题，而 k8s 的容器获取到的是宿主机的 hostname，验证了下确实：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -ti --entrypoint hostname --net host --hostname test111 m.daocloud.io/docker.io/library/nginx:alpine</span> </span><br><span class="line">test111</span><br></pre></td></tr></table></figure><p>测试 <code>hostNetwork</code> 和 <code>hostname</code> 一起下，容器的 hostname 是宿主机的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-hostname</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">m.daocloud.io/docker.io/library/nginx:alpine</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostname:</span> <span class="string">test111</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>一开始想着是 cri-dockerd 的 bug，想着去再提交一个 pr ，于是先让群友 containerd 环境 K8S 测下，好拿信息去提交 pr。结果发现 containerd K8S 下也一样是宿主机的 hostname，搜索了下后发现：</p><p><a href="https://github.com/kubernetes/kubernetes/issues/67019">https://github.com/kubernetes/kubernetes/issues/67019</a></p><p>是 K8S 代码逻辑导致的，看了下 issue，看到有 pr 关联 <a href="https://github.com/kubernetes/kubernetes/pull/132558/files">KEP-4762: Allows setting any FQDN as the pod’s hostname</a> 是新版本里加了个特性 <code>features.HostnameOverride</code> 门控和字段 <code>HostnameOverride</code>，但是看了下描述，发现压根不是一回事：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">HostnameOverride</span> <span class="string">specifies</span> <span class="string">an</span> <span class="string">explicit</span> <span class="string">override</span> <span class="string">for</span> <span class="string">the</span> <span class="string">pod&#x27;s</span> <span class="string">hostname</span> <span class="string">as</span> <span class="string">perceived</span> <span class="string">by</span> <span class="string">the</span> <span class="string">pod.</span></span><br><span class="line"><span class="string">//</span> <span class="string">This</span> <span class="string">field</span> <span class="string">only</span> <span class="string">specifies</span> <span class="string">the</span> <span class="string">pod&#x27;s</span> <span class="string">hostname</span> <span class="string">and</span> <span class="string">does</span> <span class="string">not</span> <span class="string">affect</span> <span class="string">its</span> <span class="string">DNS</span> <span class="string">records.</span></span><br><span class="line"><span class="string">//</span> <span class="attr">When this field is set to a non-empty string:</span></span><br><span class="line"><span class="string">//</span> <span class="bullet">-</span> <span class="string">It</span> <span class="string">takes</span> <span class="string">precedence</span> <span class="string">over</span> <span class="string">the</span> <span class="string">values</span> <span class="string">set</span> <span class="string">in</span> <span class="string">`hostname`</span> <span class="string">and</span> <span class="string">`subdomain`.</span></span><br><span class="line"><span class="string">//</span> <span class="bullet">-</span> <span class="string">The</span> <span class="string">Pod&#x27;s</span> <span class="string">hostname</span> <span class="string">will</span> <span class="string">be</span> <span class="string">set</span> <span class="string">to</span> <span class="string">this</span> <span class="string">value.</span></span><br><span class="line"><span class="string">//</span> <span class="bullet">-</span> <span class="string">`setHostnameAsFQDN`</span> <span class="string">must</span> <span class="string">be</span> <span class="string">nil</span> <span class="string">or</span> <span class="string">set</span> <span class="string">to</span> <span class="string">false.</span></span><br><span class="line"><span class="string">//</span> <span class="bullet">-</span> <span class="string">`hostNetwork`</span> <span class="string">must</span> <span class="string">be</span> <span class="string">set</span> <span class="string">to</span> <span class="string">false.</span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//</span> <span class="string">This</span> <span class="string">field</span> <span class="string">must</span> <span class="string">be</span> <span class="string">a</span> <span class="string">valid</span> <span class="string">DNS</span> <span class="string">subdomain</span> <span class="string">as</span> <span class="string">defined</span> <span class="string">in</span> <span class="string">RFC</span> <span class="number">1123 </span><span class="string">and</span> <span class="string">contain</span> <span class="string">at</span> <span class="string">most</span> <span class="number">64</span> <span class="string">characters.</span></span><br><span class="line"><span class="string">//</span> <span class="string">Requires</span> <span class="string">the</span> <span class="string">HostnameOverride</span> <span class="string">feature</span> <span class="string">gate</span> <span class="string">to</span> <span class="string">be</span> <span class="string">enabled.</span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//</span> <span class="string">+featureGate=HostnameOverride</span></span><br><span class="line"><span class="string">//</span> <span class="string">+optional</span></span><br><span class="line"><span class="string">HostnameOverride</span> <span class="meta">*string</span></span><br></pre></td></tr></table></figure><p>注意看上面的 <code>hostNetwork must be set to false.</code> ，新版本的这个特性压根解决不了这个问题，只能是自己踩坑了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>截止目前为止，k8s 的 Pod 同时配置 <code>hostNetwork</code> 和 <code>hostname</code> 下，容器内的 hostname 是宿主机的，docker 直接起这样配置的容器则没问题，如果你的进程依赖 hostname，则要注意这块。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近升级和压测遇到的 hostNetwork 下 hostname 的坑问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="kubernetes" scheme="http://zhangguanzhang.github.io/tags/kubernetes/"/>
    
    <category term="hostname" scheme="http://zhangguanzhang.github.io/tags/hostname/"/>
    
  </entry>
  
  <entry>
    <title>个别节点上 flannel.1 的 IP 无法 ping</title>
    <link href="http://zhangguanzhang.github.io/2025/09/23/flannel.1-cannot-ping/"/>
    <id>http://zhangguanzhang.github.io/2025/09/23/flannel.1-cannot-ping/</id>
    <published>2025-09-23T10:10:30.000Z</published>
    <updated>2025-09-23T10:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>一次客户环境上个别节点 flannel.1 的 IP 无法 ping 的排查</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>客户反馈他们环境 agent 告警监控： 本机上的 IP <code>10.187.12.0</code> 无法 ping 通。</p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><h3 id="定位范围"><a href="#定位范围" class="headerlink" title="定位范围"></a>定位范围</h3><p>客户环境不能远程，都是发命令让查的，查看 flannel 容器均没有重启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docekr ps -a | grep flanneld</span></span><br><span class="line">cb0e35b00899   1e0b2bff6efb               &quot;/opt/bin/flanneld -…&quot;   7 weeks ago   Up 7 weeks                                k8s_kube-flannel_kube-flannel-ds-qbps5_kube-system_bffc6d17-0835-468d-bb90-2367c190c94f_0</span><br></pre></td></tr></table></figure><p>让客户去告警机器上 ping，客户说 cni0 地址是通的，就 <code>10.187.12.0</code> 和 <code>10.187.11.0</code> 无法 ping 通，沟通一番才意识到是这俩 ip 在各自本机上无法 ping 通，直接 ping 报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 10.187.12.0</span></span><br><span class="line">Do you want to ping broadcast? Then -b. If not, check your local firewall rules.</span><br></pre></td></tr></table></figure><p>看了下 <code>flannel.1</code> 和 <code>cni0</code> 的 IP 信息也没问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip a s flannel.1</span></span><br><span class="line">9: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UNKNOWN group default </span><br><span class="line">    link/ether 4e:81:e2:84:ff:49 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.187.12.0/32 scope global flannel.1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::4c81:e2ff:fe84:ff49/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip a s cni0</span></span><br><span class="line">7: cni0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 02:e6:56:fb:18:3d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.187.12.1/24 brd 10.187.12.255 scope global cni0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::e6:56ff:fefb:183d/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>看了下内核参数也正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>去搜下源码看看，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qf `<span class="built_in">which</span> ping`</span></span><br><span class="line">iputils-20190709-5.ky10.aarch64</span><br></pre></td></tr></table></figure><p>搜到源码 iputils 没特殊处理逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/iputils/iputils/blob/master/ping/ping.c#L885-L895</span></span><br><span class="line"></span><br><span class="line">sock_setmark(rts, probe_fd);</span><br><span class="line"></span><br><span class="line">dst.sin_port = htons(<span class="number">1025</span>);</span><br><span class="line"><span class="keyword">if</span> (rts-&gt;nroute)</span><br><span class="line">dst.sin_addr.s_addr = rts-&gt;route[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (connect(probe_fd, (<span class="keyword">struct</span> sockaddr *)&amp;dst, <span class="keyword">sizeof</span>(dst)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EACCES) &#123;</span><br><span class="line"><span class="keyword">if</span> (rts-&gt;broadcast_pings == <span class="number">0</span>)</span><br><span class="line">error(<span class="number">2</span>, <span class="number">0</span>,</span><br><span class="line">_(<span class="string">&quot;Do you want to ping broadcast? Then -b. If not, check your local firewall rules&quot;</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, _(<span class="string">&quot;WARNING: pinging broadcast address\n&quot;</span>));</span><br></pre></td></tr></table></figure><p>完全走的系统层面分配，获取到的地址是广播地址才报错，看下路由：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route show</span></span><br><span class="line">default via xxx dev enp4s0</span><br><span class="line">....</span><br><span class="line">10.187.12.0/24 dev cni0 proto kernel scope link src 10.187.12.1</span><br></pre></td></tr></table></figure><p>但是路由匹配就有问题了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route get 10.187.12.0</span></span><br><span class="line">broadcast 10.187.12.0 dev cni0 src 10.187.12.1 uid 58248</span><br><span class="line">    cache &lt;local,brd&gt;</span><br></pre></td></tr></table></figure><p>看来问题就在路由这块，<code>ip route show</code> 实际是 <code>ip route show talbe main</code> 看下由网卡生成的 local 路由表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route show table <span class="built_in">local</span> | grep 10.187.12.0</span></span><br><span class="line">broadcast 10.187.12.0 dev cni0 proto kernel scope link src 10.187.12.1 </span><br><span class="line">local 10.187.12.0 dev flannel.1 proto kernel scope host src 10.187.12.0</span><br></pre></td></tr></table></figure><p>果然是顺序导致，local 路由表是根据网卡顺序生成的，前面细心的话会发现 <code>flannel.1</code> 前面数字是 9，<code>cni0</code> 是 7，意味着 <code>cni0</code> 比 <code>flannel.1</code> 先创建，或者是 <code>flannel.1</code> 网卡删除后重启 flanneld 容器创建的。</p><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>内部找个 k8s 环境测试下复现了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip a s flannel.1</span></span><br><span class="line">6: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UNKNOWN group default </span><br><span class="line">    link/ether 4a:53:ae:34:23:99 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.187.2.0/32 scope global flannel.1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::4853:aeff:fe34:2399/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 10.187.2.0</span></span><br><span class="line">PING 10.187.2.0 (10.187.2.0) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.187.2.0: icmp_seq=1 ttl=64 time=0.042 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.187.2.0 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.042/0.042/0.042/0.000 ms</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip <span class="built_in">link</span> delete flannel.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a | grep flanneld</span></span><br><span class="line">46079b620076   reg.xxx.lan:5000/xxx/flannel                                                     &quot;/opt/bin/flanneld -…&quot;   8 days ago       Up 8 days </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker restart 460</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 10.187.2.0</span></span><br><span class="line">Do you want to ping broadcast? Then -b. If not, check your local firewall rules.</span><br></pre></td></tr></table></figure><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>添加 32 位掩码路由不行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route add 10.187.2.0/32 dev flannel.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 10.187.2.0</span></span><br><span class="line">Do you want to ping broadcast? Then -b. If not, check your local firewall rules.</span><br></pre></td></tr></table></figure><p>因为 local 先匹配：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route show table <span class="built_in">local</span> | grep 10.187.2.0</span></span><br><span class="line">broadcast 10.187.2.0 dev cni0 proto kernel scope link src 10.187.2.1 </span><br><span class="line">local 10.187.2.0 dev flannel.1 proto kernel scope host src 10.187.2.0 </span><br></pre></td></tr></table></figure><p>删除后可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route delete broadcast 10.187.2.0 dev cni0 proto kernel scope <span class="built_in">link</span> src 10.187.2.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route show</span></span><br><span class="line">...</span><br><span class="line">10.185.0.0/16 dev docker0 proto kernel scope link src 10.185.0.1 </span><br><span class="line">10.187.0.0/24 via 10.187.0.0 dev flannel.1 onlink </span><br><span class="line">10.187.1.0/24 via 10.187.1.0 dev flannel.1 onlink </span><br><span class="line">10.187.2.0/24 dev cni0 proto kernel scope link src 10.187.2.1 </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route show table <span class="built_in">local</span>  | grep 10.187.2.0</span></span><br><span class="line">local 10.187.2.0 dev flannel.1 proto kernel scope host src 10.187.2.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 10.187.2.0</span></span><br><span class="line">PING 10.187.2.0 (10.187.2.0) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.187.2.0: icmp_seq=1 ttl=64 time=0.074 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.187.2.0 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.074/0.074/0.074/0.000 ms</span><br></pre></td></tr></table></figure><p>测下跨节点也没问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 10.187.0.1</span></span><br><span class="line">PING 10.187.0.1 (10.187.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.187.0.1: icmp_seq=1 ttl=64 time=0.365 ms</span><br><span class="line">64 bytes from 10.187.0.1: icmp_seq=2 ttl=64 time=0.325 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.187.0.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.325/0.345/0.365/0.020 ms</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>虽然这个细节问题不影响 k8s overlay 网络，但是客户监控告警要查清楚原因。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一次客户环境上个别节点 flannel.1 的 IP 无法 ping 的排查&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="http://zhangguanzhang.github.io/tags/linux/"/>
    
    <category term="flannel" scheme="http://zhangguanzhang.github.io/tags/flannel/"/>
    
  </entry>
  
  <entry>
    <title>salt-run很久才返回</title>
    <link href="http://zhangguanzhang.github.io/2025/09/12/salt-run-hang/"/>
    <id>http://zhangguanzhang.github.io/2025/09/12/salt-run-hang/</id>
    <published>2025-09-12T20:10:30.000Z</published>
    <updated>2025-09-12T20:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>一次 salt-run 很久才返回的排查</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>所有 salt-run 命令耗时都很久</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ time salt-run jobs.active</span><br><span class="line">[INFO    ] Runner completed: 20250912111420062465_14113</span><br><span class="line"></span><br><span class="line">real0m23.432s</span><br><span class="line">user0m2.716s</span><br><span class="line">sys0m0.320s</span><br></pre></td></tr></table></figure><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>salt-master 是容器里运行的，该容器没 ptrace 权限，怕重启容器后故障无了。就容器内执行卡住后看下宿主机进程 salt-run 是唯一的，宿主机上有 strace 命令，strace 看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">strace -p `ps -ef | grep -E <span class="string">&#x27;salt-ru[n]&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">openat(AT_FDCWD, &quot;/etc/hosts&quot;, O_RDONLY|O_CLOEXEC) = 11</span><br><span class="line">fstat(11, &#123;st_mode=S_IFREG|0644, st_size=898, ...&#125;) = 0</span><br><span class="line">lseek(11, 0, SEEK_SET)                  = 0</span><br><span class="line">read(11, &quot;#\n# hosts         This file desc&quot;..., 4096) = 898</span><br><span class="line">read(11, &quot;&quot;, 4096)                      = 0</span><br><span class="line">close(11)                               = 0</span><br><span class="line">newfstatat(AT_FDCWD, &quot;/etc/nsswitch.conf&quot;, &#123;st_mode=S_IFREG|0644, st_size=1516, ...&#125;, 0) = 0</span><br><span class="line">newfstatat(AT_FDCWD, &quot;/etc/resolv.conf&quot;, &#123;st_mode=S_IFREG|0644, st_size=211, ...&#125;, 0) = 0</span><br><span class="line">openat(AT_FDCWD, &quot;/etc/hosts&quot;, O_RDONLY|O_CLOEXEC) = 11</span><br><span class="line">fstat(11, &#123;st_mode=S_IFREG|0644, st_size=898, ...&#125;) = 0</span><br><span class="line">lseek(11, 0, SEEK_SET)                  = 0</span><br><span class="line">read(11, &quot;#\n# hosts         This file desc&quot;..., 4096) = 898</span><br><span class="line">read(11, &quot;&quot;, 4096)                      = 0</span><br><span class="line">close(11)                               = 0</span><br><span class="line">socket(PF_INET, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, IPPROTO_IP) = 11</span><br><span class="line">setsockopt(11, SOL_IP, IP_RECVERR, [1], 4) = 0</span><br><span class="line">connect(11, &#123;sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;10.xx.xx.1&quot;)&#125;, 16) = 0</span><br><span class="line">poll([&#123;fd=11, events=POLLOUT&#125;], 1, 0)   = 1 ([&#123;fd=11, revents=POLLOUT&#125;])</span><br><span class="line">sendto(11, &quot;e\366\1\0\0\1\0\0\0\0\0\0\7kubexxx\0\0\34\0\1&quot;, 25, MSG_NOSIGNAL, NULL, 0) = 25</span><br><span class="line">poll([&#123;fd=11, events=POLLIN&#125;], 1, 5000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>左边窗口执行，右边赶紧 strace，发现有输出后卡主，赶紧按回车分开，最后往上翻找空行附近就是卡住的信息。从上面看就是 glibc 的 DNS 解析行为：</p><ol><li>先看 <code>/etc/nsswitch.conf</code> 内的 <code>hosts</code> 行，看 hosts 和 dns 的优先级</li><li><code>connect(11, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;10.xx.xx.1&quot;)}, 16) = 0</code> 发起了 DNS 解析请求的连接信息</li><li><code>sendto(11, &quot;e\366\1\0\0\1\0\0\0\0\0\0\7kubexxx\0\0\34\0\1&quot;, 25, MSG_NOSIGNAL, NULL, 0) = 25</code> DNS 请求</li></ol><p>然后再执行下，另一个窗口看了下链接确实存在 DNS 解析行为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ss -anuop | grep :53</span></span><br><span class="line">ESTAB      0      0      10.xx.xx.215:36250              10.xx.xx.1:53                  users:((&quot;salt-run&quot;,pid=13752,fd=4))</span><br></pre></td></tr></table></figure><p>然后抓包看了下请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手机阅读的话，请往右侧翻</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -nn -i any port 53 -vvv</span></span><br><span class="line">tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br><span class="line">19:34:24.952563 IP (tos 0x0, ttl 64, id 50084, offset 0, flags [DF], proto UDP (17), length 53)</span><br><span class="line">    10.xx.xx.215.63760 &gt; 10.xx.xx.1.53: [bad udp cksum 0xc324 -&gt; 0xd5d2!] 64743+ AAAA? kubexxx. (25)</span><br><span class="line">19:34:26.613645 IP (tos 0x0, ttl 64, id 50437, offset 0, flags [DF], proto UDP (17), length 53)</span><br><span class="line">    10.xx.xx.215.35564 &gt; 10.xx.xx.1.53: [bad udp cksum 0xc324 -&gt; 0x3614!] 2763+ AAAA? kubexxx. (25)</span><br></pre></td></tr></table></figure><p>看上面的 <code>AAAA? kubexxx</code>，可以确认是请求 hostname kubexxx 的 IPv6 DNS 解析记录，然后加了下 hosts 就好了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;::1 <span class="variable">$HOSTNAME</span>&quot;</span> &gt;&gt; /etc/hosts</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">time</span> salt-run jobs.active</span></span><br><span class="line">[INFO    ] Runner completed: 20250912113512377461_16938</span><br><span class="line"></span><br><span class="line">real0m3.265s</span><br><span class="line">user0m2.714s</span><br><span class="line">sys0m0.254s</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>搜了下关键字 <code>salt-run dns ipv6</code> 看看有没有其他人遇到，结果找到类似问题：</p><ul><li><a href="https://github.com/saltstack/salt/issues/40912">https://github.com/saltstack/salt/issues/40912</a></li><li><a href="https://github.com/saltstack/salt/issues/32719#issuecomment-238114720">https://github.com/saltstack/salt/issues/32719#issuecomment-238114720</a></li></ul><p>但是回复都是老版本遇见多，我这边版本都很新了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">salt --versions-report</span></span><br><span class="line">Salt Version:</span><br><span class="line">          Salt: 3006.15</span><br><span class="line"> </span><br><span class="line">Python Version:</span><br><span class="line">        Python: 3.10.13 (main, Sep  8 2025, 06:32:11) [GCC 10.3.1]</span><br><span class="line"> </span><br><span class="line">Dependency Versions:</span><br><span class="line">          cffi: 1.14.5</span><br><span class="line">      cherrypy: Not Installed</span><br><span class="line">  cryptography: 44.0.1</span><br><span class="line">      dateutil: 2.8.2</span><br><span class="line">     docker-py: 6.1.3</span><br><span class="line">         gitdb: Not Installed</span><br><span class="line">     gitpython: Not Installed</span><br><span class="line">        Jinja2: 3.0.1</span><br><span class="line">       libgit2: Not Installed</span><br><span class="line">  looseversion: 1.3.0</span><br><span class="line">      M2Crypto: Not Installed</span><br><span class="line">          Mako: 1.2.2</span><br><span class="line">       msgpack: 1.0.5</span><br><span class="line">  msgpack-pure: Not Installed</span><br><span class="line">  mysql-python: Not Installed</span><br><span class="line">     packaging: 24.1</span><br><span class="line">     pycparser: 2.20</span><br><span class="line">      pycrypto: 3.19.1</span><br><span class="line">  pycryptodome: Not Installed</span><br><span class="line">        pygit2: Not Installed</span><br><span class="line">  python-gnupg: Not Installed</span><br><span class="line">        PyYAML: 6.0.1</span><br><span class="line">         PyZMQ: 27.0.2</span><br><span class="line">        relenv: Not Installed</span><br><span class="line">         smmap: Not Installed</span><br><span class="line">       timelib: Not Installed</span><br><span class="line">       Tornado: 4.5.3</span><br><span class="line">           ZMQ: 4.3.5</span><br><span class="line"> </span><br><span class="line">System Versions:</span><br><span class="line">          dist: openeuler 22.03 LTS-SP4</span><br><span class="line">        locale: utf-8</span><br><span class="line">       machine: x86_64</span><br><span class="line">       release: 4.12.14-120-default</span><br><span class="line">        system: Linux</span><br><span class="line">       version: openEuler 22.03 LTS-SP4</span><br></pre></td></tr></table></figure><p>这种是 glibc 的行为，salt 会解析 hostname，业务临近封库，改这个 docker 镜像内启动脚本也来不及了，就先在代码层面解决了，搜了下 python socket 库并没有那种纯看 hosts 条目的库，就手动写了如下逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fcntl</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ensure_hosts_entry</span>(<span class="params">ip_address, hostname</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/etc/hosts&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 加排他锁（阻塞模式，确保并发安全）</span></span><br><span class="line">            fcntl.flock(f, fcntl.LOCK_EX)</span><br><span class="line">            original_content = f.readlines()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> index, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(original_content):</span><br><span class="line">                line_part = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(line_part) &lt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> hostname <span class="keyword">in</span> line_part:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            original_content.append(<span class="string">f&quot;<span class="subst">&#123;ip_address&#125;</span> <span class="subst">&#123;hostname&#125;</span>\n&quot;</span>)</span><br><span class="line">            f.seek(<span class="number">0</span>)</span><br><span class="line">            f.truncate()</span><br><span class="line">            f.write(<span class="string">&#x27;&#x27;</span>.join(original_content))</span><br><span class="line">            f.flush()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            fcntl.flock(f, fcntl.LOCK_UN)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ensure_hosts_entry(<span class="string">&quot;::1&quot;</span>, socket.gethostname())</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一次 salt-run 很久才返回的排查&lt;/p&gt;</summary>
    
    
    
    
    <category term="salt" scheme="http://zhangguanzhang.github.io/tags/salt/"/>
    
    <category term="salt-run" scheme="http://zhangguanzhang.github.io/tags/salt-run/"/>
    
    <category term="ipv6" scheme="http://zhangguanzhang.github.io/tags/ipv6/"/>
    
  </entry>
  
  <entry>
    <title>麒麟内核4.19.90-52.49导致的flannel vxlan跨节点不通</title>
    <link href="http://zhangguanzhang.github.io/2025/09/10/kylin-4.19.90-52.49-udp-drop/"/>
    <id>http://zhangguanzhang.github.io/2025/09/10/kylin-4.19.90-52.49-udp-drop/</id>
    <published>2025-09-10T18:10:30.000Z</published>
    <updated>2025-09-10T18:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>一次麒麟内核导致 flannel 跨节点不通的排查</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>客户有一套 K8S 环境 A 要扩容，给了两台机器加进后，同事发现新节点 flannel 跨节点不通。抓包排查发现新节点的 <code>ip -s a s flannel.1</code> 显示的 Rx 收包为0。<br>客户认为是 k8s 问题，我们认为是客户网络环境没放行 UDP。然后双方达成共识搞一套干净环境 B 部署 K8S 看看，然后发现依旧跨节点不通。</p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/os-release</span></span><br><span class="line">NAME=&quot;Kylin Linux Advanced Server&quot;</span><br><span class="line">VERSION=&quot;V10 (Lance)&quot;</span><br><span class="line">ID=&quot;kylin&quot;</span><br><span class="line">VERSION_ID=&quot;V10&quot;</span><br><span class="line">PRETTY_NAME=&quot;Kylin Linux Advanced Server V10 (Lance)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lscpu</span></span><br><span class="line">Architecture:                    x86_64</span><br><span class="line">CPU op-mode(s):                  32-bit, 64-bit</span><br><span class="line">Byte Order:                      Little Endian</span><br><span class="line">Address sizes:                   48 bits physical, 48 bits virtual</span><br><span class="line">CPU(s):                          14</span><br><span class="line">On-line CPU(s) list:             0-13</span><br><span class="line">Thread(s) per core:              1</span><br><span class="line">Core(s) per socket:              2</span><br><span class="line">Socket(s):                       7</span><br><span class="line">NUMA node(s):                    1</span><br><span class="line">Vendor ID:                       AuthenticAMD</span><br><span class="line">CPU family:                      15</span><br><span class="line">Model:                           6</span><br><span class="line">Model name:                      Hygon C86-3G 7390 32-core Processor</span><br><span class="line">Stepping:                        3</span><br><span class="line">CPU MHz:                         2699.998</span><br><span class="line">BogoMIPS:                        5399.99</span><br><span class="line">Hypervisor vendor:               KVM</span><br><span class="line">Virtualization type:             full</span><br><span class="line">L1d cache:                       896 KiB</span><br><span class="line">L1i cache:                       896 KiB</span><br><span class="line">L2 cache:                        7 MiB</span><br><span class="line">L3 cache:                        112 MiB</span><br><span class="line">NUMA node0 CPU(s):               0-13</span><br><span class="line">Vulnerability Itlb multihit:     Not affected</span><br><span class="line">Vulnerability Spec store bypass: Not affected</span><br><span class="line">Vulnerability Spectre v1:        Mitigation; usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Vulnerability Spectre v2:        Mitigation; Retpolines, STIBP disabled, RSB filling, PBRSB-eIBRS Not affected</span><br><span class="line">Vulnerability Srbds:             Not affected</span><br><span class="line">Vulnerability Tsx async abort:   Not affected</span><br><span class="line">Flags:                           fpu de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm rep_good </span><br><span class="line">                                 nopl cpuid extd_apicid tsc_known_freq pni cx16 x2apic aes hypervisor cmp_legacy 3dnowprefetch vmmcall</span><br></pre></td></tr></table></figure><h3 id="接手缘由"><a href="#接手缘由" class="headerlink" title="接手缘由"></a>接手缘由</h3><p>现场的同事卸载了 K8S 后测试UDP 还是一样，然后认为 udp 存在限制，客户用 nmap 扫描认为 UDP 没限制，我们用 nc 起 server 用 client 测不通，客户认为我们这种测试方式不准，我就写了个测试脚本给同事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.version_info[<span class="number">0</span>] == <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">input</span> = raw_input</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">usage</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Usage:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  Server: python udp-test.py &lt;local-port&gt;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  Client: python udp-test.py &lt;host:port&gt;&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_addr</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;:&quot;</span> <span class="keyword">in</span> s:</span><br><span class="line">        host, port = s.rsplit(<span class="string">&quot;:&quot;</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> host, <span class="built_in">int</span>(port)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="built_in">int</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server</span>(<span class="params">port</span>):</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    sock.bind((<span class="string">&quot;0.0.0.0&quot;</span>, port))</span><br><span class="line">    logging.info(<span class="string">&quot;Server listening on UDP *:%d&quot;</span>, port)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data, addr = sock.recvfrom(<span class="number">4096</span>)</span><br><span class="line">        msg = data.decode(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">        logging.info(<span class="string">&quot;Received from %s: %r&quot;</span>, addr, msg)</span><br><span class="line">        sock.sendto(data, addr)          <span class="comment"># 回显</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client</span>(<span class="params">host, port</span>):</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    target = (host, port)</span><br><span class="line">    logging.info(<span class="string">&quot;Client target UDP %s:%d (type message and press Enter)&quot;</span>, host, port)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = <span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> (EOFError, KeyboardInterrupt):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\nBye&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        sock.sendto(text.encode(<span class="string">&#x27;utf-8&#x27;</span>), target)</span><br><span class="line">        sock.settimeout(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data, _ = sock.recvfrom(<span class="number">4096</span>)</span><br><span class="line">            logging.info(<span class="string">&quot;Server echoed: %r&quot;</span>, data.decode(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>))</span><br><span class="line">        <span class="keyword">except</span> socket.timeout:</span><br><span class="line">            logging.debug(<span class="string">&quot;No echo within 2s&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        usage()</span><br><span class="line">    addr_str = sys.argv[<span class="number">1</span>]</span><br><span class="line">    host, port = parse_addr(addr_str)</span><br><span class="line"></span><br><span class="line">    LOG_FMT = <span class="string">&quot;%(asctime)s [%(levelname)s] %(message)s&quot;</span></span><br><span class="line">    logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=LOG_FMT)</span><br><span class="line">    <span class="keyword">if</span> host <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 纯数字端口 -&gt; 服务端</span></span><br><span class="line">        server(port)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># host:port -&gt; 客户端</span></span><br><span class="line">        client(host, port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>脚本就是连上后发消息回车，server 把收到的消息发回客户端，客户端也打印收到的消息，同事客户环境上测了下发现不正常，然后客户用 tcpdump 抓包说接收到了。看了下客户抓包方式确实没问题：</p><ul><li>机器B 上先开抓包 <code>tcpdump -nn -i eth0 port 8472 -w xxx.pcap</code></li><li>机器A 上 <code>echo &quot;123&quot; | nc -u &lt;机器B_ip&gt; 8472</code></li></ul><p>之前以为是客户在发送机器上抓的，理清楚客户思路是正确后，就远程上去看了。</p><h3 id="抓包重现"><a href="#抓包重现" class="headerlink" title="抓包重现"></a>抓包重现</h3><p>确实目标机器能抓到报文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump  -nn -i any port 8472 -vvv</span></span><br><span class="line">dropped privs to tcpdump</span><br><span class="line">tcpdump: listening on any, link-type LINUX_SLL (Linux cooked v1), capture size 262144 bytes</span><br><span class="line">14:43:39.267522 IP (tos 0x0, ttl 64, id 56033, offset 0, flags [DF], proto UDP (17), length 35)</span><br><span class="line">    10.xx.50.166.50492 &gt; 10.xx.50.169.8472: [udp sum ok] OTV,  [|OTV]</span><br><span class="line">^C</span><br><span class="line">1 packet captured</span><br><span class="line">3 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>上面是抓包后用 nc 发 UDP 抓的，然后下面是脚本形式发的抓的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -nn -i any port 8472 -vvv</span></span><br><span class="line">dropped privs to tcpdump</span><br><span class="line">tcpdump: listening on any, link-type LINUX_SLL (Linux cooked v1), capture size 262144 bytes</span><br><span class="line">14:48:58.540224 IP (tos 0x0, ttl 64, id 48511, offset 0, flags [DF], proto UDP (17), length 31)</span><br><span class="line">    10.xx.50.166.46543 &gt; 10.xx.50.169.8472: [bad udp cksum 0x7a0d -&gt; 0x4acd!] OTV,  [|OTV]</span><br><span class="line">^C</span><br><span class="line">1 packet captured</span><br><span class="line">2 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>上面抓包对比里有 <code>bad udp cksum</code>，尝试取消网卡计算 checksum 试试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ethtool --show-offload eth0 | grep checksum</span></span><br><span class="line">rx-checksumming: on [fixed]</span><br><span class="line">tx-checksummtng: on</span><br><span class="line">tx-checksum-ipv4:off[fixed]</span><br><span class="line">tx-checksum-ip-generic: on</span><br><span class="line">tx-checksum-ipv6: off [fixed]</span><br><span class="line">tx-checksum-fcoe-crc: off [ftxed]</span><br><span class="line">tx-checksum-sctp: off [fixed]</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ethtool --offload eth0 tx-checksum-ip-generic off</span></span><br><span class="line">Actual changes:</span><br><span class="line">tx-checksumming: off</span><br><span class="line">tx-checksum-ip-generic: off</span><br><span class="line">tcp-segmentatton-offLoad: off</span><br><span class="line">tx-tcp-segmentation; off [requested on]</span><br><span class="line">tx-tcp-ecn-segmentation: off [requested on]</span><br><span class="line">tx-tcp6-segmentation: off [requested on]</span><br></pre></td></tr></table></figure><p>测了下发下还不行，然后几个都设置了还是不行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool --offload eth0 tx off rx off</span><br></pre></td></tr></table></figure><p>对比了环境 A 的 offload 都一样，并且查看驱动也一致：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">readlink</span> -f /sys/class/net/eth0/device/driver/module</span></span><br><span class="line">/sys/module/virtio_net</span><br></pre></td></tr></table></figure><p>iptables 啥规则都没有，还有不一样的就只有内核版本了：</p><ul><li>正常环境：<code>Linux 4.19.90-52.22.v2207.ky10.x86_64 #1 SMP Tue Mar 14 12:19:10 CST 2023 x86_64 x86_64 x86_64 GNU/Linux</code></li><li>异常环境：<code>Linux 4.19.90-52.49.v2207.ky10.x86_64 #3 SMP Thu Jul 24 02:43:35 CST 2025 x86_64 x86_64 x86_64 GNU/Linux</code></li></ul><p>询问客户能不能这套环境 B 机器换成和正常环境一样内核的虚机，客户答复说是平台自动化开的机器，无法保持内核一致。没办法，然后看这套环境是不是升级过内核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep kernel /var/log/dnf*</span></span><br><span class="line">...</span><br><span class="line">/var/log/dnf.rpm.log:2025-08-07T01:34:25Z SUBDEBUG InstaLLed:kernel-4.19.90-52.49.v2207.ky10.x86_64</span><br><span class="line">/var/log/dnf.rpm.log:2025-08-67T01:34:26Z SUBDEBUG Upgrade:kernel-tools-4.19.90-52.49.v2207.ky10.x86_64</span><br><span class="line">/var/log/dnf.rpm.log:2025-08-07T01:34:29Z SUBDEBUG Upgraded:kernel-tools-4.19.90-52.45.v2207.ky10.x86_64</span><br><span class="line">/var/log/dnf.rpm.log:2025-08-67T01:34:30Z SUBDEBUG Upgraded:kernel-headers-4.19.90-52.45.v2207.ky10.x86_64</span><br><span class="line">/var/log/dnf.rpm.log:2025-08-07T01:34:34Z SUBDEBUG Upgraded:kernel-tools-libs-4.19.90-52.45.v2207.ky10.x86_64</span><br></pre></td></tr></table></figure><p>果然升级了，看下老版本在不在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep kernel</span></span><br><span class="line">kernel-modules-extra-4.19.90-52.45.v2207.ky10.x86_64</span><br><span class="line">kernel-moduLes-extra-4.19.90-52.22.v2207.ky10.x86_64</span><br><span class="line">kernel-modules-4.19.90-52.49.v2207.ky10.x86_64</span><br><span class="line">kernel-core-4.19.90-52.22.v2207.ky10.x86_64</span><br><span class="line">kerne1-t001s-11bs-4.19.90-52.49.V2207.ky10.x86_64</span><br><span class="line">kernel-modules-extra-4.19.96-52.49.v2207.ky10.x86_64</span><br><span class="line">kernel-4.19.90-52.22.v2207.ky10.x86_64</span><br><span class="line">kernel-t00L5-4.19.90-52.49.v2207.ky10.x86_64</span><br><span class="line">kernel-core-4.19.90-52.45.v2207.ky10.x86_64</span><br><span class="line">kernel-modules-4.19.90-52.45.v2207.ky10.x86_64</span><br><span class="line">kernel-4.19.90-52.45.v2207.ky10.x86_64</span><br><span class="line">kernel-modules-4.19.90-52.22.v2207.ky10.x86_64</span><br><span class="line">kernel-headers-4.19.96-52.49.v2207.ky10.x86_64</span><br><span class="line">kernel-4.19.90-52.49.v2207.ky10.x86_64</span><br><span class="line">kernel-4.19.90-52.49.v2207.ky10.x86_64</span><br></pre></td></tr></table></figure><p>查看下 grub 里顺序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk -F\&#x27; <span class="string">&#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27;</span> /etc/grub2.cfg</span></span><br><span class="line">0 : Kylin Linux Advanced Server (4.19.90-52.49.v2207.ky10.x86_64) V10 (Lance)</span><br><span class="line">1 : Kylin Linux Advanced Server (4.19.90-52.45.v2207.ky10.x86_64) V10 (Lance)</span><br><span class="line">2 : Kylin Linux Advanced Server (4.19.90-52.22.v2207.ky10.x86_64) V10 (Lance)</span><br><span class="line">3 : Kylin Linux Advanced Server (0-rescue-de06076a688a45bf9d1acd0bf45bb93e) V10 (Lance)</span><br></pre></td></tr></table></figure><p>切换到 52.22:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grub2-set-default 2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grub2-mkconfig -o /etc/grub2.cfg</span></span><br></pre></td></tr></table></figure><p>询问客户能否重启，可以重启，重启后测试就正常了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a</span><br><span class="line">Linux TKVMJT0240 4.19.90-52.22.v2207.ky10.x86_64 #1 SMP Tue Mar 14 12:19:10 CST </span><br><span class="line"></span><br><span class="line"># 任意机器1</span><br><span class="line">$ python udp-test.py 8472</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 机器2</span><br><span class="line">$ python udp-test.py 机器1的ip:8472</span><br><span class="line">25-09-10 17:29:59,623 [INFO] Client raget UDP xxx:8472( type message and press Enter)</span><br><span class="line">&gt;&gt;&gt; 123</span><br><span class="line">25-09-10 17:30:00,753 [INFO] Server echoed: &#x27;123&#x27;</span><br><span class="line">&gt;&gt;&gt; ^C</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure><p>其他几个机器一样处理后都正常。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一次麒麟内核导致 flannel 跨节点不通的排查&lt;/p&gt;</summary>
    
    
    
    
    <category term="kubernetes" scheme="http://zhangguanzhang.github.io/tags/kubernetes/"/>
    
    <category term="flannel" scheme="http://zhangguanzhang.github.io/tags/flannel/"/>
    
    <category term="vxlan" scheme="http://zhangguanzhang.github.io/tags/vxlan/"/>
    
    <category term="kylin" scheme="http://zhangguanzhang.github.io/tags/kylin/"/>
    
  </entry>
  
  <entry>
    <title>flannel 路由错乱</title>
    <link href="http://zhangguanzhang.github.io/2025/09/03/flannel-mode-chaos/"/>
    <id>http://zhangguanzhang.github.io/2025/09/03/flannel-mode-chaos/</id>
    <published>2025-09-03T10:10:30.000Z</published>
    <updated>2025-09-03T10:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>一次 flannel 路由错乱导致的跨节点不通</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>有一套客户测试环境，实施部署业务后发现有问题，看了下业务日志无法解析域名。因为 host-gw 需要二层，而且有些虚拟化有 IP&#x2F;MAC 绑定，所以默认用 vxlan 模式。</p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><h3 id="路由不对"><a href="#路由不对" class="headerlink" title="路由不对"></a>路由不对</h3><p>上去查了下发现 Pod 网段路由不对：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> ip r s</span> </span><br><span class="line">default via 172.16.0.1 dev eth0 proto dhcp metric 100 </span><br><span class="line">10.185.0.0/16 dev docker0 proto kernel scope link src 10.185.0.1 linkdown </span><br><span class="line">10.187.0.0/24 via 172.16.0.250 dev eth0</span><br><span class="line">10.187.1.0/24 via 172.16.0.202 dev eth0 </span><br><span class="line">10.187.2.0/24 via 172.16.0.104 dev eth0 #&lt;--- 这几个</span><br><span class="line">10.187.3.0/24 via 172.16.0.104 dev eth0 #&lt;--- 这几个</span><br><span class="line">10.187.3.0/24 dev cni0 proto kernel scope link src 10.187.3.1 #&lt;--- 这几个</span><br><span class="line">172.16.0.0/24 dev eth0 proto kernel scope link src 172.16.0.231 metric 100 </span><br></pre></td></tr></table></figure><p>是 vxlan 模式，但是 2.0、3.0 下一跳都是 172.16.0.104，而且本机是 <code>10.187.3.0/24</code> 网段，cni0 的路由无法匹配到。怀疑是客户添加的路由，让和客户沟通后换个和客户内网不重合的 Pod CIDR。然后实施重装后还是这样，上去看了下日志：</p><h3 id="模式错乱"><a href="#模式错乱" class="headerlink" title="模式错乱"></a>模式错乱</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a | grep flanneld</span><br><span class="line">$ docker logs xxxx # flannel容器ID</span><br><span class="line">W0903 01:37:31.229597       1 main.go:540] no subnet found for key: FLANNEL_IPV6_NETWORK in file: /run/flannel/subnet.env</span><br><span class="line">W0903 01:37:31.229636       1 main.go:540] no subnet found for key: FLANNEL_IPV6_SUBNET in file: /run/flannel/subnet.env</span><br><span class="line">I0903 01:37:31.229643       1 iptables.go:125] Setting up masking rules</span><br><span class="line">I0903 01:37:31.422425       1 iptables.go:226] Changing default FORWARD chain policy to ACCEPT</span><br><span class="line">I0903 01:37:31.523863       1 main.go:396] Wrote subnet file to /run/flannel/subnet.env</span><br><span class="line">I0903 01:37:31.523889       1 main.go:400] Running backend.</span><br><span class="line">I0903 01:37:31.524023       1 route_network.go:56] Watching for new subnet leases</span><br><span class="line">I0903 01:37:31.524247       1 subnet.go:152] Batch elem [0] is &#123; lease.Event&#123;Type:0, Lease:lease.Lease&#123;EnableIPv4:true, EnableIPv6:false, Subnet:ip.IP4Net&#123;IP:0xa610100, PrefixLen:0x18&#125;, IPv6Subnet:ip.IP6Net&#123;IP:(*ip.IP6)(nil), PrefixLen:0x0&#125;, Attrs:lease.LeaseAttrs&#123;PublicIP:0xac100068, PublicIPv6:(*ip.IP6)(nil), BackendType:&quot;host-gw&quot;, BackendData:json.RawMessage&#123;0x6e, 0x75, 0x6c, 0x6c&#125;, BackendV6Data:json.RawMessage(nil)&#125;, Expiration:time.Date(1, time.January, 1, 0, 0, 0, 0, time.UTC), Asof:0&#125;&#125; &#125;</span><br><span class="line">I0903 01:37:31.524425       1 subnet.go:152] Batch elem [0] is &#123; lease.Event&#123;Type:0, Lease:lease.Lease&#123;EnableIPv4:true, EnableIPv6:false, Subnet:ip.IP4Net&#123;IP:0xa610300, PrefixLen:0x18&#125;, IPv6Subnet:ip.IP6Net&#123;IP:(*ip.IP6)(nil), PrefixLen:0x0&#125;, Attrs:lease.LeaseAttrs&#123;PublicIP:0xac1000e7, PublicIPv6:(*ip.IP6)(nil), BackendType:&quot;host-gw&quot;, BackendData:json.RawMessage&#123;0x6e, 0x75, 0x6c, 0x6c&#125;, BackendV6Data:json.RawMessage(nil)&#125;, Expiration:time.Date(1, time.January, 1, 0, 0, 0, 0, time.UTC), Asof:0&#125;&#125; &#125;</span><br><span class="line">I0903 01:37:31.524449       1 route_network.go:93] Subnet added: 10.97.1.0/24 via 172.16.0.104</span><br><span class="line">I0903 01:37:31.524705       1 route_network.go:166] Route to &#123;Ifindex: 2 Dst: 10.97.1.0/24 Src: &lt;nil&gt; Gw: 172.16.0.104 Flags: [] Table: 0 Realm: 0&#125; already exists, skipping.</span><br><span class="line">I0903 01:37:31.524797       1 route_network.go:93] Subnet added: 10.97.3.0/24 via 172.16.0.231</span><br><span class="line">I0903 01:37:31.524876       1 route_network.go:166] Route to &#123;Ifindex: 2 Dst: 10.97.3.0/24 Src: &lt;nil&gt; Gw: 172.16.0.231 Flags: [] Table: 0 Realm: 0&#125; already exists, skipping.</span><br><span class="line">I0903 01:37:31.524903       1 subnet.go:152] Batch elem [0] is &#123; lease.Event&#123;Type:0, Lease:lease.Lease&#123;EnableIPv4:true, EnableIPv6:false, Subnet:ip.IP4Net&#123;IP:0xa610000, PrefixLen:0x18&#125;, IPv6Subnet:ip.IP6Net&#123;IP:(*ip.IP6)(nil), PrefixLen:0x0&#125;, Attrs:lease.LeaseAttrs&#123;PublicIP:0xac1000fa, PublicIPv6:(*ip.IP6)(nil), BackendType:&quot;host-gw&quot;, BackendData:json.RawMessage&#123;0x6e, 0x75, 0x6c, 0x6c&#125;, BackendV6Data:json.RawMessage(nil)&#125;, Expiration:time.Date(1, time.January, 1, 0, 0, 0, 0, time.UTC), Asof:0&#125;&#125; &#125;</span><br><span class="line">I0903 01:37:31.524939       1 route_network.go:93] Subnet added: 10.97.0.0/24 via 172.16.0.250</span><br><span class="line">I0903 01:37:31.525190       1 route_network.go:166] Route to &#123;Ifindex: 2 Dst: 10.97.0.0/24 Src: &lt;nil&gt; Gw: 172.16.0.250 Flags: [] Table: 0 Realm: 0&#125; already exists, skipping.</span><br><span class="line">I0903 01:37:31.621427       1 main.go:421] Waiting for all goroutines to exit</span><br><span class="line">I0903 01:37:31.922267       1 iptables.go:372] bootstrap done</span><br><span class="line">I0903 01:37:32.129063       1 iptables.go:372] bootstrap done</span><br></pre></td></tr></table></figure><p>上面日志很奇怪，注意几个关键地方：</p><ul><li><code>BackendType:&quot;host-gw&quot;</code></li><li><code>Subnet added: 10.97.0.0/24 via 172.16.0.250</code></li></ul><p>怎么会是 <code>host-gw</code> 模式，查看下路由：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@vm172-16-0-202 ~]# ip r s </span><br><span class="line">default via 172.16.0.1 dev eth0 proto dhcp metric 100 </span><br><span class="line">10.97.0.0/24 via 172.16.0.250 dev eth0 </span><br><span class="line">10.97.1.0/24 via 172.16.0.104 dev eth0 </span><br><span class="line">10.97.2.0/24 via 172.16.0.250 dev eth0 </span><br><span class="line">10.97.2.0/24 dev cni0 proto kernel scope link src 10.97.2.1 </span><br><span class="line">10.97.3.0/24 via 172.16.0.231 dev eth0 </span><br><span class="line">10.185.0.0/16 dev docker0 proto kernel scope link src 10.185.0.1 linkdown </span><br><span class="line">10.187.0.0/24 via 172.16.0.250 dev eth0 </span><br><span class="line">10.187.2.0/24 via 172.16.0.104 dev eth0 </span><br><span class="line">10.187.3.0/24 via 172.16.0.231 dev eth0 </span><br><span class="line">172.16.0.0/24 dev eth0 proto kernel scope link src 172.16.0.202 metric 100</span><br></pre></td></tr></table></figure><p>老路由忽略，新路由看确实是 host-gw 模式的路由，看下 configmap 配置模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@vm172-16-0-202 ~]# kubectl -n kube-system get cm kube-flannel-cfg -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  cni-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;cbr0&quot;</span>,</span><br><span class="line">      <span class="string">&quot;cniVersion&quot;</span>: <span class="string">&quot;0.3.1&quot;</span>,</span><br><span class="line">      <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;flannel&quot;</span>,</span><br><span class="line">          <span class="string">&quot;delegate&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hairpinMode&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;isDefaultGateway&quot;</span>: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;portmap&quot;</span>,</span><br><span class="line">          <span class="string">&quot;capabilities&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;portMappings&quot;</span>: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;10.97.0.0/16&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Backend&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;vxlan&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Port&quot;</span>: 8475</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">kind: ConfigMap</span><br></pre></td></tr></table></figure><p>configmap 是 vxlan 没问题，看下文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vm172-16-0-202 ~]# cat /run/flannel/subnet.env </span><br><span class="line">FLANNEL_NETWORK=10.97.0.0/16</span><br><span class="line">FLANNEL_SUBNET=10.97.2.1/24</span><br><span class="line">FLANNEL_MTU=1500</span><br><span class="line">FLANNEL_IPMASQ=true</span><br></pre></td></tr></table></figure><p>奇怪了，怎么是 host-gw 的 1500 MTU，删除下 flannel 容器后再看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@vm172-16-0-202 ~]# docker rm -f xxx # flanneld 容器id</span><br><span class="line">[root@vm172-16-0-202 ~]# cat /run/flannel/subnet.env </span><br><span class="line">FLANNEL_NETWORK=10.97.0.0/16</span><br><span class="line">FLANNEL_SUBNET=10.97.2.1/24</span><br><span class="line">FLANNEL_MTU=1450</span><br><span class="line">FLANNEL_IPMASQ=true</span><br><span class="line">[root@vm172-16-0-202 ~]# docker ps -a | grep flanneld</span><br><span class="line">e288c4442ee2   reg.xxx.lan:5000/xxx/flannel                   &quot;/opt/bin/flanneld -…&quot;   41 seconds ago   Up 40 seconds                         k8s_kube-flannel_kube-flannel-ds-w7rk2_kube-system_581101b1-cfa5-4ccc-80be-e78a9c248b96_1</span><br><span class="line">[root@vm172-16-0-202 ~]# docker logs e288</span><br><span class="line">I0903 01:47:13.123249       1 main.go:211] CLI flags config: &#123;etcdEndpoints:http://127.0.0.1:4001,http://127.0.0.1:2379 etcdPrefix:/coreos.com/network etcdKeyfile: etcdCertfile: etcdCAFile: etcdUsername: etcdPassword: version:false kubeSubnetMgr:true kubeApiUrl: kubeAnnotationPrefix:flannel.alpha.coreos.com kubeConfigFile: iface:[] ifaceRegex:[] ipMasq:true ifaceCanReach: subnetFile:/run/flannel/subnet.env publicIP: publicIPv6: subnetLeaseRenewMargin:60 healthzIP:0.0.0.0 healthzPort:0 iptablesResyncSeconds:5 iptablesForwardRules:true netConfPath:/etc/kube-flannel/net-conf.json setNodeNetworkUnavailable:true&#125;</span><br><span class="line">W0903 01:47:13.123387       1 client_config.go:618] Neither --kubeconfig nor --master was specified.  Using the inClusterConfig.  This might not work.</span><br><span class="line">I0903 01:47:13.223377       1 kube.go:139] Waiting 10m0s for node controller to sync</span><br><span class="line">I0903 01:47:13.223476       1 kube.go:469] Starting kube subnet manager</span><br><span class="line">I0903 01:47:13.230593       1 kube.go:490] Creating the node lease for IPv4. This is the n.Spec.PodCIDRs: [10.97.1.0/24]</span><br><span class="line">I0903 01:47:13.230628       1 kube.go:490] Creating the node lease for IPv4. This is the n.Spec.PodCIDRs: [10.97.2.0/24]</span><br><span class="line">I0903 01:47:13.230637       1 kube.go:490] Creating the node lease for IPv4. This is the n.Spec.PodCIDRs: [10.97.3.0/24]</span><br><span class="line">I0903 01:47:13.230644       1 kube.go:490] Creating the node lease for IPv4. This is the n.Spec.PodCIDRs: [10.97.0.0/24]</span><br><span class="line">I0903 01:47:14.223684       1 kube.go:146] Node controller sync successful</span><br><span class="line">I0903 01:47:14.223761       1 main.go:231] Created subnet manager: Kubernetes Subnet Manager - 172.16.0.202</span><br><span class="line">I0903 01:47:14.223767       1 main.go:234] Installing signal handlers</span><br><span class="line">I0903 01:47:14.224176       1 main.go:452] Found network config - Backend type: vxlan</span><br><span class="line">I0903 01:47:14.229346       1 kube.go:669] List of node(172.16.0.202) annotations: map[string]string&#123;&quot;flannel.alpha.coreos.com/backend-data&quot;:&quot;null&quot;, &quot;flannel.alpha.coreos.com/backend-type&quot;:&quot;host-gw&quot;, &quot;flannel.alpha.coreos.com/kube-subnet-manager&quot;:&quot;true&quot;, &quot;flannel.alpha.coreos.com/public-ip&quot;:&quot;172.16.0.202&quot;, &quot;node.alpha.kubernetes.io/ttl&quot;:&quot;0&quot;, &quot;volumes.kubernetes.io/controller-managed-attach-detach&quot;:&quot;true&quot;&#125;</span><br><span class="line">I0903 01:47:14.229398       1 match.go:210] Determining IP address of default interface</span><br><span class="line">I0903 01:47:14.229758       1 match.go:263] Using interface with name eth0 and address 172.16.0.202</span><br><span class="line">I0903 01:47:14.229788       1 match.go:285] Defaulting external address to interface address (172.16.0.202)</span><br><span class="line">I0903 01:47:14.229841       1 vxlan.go:141] VXLAN config: VNI=1 Port=8475 GBP=false Learning=false DirectRouting=false</span><br><span class="line">I0903 01:47:14.233427       1 kube.go:636] List of node(172.16.0.202) annotations: map[string]string&#123;&quot;flannel.alpha.coreos.com/backend-data&quot;:&quot;null&quot;, &quot;flannel.alpha.coreos.com/backend-type&quot;:&quot;host-gw&quot;, &quot;flannel.alpha.coreos.com/kube-subnet-manager&quot;:&quot;true&quot;, &quot;flannel.alpha.coreos.com/public-ip&quot;:&quot;172.16.0.202&quot;, &quot;node.alpha.kubernetes.io/ttl&quot;:&quot;0&quot;, &quot;volumes.kubernetes.io/controller-managed-attach-detach&quot;:&quot;true&quot;&#125;</span><br><span class="line">I0903 01:47:14.249292       1 iptables.go:51] Starting flannel in iptables mode...</span><br><span class="line">W0903 01:47:14.249452       1 main.go:540] no subnet found for key: FLANNEL_IPV6_NETWORK in file: /run/flannel/subnet.env</span><br><span class="line">W0903 01:47:14.249491       1 main.go:540] no subnet found for key: FLANNEL_IPV6_SUBNET in file: /run/flannel/subnet.env</span><br><span class="line">I0903 01:47:14.249498       1 iptables.go:125] Setting up masking rules</span><br><span class="line">I0903 01:47:14.250112       1 kube.go:490] Creating the node lease for IPv4. This is the n.Spec.PodCIDRs: [10.97.2.0/24]</span><br><span class="line">I0903 01:47:14.529553       1 iptables.go:226] Changing default FORWARD chain policy to ACCEPT</span><br><span class="line">I0903 01:47:14.622211       1 main.go:396] Wrote subnet file to /run/flannel/subnet.env</span><br><span class="line">I0903 01:47:14.622240       1 main.go:400] Running backend.</span><br><span class="line">I0903 01:47:14.622545       1 vxlan_network.go:65] watching for new subnet leases</span><br><span class="line">I0903 01:47:14.622590       1 subnet.go:152] Batch elem [0] is &#123; lease.Event&#123;Type:0, Lease:lease.Lease&#123;EnableIPv4:true, EnableIPv6:false, Subnet:ip.IP4Net&#123;IP:0xa610100, PrefixLen:0x18&#125;, IPv6Subnet:ip.IP6Net&#123;IP:(*ip.IP6)(nil), PrefixLen:0x0&#125;, Attrs:lease.LeaseAttrs&#123;PublicIP:0xac100068, PublicIPv6:(*ip.IP6)(nil), BackendType:&quot;host-gw&quot;, BackendData:json.RawMessage&#123;0x6e, 0x75, 0x6c, 0x6c&#125;, BackendV6Data:json.RawMessage(nil)&#125;, Expiration:time.Date(1, time.January, 1, 0, 0, 0, 0, time.UTC), Asof:0&#125;&#125; &#125;</span><br><span class="line">I0903 01:47:14.622651       1 subnet.go:152] Batch elem [0] is &#123; lease.Event&#123;Type:0, Lease:lease.Lease&#123;EnableIPv4:true, EnableIPv6:false, Subnet:ip.IP4Net&#123;IP:0xa610300, PrefixLen:0x18&#125;, IPv6Subnet:ip.IP6Net&#123;IP:(*ip.IP6)(nil), PrefixLen:0x0&#125;, Attrs:lease.LeaseAttrs&#123;PublicIP:0xac1000e7, PublicIPv6:(*ip.IP6)(nil), BackendType:&quot;host-gw&quot;, BackendData:json.RawMessage&#123;0x6e, 0x75, 0x6c, 0x6c&#125;, BackendV6Data:json.RawMessage(nil)&#125;, Expiration:time.Date(1, time.January, 1, 0, 0, 0, 0, time.UTC), Asof:0&#125;&#125; &#125;</span><br><span class="line">I0903 01:47:14.622694       1 vxlan_network.go:100] Received Subnet Event with VxLan: BackendType: host-gw, PublicIP: 172.16.0.104, PublicIPv6: (nil), BackendData: null, BackendV6Data: (nil)</span><br><span class="line">W0903 01:47:14.622710       1 vxlan_network.go:102] ignoring non-vxlan v4Subnet(10.97.1.0/24) v6Subnet(::/0): type=host-gw</span><br><span class="line">I0903 01:47:14.622724       1 vxlan_network.go:100] Received Subnet Event with VxLan: BackendType: host-gw, PublicIP: 172.16.0.231, PublicIPv6: (nil), BackendData: null, BackendV6Data: (nil)</span><br><span class="line">W0903 01:47:14.622727       1 vxlan_network.go:102] ignoring non-vxlan v4Subnet(10.97.3.0/24) v6Subnet(::/0): type=host-gw</span><br><span class="line">I0903 01:47:14.622737       1 subnet.go:152] Batch elem [0] is &#123; lease.Event&#123;Type:0, Lease:lease.Lease&#123;EnableIPv4:true, EnableIPv6:false, Subnet:ip.IP4Net&#123;IP:0xa610000, PrefixLen:0x18&#125;, IPv6Subnet:ip.IP6Net&#123;IP:(*ip.IP6)(nil), PrefixLen:0x0&#125;, Attrs:lease.LeaseAttrs&#123;PublicIP:0xac1000fa, PublicIPv6:(*ip.IP6)(nil), BackendType:&quot;host-gw&quot;, BackendData:json.RawMessage&#123;0x6e, 0x75, 0x6c, 0x6c&#125;, BackendV6Data:json.RawMessage(nil)&#125;, Expiration:time.Date(1, time.January, 1, 0, 0, 0, 0, time.UTC), Asof:0&#125;&#125; &#125;</span><br><span class="line">I0903 01:47:14.622759       1 vxlan_network.go:100] Received Subnet Event with VxLan: BackendType: host-gw, PublicIP: 172.16.0.250, PublicIPv6: (nil), BackendData: null, BackendV6Data: (nil)</span><br><span class="line">W0903 01:47:14.622764       1 vxlan_network.go:102] ignoring non-vxlan v4Subnet(10.97.0.0/24) v6Subnet(::/0): type=host-gw</span><br><span class="line">I0903 01:47:14.722083       1 main.go:421] Waiting for all goroutines to exit</span><br><span class="line">I0903 01:47:15.123247       1 iptables.go:372] bootstrap done</span><br><span class="line">I0903 01:47:15.525861       1 iptables.go:372] bootstrap done</span><br></pre></td></tr></table></figure><p>文件内容是对了，但是看日志内部显示节点 annotation 注解不对劲：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kube.go:636] List of node(172.16.0.202) annotations: \</span><br><span class="line">  map[string]string&#123;&quot;flannel.alpha.coreos.com/backend-data&quot;:&quot;null&quot;, \</span><br><span class="line">  &quot;flannel.alpha.coreos.com/backend-type&quot;:&quot;host-gw&quot;, \</span><br><span class="line">  &quot;flannel.alpha.coreos.com/kube-subnet-manager&quot;:&quot;true&quot;, \</span><br><span class="line">  &quot;flannel.alpha.coreos.com/public-ip&quot;:&quot;172.16.0.202&quot;, \</span><br><span class="line">  &quot;node.alpha.kubernetes.io/ttl&quot;:&quot;0&quot;, &quot;volumes.kubernetes.io/controller-managed-attach-detach&quot;:&quot;true&quot;&#125;</span><br></pre></td></tr></table></figure><p>显示的是 host-gw ，看下节点注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get node -o yaml | grep flannel</span><br><span class="line">      flannel.alpha.coreos.com/backend-data: &quot;null&quot;</span><br><span class="line">      flannel.alpha.coreos.com/backend-type: host-gw</span><br><span class="line">      flannel.alpha.coreos.com/kube-subnet-manager: &quot;true&quot;</span><br><span class="line">      flannel.alpha.coreos.com/public-ip: 172.16.0.104</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel@sha256:13cddb14533a10394aa9436bd96a4c866a139b7ef01e71526aae013e724acca7</span><br><span class="line">      - flannel/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin@sha256:85aa4c338969e97b1ab751fdc2c167af228a241a224e2d0e5b81ca0f3e93e1fa</span><br><span class="line">      - flannel/flannel-cni-plugin:v1.4.1-flannel1</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin:v1.4.1</span><br><span class="line">      flannel.alpha.coreos.com/backend-data: &#x27;&#123;&quot;VNI&quot;:1,&quot;VtepMAC&quot;:&quot;f6:12:96:a0:5a:14&quot;&#125;&#x27;</span><br><span class="line">      flannel.alpha.coreos.com/backend-type: vxlan</span><br><span class="line">      flannel.alpha.coreos.com/kube-subnet-manager: &quot;true&quot;</span><br><span class="line">      flannel.alpha.coreos.com/public-ip: 172.16.0.202</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel@sha256:13cddb14533a10394aa9436bd96a4c866a139b7ef01e71526aae013e724acca7</span><br><span class="line">      - flannel/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin@sha256:85aa4c338969e97b1ab751fdc2c167af228a241a224e2d0e5b81ca0f3e93e1fa</span><br><span class="line">      - flannel/flannel-cni-plugin:v1.4.1-flannel1</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin:v1.4.1</span><br><span class="line">      flannel.alpha.coreos.com/backend-data: &quot;null&quot;</span><br><span class="line">      flannel.alpha.coreos.com/backend-type: host-gw</span><br><span class="line">      flannel.alpha.coreos.com/kube-subnet-manager: &quot;true&quot;</span><br><span class="line">      flannel.alpha.coreos.com/public-ip: 172.16.0.231</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel@sha256:13cddb14533a10394aa9436bd96a4c866a139b7ef01e71526aae013e724acca7</span><br><span class="line">      - flannel/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin@sha256:85aa4c338969e97b1ab751fdc2c167af228a241a224e2d0e5b81ca0f3e93e1fa</span><br><span class="line">      - flannel/flannel-cni-plugin:v1.4.1-flannel1</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin:v1.4.1</span><br><span class="line">      flannel.alpha.coreos.com/backend-data: &quot;null&quot;</span><br><span class="line">      flannel.alpha.coreos.com/backend-type: host-gw</span><br><span class="line">      flannel.alpha.coreos.com/kube-subnet-manager: &quot;true&quot;</span><br><span class="line">      flannel.alpha.coreos.com/public-ip: 172.16.0.250</span><br></pre></td></tr></table></figure><p>怎么两个 host-gw 模式，既然删除 pod 无用，就 edit 去掉 <code>flannel.alpha.coreos.com/backend-type</code> 注解了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@vm172-16-0-202 ~]# kubectl edit node 172.16.0.202</span><br><span class="line">[root@vm172-16-0-202 ~]# kubectl -n kube-system delete pod kube-flannel-ds-2cxkf kube-flannel-ds-hml7r</span><br><span class="line">pod &quot;kube-flannel-ds-2cxkf&quot; deleted</span><br><span class="line">pod &quot;kube-flannel-ds-hml7r&quot; deleted</span><br><span class="line">[root@vm172-16-0-202 ~]# kubectl get no -o yaml | grep flannel</span><br><span class="line">      flannel.alpha.coreos.com/backend-data: &#x27;&#123;&quot;VNI&quot;:1,&quot;VtepMAC&quot;:&quot;de:87:3d:b7:74:fc&quot;&#125;&#x27;</span><br><span class="line">      flannel.alpha.coreos.com/backend-type: vxlan</span><br><span class="line">      flannel.alpha.coreos.com/kube-subnet-manager: &quot;true&quot;</span><br><span class="line">      flannel.alpha.coreos.com/public-ip: 172.16.0.104</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel@sha256:13cddb14533a10394aa9436bd96a4c866a139b7ef01e71526aae013e724acca7</span><br><span class="line">      - flannel/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin@sha256:85aa4c338969e97b1ab751fdc2c167af228a241a224e2d0e5b81ca0f3e93e1fa</span><br><span class="line">      - flannel/flannel-cni-plugin:v1.4.1-flannel1</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin:v1.4.1</span><br><span class="line">      flannel.alpha.coreos.com/backend-data: &#x27;&#123;&quot;VNI&quot;:1,&quot;VtepMAC&quot;:&quot;f6:12:96:a0:5a:14&quot;&#125;&#x27;</span><br><span class="line">      flannel.alpha.coreos.com/backend-type: vxlan</span><br><span class="line">      flannel.alpha.coreos.com/kube-subnet-manager: &quot;true&quot;</span><br><span class="line">      flannel.alpha.coreos.com/public-ip: 172.16.0.202</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel@sha256:13cddb14533a10394aa9436bd96a4c866a139b7ef01e71526aae013e724acca7</span><br><span class="line">      - flannel/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin@sha256:85aa4c338969e97b1ab751fdc2c167af228a241a224e2d0e5b81ca0f3e93e1fa</span><br><span class="line">      - flannel/flannel-cni-plugin:v1.4.1-flannel1</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin:v1.4.1</span><br><span class="line">      flannel.alpha.coreos.com/backend-data: &#x27;&#123;&quot;VNI&quot;:1,&quot;VtepMAC&quot;:&quot;1e:24:24:5e:b8:84&quot;&#125;&#x27;</span><br><span class="line">      flannel.alpha.coreos.com/backend-type: vxlan</span><br><span class="line">      flannel.alpha.coreos.com/kube-subnet-manager: &quot;true&quot;</span><br><span class="line">      flannel.alpha.coreos.com/public-ip: 172.16.0.231</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel@sha256:13cddb14533a10394aa9436bd96a4c866a139b7ef01e71526aae013e724acca7</span><br><span class="line">      - flannel/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel:v0.25.4</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin@sha256:85aa4c338969e97b1ab751fdc2c167af228a241a224e2d0e5b81ca0f3e93e1fa</span><br><span class="line">      - flannel/flannel-cni-plugin:v1.4.1-flannel1</span><br><span class="line">      - reg.xxx.lan:5000/xxx/flannel-cni-plugin:v1.4.1</span><br><span class="line">      flannel.alpha.coreos.com/backend-data: &#x27;&#123;&quot;VNI&quot;:1,&quot;VtepMAC&quot;:&quot;36:a5:28:4d:ec:e3&quot;&#125;&#x27;</span><br><span class="line">      flannel.alpha.coreos.com/backend-type: vxlan</span><br><span class="line">      flannel.alpha.coreos.com/kube-subnet-manager: &quot;true&quot;</span><br><span class="line">      flannel.alpha.coreos.com/public-ip: 172.16.0.250</span><br></pre></td></tr></table></figure><p>剩下几个 node 处理后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@vm172-16-0-202 ~]# ip r s</span><br><span class="line">default via 172.16.0.1 dev eth0 proto dhcp metric 100 </span><br><span class="line">10.97.0.0/24 via 10.97.0.0 dev flannel.1 onlink </span><br><span class="line">10.97.1.0/24 via 10.97.1.0 dev flannel.1 onlink </span><br><span class="line">10.97.2.0/24 via 172.16.0.250 dev eth0 </span><br><span class="line">10.97.2.0/24 dev cni0 proto kernel scope link src 10.97.2.1 </span><br><span class="line">10.97.3.0/24 via 10.97.3.0 dev flannel.1 onlink </span><br><span class="line">10.185.0.0/16 dev docker0 proto kernel scope link src 10.185.0.1 linkdown </span><br><span class="line">10.187.0.0/24 via 172.16.0.250 dev eth0 </span><br><span class="line">10.187.2.0/24 via 172.16.0.104 dev eth0 </span><br><span class="line">10.187.3.0/24 via 172.16.0.231 dev eth0 </span><br><span class="line">172.16.0.0/24 dev eth0 proto kernel scope link src 172.16.0.202 metric 100</span><br></pre></td></tr></table></figure><p>重启后也没问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@vm172-16-0-202 ~]# ip r</span><br><span class="line">default via 172.16.0.1 dev eth0 proto dhcp metric 100 </span><br><span class="line">10.97.0.0/24 via 10.97.0.0 dev flannel.1 onlink </span><br><span class="line">10.97.1.0/24 via 10.97.1.0 dev flannel.1 onlink </span><br><span class="line">10.97.2.0/24 dev cni0 proto kernel scope link src 10.97.2.1 </span><br><span class="line">10.97.3.0/24 via 10.97.3.0 dev flannel.1 onlink </span><br><span class="line">10.185.0.0/16 dev docker0 proto kernel scope link src 10.185.0.1 linkdown </span><br><span class="line">172.16.0.0/24 dev eth0 proto kernel scope link src 172.16.0.202 metric 100</span><br></pre></td></tr></table></figure><p>询问了是不是有人最开始部署改过模式了，说没有，奇怪了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一次 flannel 路由错乱导致的跨节点不通&lt;/p&gt;</summary>
    
    
    
    
    <category term="kubernetes" scheme="http://zhangguanzhang.github.io/tags/kubernetes/"/>
    
    <category term="flannel" scheme="http://zhangguanzhang.github.io/tags/flannel/"/>
    
    <category term="vxlan" scheme="http://zhangguanzhang.github.io/tags/vxlan/"/>
    
  </entry>
  
  <entry>
    <title>私有化下(CentOS 7)Podman调研</title>
    <link href="http://zhangguanzhang.github.io/2025/08/06/centos7-podman/"/>
    <id>http://zhangguanzhang.github.io/2025/08/06/centos7-podman/</id>
    <published>2025-08-06T10:10:30.000Z</published>
    <updated>2025-08-06T10:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 7 上 Podman调研…..</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>内部需要调研 podman 替换掉 docker，因为我们私有化要适配很多操作系统（很多客户内部规定了必须使用啥系统，所以要支持），使用最常见的 CentOS 7：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/redhat-release</span> </span><br><span class="line">CentOS Linux release 7.8.2003 (Core)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux xxx 3.10.0-1127.el7.x86_64 #1 SMP Tue Mar 31 23:36:51 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h3><p><a href="https://podman.io/docs/installation">官方安装文档</a>上并没有 centos7 的安装，因为已经 EOL 好几年。考虑到客户会无网，需要类似 docker-static 那样，搜索谷歌和 github 找到 <a href="https://github.com/mgoltzsche/podman-static">podman-static</a>。podman 最新版本是v5，下载 v5.5.2 的压缩包后解压。</p><h3 id="daemon-进程相关"><a href="#daemon-进程相关" class="headerlink" title="daemon 进程相关"></a>daemon 进程相关</h3><p>因为我们还需要调用 API，所以需要起 daemon 进程监听 socket 和 tcp，需要以下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">podman system service -h</span></span><br><span class="line">Run API service</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line">  Run an API service</span><br><span class="line"></span><br><span class="line">Enable a listening service for API access to Podman commands.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  podman system service [options] [URI]</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  podman system service --time=0 unix:///tmp/podman.sock</span><br><span class="line">  podman system service --time=0 tcp://localhost:8888</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --cors string   Set CORS Headers</span><br><span class="line">  -t, --time uint     Time until the service session expires in seconds.  Use 0 to disable the timeout (default 5)</span><br></pre></td></tr></table></figure><p>发现无法同时监听 tcp 和 socket，并且 tcp 不支持tls选项，搜索issue <a href="https://github.com/containers/podman/issues/24583">Support (m)TLS API socket</a>发现暂未支持，只能使用 socket 监听。</p><p>然后发现无法监听指定路径 socket文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">API service listening on \&quot;/run/podman/podman.sock\&quot;. URI: \&quot;unix:///var/run/docker.sock\&quot;&quot;</span><br></pre></td></tr></table></figure><p>查阅 podman 源码，发现走到以下逻辑：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containers/podman/blob/v5.5.2/cmd/podman/system/service_abi.go#L58-L77</span></span><br><span class="line">        <span class="keyword">switch</span> uri.Scheme &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;unix&quot;</span>:</span><br><span class="line">            path, err := filepath.Abs(uri.Path)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> os.Getenv(<span class="string">&quot;LISTEN_FDS&quot;</span>) != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                <span class="comment">// If it is activated by systemd, use the first LISTEN_FD (3)</span></span><br><span class="line">                <span class="comment">// instead of opening the socket file.</span></span><br><span class="line">                f := os.NewFile(<span class="type">uintptr</span>(<span class="number">3</span>), <span class="string">&quot;podman.sock&quot;</span>)</span><br><span class="line">                listener, err = net.FileListener(f)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listener, err = net.Listen(uri.Scheme, path)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to create socket: %w&quot;</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>通过查看 env 发现确实有 <code>LISTEN_FDS</code> 的 env：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">xargs -n1 -0 &lt; /proc/$(pgrep podman)/environ</span></span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">PATH=&quot;/data/kube/bin:/bin:/sbin:/usr/bin:/usr/sbin&quot;</span><br><span class="line">LISTEN_PID=9047</span><br><span class="line">LISTEN_FDS=1</span><br><span class="line">LOGGING=&quot;--log-level=info&quot;</span><br></pre></td></tr></table></figure><p>看了下代码说明，是支持 systemd 的 socket 主动激活，我们不需要，去掉压缩包里的:</p><ol><li><code>system/podman.socket</code></li><li><code>system/podman.service</code> 内 require和 after podman.socket</li></ol><p>然后启动可行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">API service listening on &quot;/var/run/docker.sock&quot;. URI: &quot;unix:///var/run/docker.sock&quot;</span><br></pre></td></tr></table></figure><h3 id="info-的-format-差异"><a href="#info-的-format-差异" class="headerlink" title="info 的 format 差异"></a>info 的 format 差异</h3><p>我们使用到了部分 info 里的 format 存在差异：</p><ol><li><code>&#39;&#123;&#123;.OSType&#125;&#125;&#39;</code> -&gt; <code>&#39;&#123;&#123;.Host.OS&#125;&#125;&#39;</code></li><li><code>&#39;&#123;&#123;.DockerRootDir&#125;&#125;&#39;</code> -&gt; <code>&#39;&#123;&#123;.Store.GraphRoot&#125;&#125;&#39;</code></li></ol><h3 id="非-host-网络容器"><a href="#非-host-网络容器" class="headerlink" title="非 host 网络容器"></a>非 host 网络容器</h3><p>部署后发现无法启动非 host 网络容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name registry_pass --entrypoint htpasswd registry:2.7.1</span></span><br><span class="line">Error: creating network namespace for container 3de0fd230fd7693a107de4b56e5ab1444a558ae1e835e78e292ed364915a6362: failed to create namespace: failed to bind mount ns at /run/netns/netns-b0f807fe-e630-3182-e16b-5b5837e2b1a3: no such file or directory</span><br></pre></td></tr></table></figure><p>golang 代码的 Error 是信息叠加的，所以可以直接搜索报错 <code>creating network namespace for container</code> ，找到报错代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containers/podman/blob/v5.5.2/libpod/networking_linux.go#L77-L81</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runtime)</span></span> createNetNS(ctr *Container) (n <span class="type">string</span>, q <span class="keyword">map</span>[<span class="type">string</span>]types.StatusBlock, retErr <span class="type">error</span>) &#123;</span><br><span class="line">    ctrNS, err := netns.NewNS()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;creating network namespace for container %s: %w&quot;</span>, ctr.ID(), err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>跳转到 <code>netns.NewNS()</code> 内：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNS</span><span class="params">()</span></span> (ns.NetNS, <span class="type">error</span>) &#123;</span><br><span class="line">    nsRunDir, err := GetNSRunDir()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the directory for mounting network namespaces</span></span><br><span class="line">    <span class="comment">// This needs to be a shared mountpoint in case it is mounted in to</span></span><br><span class="line">    <span class="comment">// other namespaces (containers)</span></span><br><span class="line">    err = makeNetnsDir(nsRunDir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> <span class="number">10000</span> &#123;</span><br><span class="line">        nsName, err := getRandomNetnsName()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        nsPath := path.Join(nsRunDir, nsName)</span><br><span class="line">        ns, err := newNSPath(nsPath)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ns, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// retry when the name already exists</span></span><br><span class="line">        <span class="keyword">if</span> errors.Is(err, os.ErrExist) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errNoFreeName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是那行 <code>makeNetnsDir()</code> 报错，内部都是基础的文件和 ns mount 操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeNetnsDir</span><span class="params">(nsRunDir <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    err := os.MkdirAll(nsRunDir, <span class="number">0o755</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Important, the bind mount setup is racy if two process try to set it up in parallel.</span></span><br><span class="line">    <span class="comment">// This can have very bad consequences because we end up with two duplicated mounts</span></span><br><span class="line">    <span class="comment">// for the netns file that then might have a different parent mounts.</span></span><br><span class="line">    <span class="comment">// Also because as root netns dir is also created by ip netns we should not race against them.</span></span><br><span class="line">    <span class="comment">// Use a lock on the netns dir like they do, compare the iproute2 ip netns add code.</span></span><br><span class="line">    <span class="comment">// https://github.com/iproute2/iproute2/blob/8b9d9ea42759c91d950356ca43930a975d0c352b/ip/ipnetns.c#L806-L815</span></span><br><span class="line"></span><br><span class="line">    dirFD, err := unix.Open(nsRunDir, unix.O_RDONLY|unix.O_DIRECTORY|unix.O_CLOEXEC, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;os.PathError&#123;Op: <span class="string">&quot;open&quot;</span>, Path: nsRunDir, Err: err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// closing the fd will also unlock so we do not have to call flock(fd,LOCK_UN)</span></span><br><span class="line">    <span class="keyword">defer</span> unix.Close(dirFD)</span><br><span class="line"></span><br><span class="line">    err = unix.Flock(dirFD, unix.LOCK_EX)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to lock %s dir: %w&quot;</span>, nsRunDir, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remount the namespace directory shared. This will fail with EINVAL</span></span><br><span class="line">    <span class="comment">// if it is not already a mountpoint, so bind-mount it on to itself</span></span><br><span class="line">    <span class="comment">// to &quot;upgrade&quot; it to a mountpoint.</span></span><br><span class="line">    err = unix.Mount(<span class="string">&quot;&quot;</span>, nsRunDir, <span class="string">&quot;none&quot;</span>, unix.MS_SHARED|unix.MS_REC, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != unix.EINVAL &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;mount --make-rshared %s failed: %q&quot;</span>, nsRunDir, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively remount /run/netns on itself. The recursive flag is</span></span><br><span class="line">    <span class="comment">// so that any existing netns bindmounts are carried over.</span></span><br><span class="line">    err = unix.Mount(nsRunDir, nsRunDir, <span class="string">&quot;none&quot;</span>, unix.MS_BIND|unix.MS_REC, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;mount --rbind %s %s failed: %q&quot;</span>, nsRunDir, nsRunDir, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we can make it shared</span></span><br><span class="line">    err = unix.Mount(<span class="string">&quot;&quot;</span>, nsRunDir, <span class="string">&quot;none&quot;</span>, unix.MS_SHARED|unix.MS_REC, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;mount --make-rshared %s failed: %q&quot;</span>, nsRunDir, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载代码后编译 podman 调试看看 <code>makeNetnsDir()</code> 具体哪个步骤出问题，发现无法跳到断点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ dlv exec bin/podman --  run  -ti --entrypoint ls docker.io/library/registry:2.7.1</span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) b libpod/networking_linux.go:78</span><br><span class="line">Breakpoint 1 set at 0x1555494 for github.com/containers/podman/v5/libpod.(*Runtime).createNetNS() ./libpod/networking_linux.go:78</span><br><span class="line">(dlv) c</span><br><span class="line">WARN[0000] Using cgroups-v1 which is deprecated in favor of cgroups-v2 with Podman v5 and will be removed in a future version. Set environment variable `PODMAN_IGNORE_CGROUPSV1_WARNING` to hide this warning. </span><br><span class="line">WARN[0000] The input device is not a TTY. The --tty and --interactive flags might not work properly </span><br><span class="line">received SIGINT, stopping process (will not forward signal)</span><br><span class="line">&gt; runtime.futex() /usr/local/go/src/runtime/sys_linux_amd64.s:558 (PC: 0x492243)</span><br><span class="line">Warning: debugging optimized function</span><br><span class="line">   553:        MOVQ    ts+16(FP), R10</span><br><span class="line">   554:        MOVQ    addr2+24(FP), R8</span><br><span class="line">   555:        MOVL    val3+32(FP), R9</span><br><span class="line">   556:        MOVL    $SYS_futex, AX</span><br><span class="line">   557:        SYSCALL</span><br><span class="line">=&gt; 558:        MOVL    AX, ret+40(FP)</span><br></pre></td></tr></table></figure><p>然后发现 <code>podman info</code> 也卡住：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/podman  info</span></span><br><span class="line">WARN[0000] Using cgroups-v1 which is deprecated in favor of cgroups-v2 with Podman v5 and will be removed in a future version. Set environment variable `PODMAN_IGNORE_CGROUPSV1_WARNING` to hide this warning. </span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>看了下 <code>podman info</code> 调用链，调试了下发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(dlv) n</span><br><span class="line">&gt; github.com/containers/podman/v5/libpod.(*Runtime).hostInfo() ./libpod/info.go:106 (PC: 0x21d942e)</span><br><span class="line">   101:        cpuUtil, err := getCPUUtilization()</span><br><span class="line">   102:        if err != nil &#123;</span><br><span class="line">   103:            return nil, err</span><br><span class="line">   104:        &#125;</span><br><span class="line">   105:    </span><br><span class="line">=&gt; 106:        locksFree, err := r.lockManager.AvailableLocks()</span><br><span class="line">   107:        if err != nil &#123;</span><br><span class="line">   108:            return nil, fmt.Errorf(&quot;getting free locks: %w&quot;, err)</span><br><span class="line">   109:        &#125;</span><br><span class="line">   110:    </span><br><span class="line">   111:        info := define.HostInfo&#123;</span><br><span class="line">(dlv) n</span><br></pre></td></tr></table></figure><p>看了下代码是卡在 cgo 的 shm lock 那里，无法调试找到网络ns创建问题。</p><h3 id="v4版本尝试"><a href="#v4版本尝试" class="headerlink" title="v4版本尝试"></a>v4版本尝试</h3><p>v4 已经不维护，官方主干版本是 v5，尝试下载了最新的v4 v4.9.5 启动报错不支持：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">podman run --entrypoint <span class="built_in">ls</span> alpine:latest</span></span><br><span class="line">Error: netavark: create veth pair: Netlink error: Not supported (os error 95)</span><br></pre></td></tr></table></figure><p>对于v5和v4的报错均搜索到类似的问题:</p><ul><li><a href="https://github.com/mgoltzsche/podman-static/issues/138">https://github.com/mgoltzsche/podman-static/issues/138</a></li><li><a href="https://github.com/containers/podman/discussions/12840">https://github.com/containers/podman/discussions/12840</a></li></ul><p>centos7的3.10内核不满足最低的4.18</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>podman 现阶段不支持 tls，并且 socket 和 tcp 无法同时监听，安全问题只能使用 socket 文件，无法远程管理</li><li>私有化需要支持众多操作系统下，内核版本跨度从老到新都有，无法使用 podman，如果不是私有化自己单一环境且有网的情况下，可以使用</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;CentOS 7 上 Podman调研…..&lt;/p&gt;</summary>
    
    
    
    
    <category term="podman" scheme="http://zhangguanzhang.github.io/tags/podman/"/>
    
    <category term="centos" scheme="http://zhangguanzhang.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>python grpc 使用域名第一次耗时长问题</title>
    <link href="http://zhangguanzhang.github.io/2025/07/29/python-grpc-first-long/"/>
    <id>http://zhangguanzhang.github.io/2025/07/29/python-grpc-first-long/</id>
    <published>2025-07-29T17:40:30.000Z</published>
    <updated>2025-07-29T17:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近给同事解决的 python grpc 耗时长问题…..</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>昨天上着班突然被群里拉到一个开发任务群里，看了下聊天记录说啥慢，询问了下理清了流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> client    server1   model server</span><br><span class="line">┌──┐        ┌──┐        ┌──┐ </span><br><span class="line">└┬─┘        └┬─┘        └─┬┘ </span><br><span class="line"> ├───http───►│            │  </span><br><span class="line"> │           ├───grpc────►│  </span><br><span class="line"> │           │◄──grpc─────┤  </span><br><span class="line"> │◄───http───┤            │  </span><br><span class="line">                          </span><br></pre></td></tr></table></figure><p>http 客户端请求服务1，带了模型服务的 <code>model_url</code>，server1 会 grpc 请求 <code>model_url</code>，然后发现回复非常慢，把 <code>ai-xxx</code> 换成实际的外部 IP 就会很快。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl --location &#x27;http://xxxx:8870/chat&#x27; \</span><br><span class="line">    --header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">    --data &#x27;&#123;</span><br><span class="line">        &quot;stream&quot;: true,</span><br><span class="line">        &quot;messages_type&quot;: 1,</span><br><span class="line">        &quot;title&quot;: &quot;人工智能&quot;,</span><br><span class="line">        &quot;inspiration&quot;: &quot;文风严谨，语言简洁凝练&quot;,</span><br><span class="line">        &quot;model_config&quot;: &#123;</span><br><span class="line">            &quot;default&quot;: true,</span><br><span class="line">            &quot;type&quot;: &quot;xxxx&quot;,</span><br><span class="line">            &quot;model_url&quot;: &quot;ai-xxx&quot;,</span><br><span class="line">            &quot;model_name&quot;: &quot;xxxxx-xxxx&quot;,</span><br><span class="line">            &quot;model&quot;: &quot;xxxxx&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x27;</span><br></pre></td></tr></table></figure><p>环境上测了下果然是，server1 的访问日志看有 9s 左右耗时，看了下环境是 k8s， <code>ai-xxx</code> 是直接创建的 svc 和 ep，endpoint 为外部一个模型服务的 ip 端口。看了下 server1 内的 <code>/etc/nsswitch</code> 正常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep hosts /etc/nsswitch.conf </span><br><span class="line">hosts:          files dns</span><br></pre></td></tr></table></figure><p>加了下 hosts 测下还是每次都必现，可以肯定和 k8s dns 无关了，如果是 k8s dns 5s timeout 问题，那是 IPv6 的 AAAA 记录五元组冲突导致的超时的话都是偶现而非必现，和这个不一样。</p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>初步怀疑是研发的 server1 后端接口逻辑有问题，但是他们说有些环境正常有些不正常，于是我让他们给个最小的 python grpc client 访问模型的 demo。这样二分排除范围，不然两个链路不好查。没想到今天测试又催这个问题看得咋样了。然后让研发把 demo 发过来看。</p><h3 id="demo-复现"><a href="#demo-复现" class="headerlink" title="demo 复现"></a>demo 复现</h3><p>拿到 demo 有点无语，这种耗时的打印居然是用的 print，手动修改成 logging 后测试复现了，大概逻辑如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server_urls = [</span><br><span class="line">    <span class="string">&quot;ai-xxx:80&quot;</span>,</span><br><span class="line">    <span class="string">&quot;10.xx.xx.xxx:10037&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> server_url <span class="keyword">in</span> server_urls:</span><br><span class="line">    grpc_test()</span><br></pre></td></tr></table></figure><p>拷贝到 server1 的容器里执行，发现必现，耗时久的附近是如下 <code>35s - 43s</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2025-07-29 16:52:35 [INFO] 🔥 开始测试GRPC连接: ai-xxx:80</span><br><span class="line">2025-07-29 16:52:35 [INFO] 📡 创建Triton客户端...</span><br><span class="line">2025-07-29 16:52:35 [INFO] ✅ 客户端创建成功</span><br><span class="line">2025-07-29 16:52:35 [INFO] 🔍 检查服务器状态...</span><br><span class="line">2025-07-29 16:52:43 [INFO]    服务器存活: ✅</span><br><span class="line">2025-07-29 16:52:43 [INFO]    服务器就绪: ✅</span><br><span class="line">2025-07-29 16:52:43 [INFO] ✅ 服务器状态检查通过</span><br><span class="line">...</span><br><span class="line">2025-07-29 16:52:44 [INFO] 🔥 开始测试GRPC连接: 10.xx.xx.xxx:10037</span><br><span class="line">2025-07-29 16:52:44 [INFO] 📡 创建Triton客户端...</span><br><span class="line">2025-07-29 16:52:44 [INFO] ✅ 客户端创建成功</span><br><span class="line">2025-07-29 16:52:44 [INFO] 🔍 检查服务器状态...</span><br><span class="line">2025-07-29 16:52:44 [INFO]    服务器存活: ✅</span><br><span class="line">2025-07-29 16:52:44 [INFO]    服务器就绪: ✅</span><br><span class="line">2025-07-29 16:52:44 [INFO] ✅ 服务器状态检查通过</span><br></pre></td></tr></table></figure><p>看了下 demo 代码对应位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">triton_client = grpcclient.InferenceServerClient(</span><br><span class="line">    url=server_url,</span><br><span class="line">    verbose=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line">logging.info(<span class="string">&quot;✅ 客户端创建成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查服务器状态</span></span><br><span class="line">logging.info(<span class="string">&quot;🔍 检查服务器状态is_server_live&quot;</span>)</span><br><span class="line">is_live = triton_client.is_server_live()</span><br><span class="line">logging.info(<span class="string">&quot;🔍 检查服务器状态is_server_ready&quot;</span>)</span><br><span class="line">is_ready = triton_client.is_server_ready()</span><br></pre></td></tr></table></figure><p><code>python -m pdb grpc-test.py</code> 调试了下，发现这个方法只是一个纯粹的 grpc 请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(Pdb) n</span><br><span class="line">&gt; /usr/local/lib/python3<span class="number">.10</span>/site-packages/tritonclient/grpc/_client.py(<span class="number">294</span>)is_server_live()</span><br><span class="line">-&gt; <span class="keyword">try</span>:</span><br><span class="line">(Pdb) <span class="built_in">list</span></span><br><span class="line"><span class="number">289</span>          InferenceServerException</span><br><span class="line"><span class="number">290</span>              If unable to get liveness <span class="keyword">or</span> has timed out.</span><br><span class="line"><span class="number">291</span>  </span><br><span class="line"><span class="number">292</span>          <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">293          metadata = self._get_metadata(headers)</span></span><br><span class="line"><span class="string">294  -&gt;        try:</span></span><br><span class="line"><span class="string">295              request = service_pb2.ServerLiveRequest()</span></span><br><span class="line"><span class="string">296              if self._verbose:</span></span><br><span class="line"><span class="string">297                  print(&quot;is_server_live, metadata &#123;&#125;\n&#123;&#125;&quot;.format(metadata, request))</span></span><br><span class="line"><span class="string">298              response = self._client_stub.ServerLive(</span></span><br><span class="line"><span class="string">299                  request=request, metadata=metadata, timeout=client_timeout</span></span><br></pre></td></tr></table></figure><p>grpc 客户端用的 <code>tritonclient</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip list | grep client</span></span><br><span class="line">tritonclient           2.57.0</span><br></pre></td></tr></table></figure><p><a href="https://pypi.org/project/tritonclient/#history">pypi</a> 查了下这个 grpc 库发现找到的仓库 <a href="https://github.com/triton-inference-server/client">triton-inference-server&#x2F;client</a> 分支和上面版本号对不上，很奇怪。</p><p>谷歌搜了下 <code>is_server_live long time</code> 发现能搜到同样问题 <a href="https://github.com/triton-inference-server/server/issues/3800">is_server_live() python GRPC client got no response</a>，但是别人用的是 IP ，后面还把 issue 关闭了说是他们自己的网络问题。</p><p>然后让研发找 <code>is_server_live()</code> 的 grpc server 端研发查下 <code>ServerLive</code> 接口调用逻辑，另一方面让 server1 研发把 <code>is_server_live()</code> 注释了试试，他说走 CI 流程会稍微慢些，让我看看环境上能直接改不，于是大家一起并行操作。</p><h3 id="稍有眉目"><a href="#稍有眉目" class="headerlink" title="稍有眉目"></a>稍有眉目</h3><p>发现环境改了后还是复现，于是我在 demo 里改了下发现慢在第二个了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 检查服务器状态</span></span><br><span class="line">logging.info(<span class="string">&quot;🔍 检查服务器状态is_server_live&quot;</span>)</span><br><span class="line"><span class="comment"># is_live = triton_client.is_server_live()</span></span><br><span class="line">logging.info(<span class="string">&quot;🔍 检查服务器状态is_server_ready&quot;</span>)</span><br><span class="line"><span class="comment"># is_ready = triton_client.is_server_ready()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># logging.info(f&quot;   服务器存活: &#123;&#x27;✅&#x27; if is_live else &#x27;❌&#x27;&#125;&quot;)</span></span><br><span class="line"><span class="comment"># logging.info(f&quot;   服务器就绪: &#123;&#x27;✅&#x27; if is_ready else &#x27;❌&#x27;&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if not is_live:</span></span><br><span class="line"><span class="comment">#     raise Exception(&quot;服务器未存活&quot;)</span></span><br><span class="line"><span class="comment"># if not is_ready:</span></span><br><span class="line"><span class="comment">#     raise Exception(&quot;服务器未就绪&quot;)</span></span><br><span class="line"></span><br><span class="line">logging.info(<span class="string">&quot;✅ 服务器状态检查通过&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 获取模型信息</span></span><br><span class="line">logging.info(<span class="string">&quot;📋 获取模型信息...&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    model_metadata = triton_client.get_model_metadata(<span class="string">&quot;xxxxx&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2025-07-29 17:32:32 [INFO] ✅ 客户端创建成功</span><br><span class="line">2025-07-29 17:32:32 [INFO] 🔍 检查服务器状态is_server_live</span><br><span class="line">2025-07-29 17:32:32 [INFO] 🔍 检查服务器状态is_server_ready</span><br><span class="line">2025-07-29 17:32:32 [INFO] ✅ 服务器状态检查通过</span><br><span class="line">2025-07-29 17:32:32 [INFO] 📋 获取模型信息...</span><br><span class="line">2025-07-29 17:32:40 [INFO] ✅ 成功获取模型元数据</span><br><span class="line">2025-07-29 17:32:40 [INFO]    模型名称: xxxx</span><br><span class="line">2025-07-29 17:32:40 [INFO]    模型版本: [&#x27;1&#x27;]</span><br><span class="line">2025-07-29 17:32:40 [INFO] 🧠 执行简单推理测试...</span><br><span class="line">2025-07-29 17:32:40 [INFO] ✅ 流启动成功</span><br><span class="line">2025-07-29 17:32:40 [INFO] ✅ 推理请求发送成功</span><br><span class="line">2025-07-29 17:32:40 [INFO] ⏳ 等待响应...</span><br><span class="line">2025-07-29 17:32:40 [INFO] ✅ 收到成功响应</span><br><span class="line">2025-07-29 17:32:40 [INFO]    输出tokens: [9]</span><br><span class="line">2025-07-29 17:32:40 [INFO] 🎉 GRPC连接测试完全成功!</span><br><span class="line">2025-07-29 17:32:40 [INFO] 🎉 务器 ai-xxx:80 测试成功!</span><br></pre></td></tr></table></figure><p>这次不是前面的 <code>is_server_live()</code> 问题，仔细看了下代码想了下是 <code>grpcclient</code> 的第一个 grpc 请求有问题导致耗时长，搜索了下发现一样相似但是更耗时的问题：</p><ul><li><a href="https://github.com/triton-inference-server/server/issues/1821">https://github.com/triton-inference-server/server/issues/1821</a></li></ul><p>不过上面 issue 里 triton 官方说是 <code>grpc/grpc</code> 的问题， 搜到 <a href="https://github.com/grpc/grpc/issues/22260">Communication from c++ server to python client is too slow</a> 说 python 很慢但是 c++ 的不慢，python 的首次 grpc 建立连接耗时很长，后续的请求都在 ms 内完成。issue 内下面大佬排查出耗时大部分开销都是在 libc 相关调用上。</p><p>众所周知，grpc 是长连接后推流，让研发要不要改代码写成连接池试试，他们说来不及。</p><p>感觉既然和 triton 无关，就搜 <code>python grpc dns first time long</code> 搜到了 <a href="https://github.com/grpc/grpc/issues/24018">Python client hangs on first connection</a> 类似问题，排查和 DNS 相关，发现大佬说试试 <code>GRPC_DNS_RESOLVER=native</code> ，搜了下 <code>grpc/grpc</code> 官方文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* GRPC_DNS_RESOLVER</span><br><span class="line">  Declares which DNS resolver to use. The default is ares if gRPC is built with</span><br><span class="line">  c-ares support. Otherwise, the value of this environment variable is ignored.</span><br><span class="line">  Available DNS resolver include:</span><br><span class="line">  - ares (default on most platforms except iOS, Android or Node)- a DNS</span><br><span class="line">    resolver based around the c-ares library</span><br><span class="line">  - native - a DNS resolver based around getaddrinfo(), creates a new thread to</span><br><span class="line">    perform name resolution</span><br></pre></td></tr></table></figure><p>默认是 c 的库 <code>c-ares</code> 去解析的，设置为 <code>native</code> 则使用系统 libc 的 <code>getaddrinfo()</code> ，于是测试了下可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">GRPC_DNS_RESOLVER=native python3  /root/test2.py</span> </span><br><span class="line">2025-07-29 17:59:43 [INFO] ✅ tritonclient导入成功</span><br><span class="line">2025-07-29 17:59:43 [INFO] ============================================================</span><br><span class="line">2025-07-29 17:59:43 [INFO] 🚀 GRPC连接测试工具</span><br><span class="line">2025-07-29 17:59:43 [INFO] ============================================================</span><br><span class="line">2025-07-29 17:59:43 [INFO] </span><br><span class="line">📍 测试服务器: ai-xxx:80</span><br><span class="line">2025-07-29 17:59:43 [INFO] ----------------------------------------</span><br><span class="line">2025-07-29 17:59:43 [INFO] 🔍 测试DNS解析: ai-xxx:80</span><br><span class="line">2025-07-29 17:59:43 [INFO] ✅ DNS解析成功: ai-xxx -&gt; 10.186.44.250:80</span><br><span class="line">2025-07-29 17:59:43 [INFO] 🔥 开始测试GRPC连接: ai-xxx:80</span><br><span class="line">2025-07-29 17:59:43 [INFO] 📡 创建Triton客户端...</span><br><span class="line">2025-07-29 17:59:43 [INFO] ✅ 客户端创建成功</span><br><span class="line">2025-07-29 17:59:43 [INFO] 🔍 检查服务器状态is_server_live</span><br><span class="line">2025-07-29 17:59:44 [INFO] 🔍 检查服务器状态is_server_ready</span><br><span class="line">2025-07-29 17:59:44 [INFO]    服务器存活: ✅</span><br><span class="line">2025-07-29 17:59:44 [INFO]    服务器就绪: ✅</span><br><span class="line">2025-07-29 17:59:44 [INFO] ✅ 服务器状态检查通过</span><br><span class="line">2025-07-29 17:59:44 [INFO] 📋 获取模型信息...</span><br><span class="line">2025-07-29 17:59:44 [INFO] ✅ 成功获取模型元数据</span><br><span class="line">2025-07-29 17:59:44 [INFO]    模型名称: xxxx</span><br><span class="line">2025-07-29 17:59:44 [INFO]    模型版本: [&#x27;1&#x27;]</span><br><span class="line">2025-07-29 17:59:44 [INFO] 🧠 执行简单推理测试...</span><br><span class="line">2025-07-29 17:59:44 [INFO] ✅ 流启动成功</span><br><span class="line">2025-07-29 17:59:44 [INFO] ✅ 推理请求发送成功</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近给同事解决的 python grpc 耗时长问题…..&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://zhangguanzhang.github.io/tags/python/"/>
    
    <category term="grpc" scheme="http://zhangguanzhang.github.io/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>golang gitlab subgroup 构建问题</title>
    <link href="http://zhangguanzhang.github.io/2025/06/17/golang-gitlab-subgroup/"/>
    <id>http://zhangguanzhang.github.io/2025/06/17/golang-gitlab-subgroup/</id>
    <published>2025-06-17T14:40:30.000Z</published>
    <updated>2025-06-17T14:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近给同事解决的 subgroup 问题…..</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>开发构建 Docker 镜像报错没权限拉取依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">xxxapi/middlewares imports</span><br><span class="line">xxx.xxxgitlab.net/x/xx/xxx/econtext: xxx.xxxgitlab.net/x/xx/xxx@v1.6.5-rc.7.0.20250609085545-4855369c0f1e: invalid version: git ls-remote -q origin in /go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c: exit status 128:</span><br><span class="line">remote: </span><br><span class="line">remote: ========================================================================</span><br><span class="line">remote: </span><br><span class="line">remote: The project you were looking for could not be found or you don&#x27;t have permission to view it.</span><br><span class="line">remote: </span><br><span class="line">remote: ========================================================================</span><br><span class="line">remote: </span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>镜像内有 gitlab 的 deploy keys，初步怀疑是没依赖仓库权限，让开发联系该依赖仓库负责人，去开启 <code>Enabled deploy keys</code> 后还是一样。</p><h3 id="手动构建测试"><a href="#手动构建测试" class="headerlink" title="手动构建测试"></a>手动构建测试</h3><p>登录到构建机器上，docker build 实际就是按照 Dockerfile 来 docker run 和 docker commit 的结合，找到失败的 run 的镜像 id：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br><span class="line">b7c4be99d86d   ba54b82c5b1c                                                        &quot;/bin/sh -c &#x27;IN_DOCK…&quot;   4 hours ago    Exited (1) 1 hours ago              nervous_chandrasekhar</span><br></pre></td></tr></table></figure><p>用上面的镜像 ID 和 command 手动测下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --<span class="built_in">rm</span> -ti --entrypoint bash ba54b82c5b1c</span></span><br><span class="line">root@a9114c46d496:/go/src/xxx.xxxgitlab.net/xxxxx/# IN_DOCKER=1 bash ./build.sh</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>报错依旧，<code>GOPRIVATE</code> <code>GONOPROXY</code> 啥的都配置了的，以及 ssh 相关 <code>git config --global url.&quot;git@xxx.xxxgitlab.net:&quot;.insteadof &quot;https://xxx.xxxgitlab.net/&quot;</code>都是以及配置了没问题的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.gitconfig</span></span><br><span class="line">[url &quot;git@xxx.xxxgitlab.net:&quot;]</span><br><span class="line">insteadof = https://xxx.xxxgitlab.net/</span><br></pre></td></tr></table></figure><p>用 git 测试也没问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@xxx.xxxgitlab.net</span></span><br><span class="line">Welcome to GitLab, @xxxx_reporter!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> xxx.xxxgitlab.net/x/xx/xxx</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看了下 go 的 help ，发现 <code>go mod</code> 没有 debug level 相关 cmdline，但是 <code>go get</code> 有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get -x  xxx.xxxgitlab.net/x/xx/xxx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get https://xxx.xxxgitlab.net/x/xx/xxx?go-get=1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get https://xxx.xxxgitlab.net/x/xx/xxx?go-get=1: 200 OK (0.063s)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get https://xxx.xxxgitlab.net/docmxini/xx?go-get=1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get https://xxx.xxxgitlab.net/x/xx?go-get=1: 200 OK (0.016s)</span></span><br><span class="line">mkdir -p /go/pkg/mod/cache/vcs # git3 https://xxx.xxxgitlab.net/x/xx.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lock /go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c.lock</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c <span class="keyword">for</span> git3 https://xxx.xxxgitlab.net/x/fx.git</span></span><br><span class="line">cd /go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c; git -c log.showsignature=false log --no-decorate -n1 &#x27;--format=format:%H %ct %D&#x27; 4855369c0f1e --</span><br><span class="line">0.002s # cd /go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c; git -c log.showsignature=false log --no-decorate -n1 &#x27;--format=format:%H %ct %D&#x27; 4855369c0f1e --</span><br><span class="line">cd /go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c; git ls-remote -q origin</span><br><span class="line">0.232s # cd /go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c; git ls-remote -q origin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get https://xxx.xxxgitlab.net/x/xx.git</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get https://xxx.xxxgitlab.net/x/xx.git: 200 OK (0.076s)</span></span><br><span class="line">cd /go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c; git tag -l</span><br><span class="line">0.002s # cd /go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c; git tag -l</span><br><span class="line">go: xxx.xxxgitlab.net/x/xx/xxx@v1.6.5-rc.7.0.20250609085545-4855369c0f1e: invalid version: git ls-remote -q origin in /go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c: exit status 128:</span><br><span class="line">remote: </span><br><span class="line">remote: ========================================================================</span><br><span class="line">remote: </span><br><span class="line">remote: The project you were looking for could not be found or you don&#x27;t have permission to view it.</span><br><span class="line">remote: </span><br><span class="line">remote: ========================================================================</span><br><span class="line">remote: </span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><p>上面最后的命令报错，cd 进去执行下看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /go/pkg/mod/cache/vcs/672638ca2205d3f2cdc0288db28840b769e58250b95fbbd31e553c6c8076fc3c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git ls-remote</span></span><br><span class="line">remote: </span><br><span class="line">remote: ========================================================================</span><br><span class="line">remote: </span><br><span class="line">remote: The project you were looking for could not be found or you don&#x27;t have permission to view it.</span><br><span class="line">remote: </span><br><span class="line">remote: ========================================================================</span><br><span class="line">remote: </span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><p>其实前面的 <code>go get -x</code> 里就有问题详细信息了，这里我是看目录下文件发现的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al</span></span><br><span class="line">total 28</span><br><span class="line">drwxr-xr-x  7 root root  119 Jun 17 03:53 .</span><br><span class="line">drwxr-xr-x 20 root root 8192 Jun 17 03:53 ..</span><br><span class="line">-rw-r--r--  1 root root   23 Jun 17 03:53 HEAD</span><br><span class="line">drwxr-xr-x  2 root root    6 Jun 17 03:53 branches</span><br><span class="line">-rw-r--r--  1 root root  179 Jun 17 03:53 config</span><br><span class="line">-rw-r--r--  1 root root   73 Jun 17 03:53 description</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jun 17 03:53 hooks</span><br><span class="line">drwxr-xr-x  2 root root   21 Jun 17 03:53 info</span><br><span class="line">drwxr-xr-x  4 root root   30 Jun 17 03:53 objects</span><br><span class="line">drwxr-xr-x  4 root root   31 Jun 17 03:53 refs</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> config</span></span><br><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = true</span><br><span class="line">bare = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = https://xxx.xxxgitlab.net/x/xx.git</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure><p>仓库地址不对，改成 <code>url = https://xxx.xxxgitlab.net/x/xx/xxx.git</code> 后就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git ls-remote | <span class="built_in">head</span></span></span><br><span class="line">From git@xxx.xxxgitlab.net:x/xx/xxx.git</span><br><span class="line">74f35a28ecc0f9721a49c41fb5d7bffa071d1502HEAD</span><br><span class="line">295c3a79dfc0d27022459d0cec21411031edd5e8refs/heads/0xxx</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="gitlab-subgroup"><a href="#gitlab-subgroup" class="headerlink" title="gitlab subgroup"></a>gitlab subgroup</h3><p>搜了下，发现是 gitlab 的鉴权和 golang 的 get 逻辑冲突，双方都认为对方不规范，谁都不让谁，具体见文章:</p><ul><li><a href="https://mp.weixin.qq.com/s/D_AsV9QpOZ_5v8f1eKoxjQ">Go 模块使用 GitLab subgroups 的问题</a></li><li><a href="https://docs.gitlab.com/ee/user/project/use_project_as_go_package.html#authenticate-go-requests-to-private-projects">use_project_as_go_package</a></li><li><a href="https://go.dev/ref/mod#private-module-proxy-auth">private-module-proxy-auth</a></li><li><a href="https://gitlab.com/gitlab-org/gitlab/-/issues/437005">Allow to set a go-modules folder for private Go projects</a></li></ul><p>解决方案只有两种，一种是 <code>~/.netrc</code> 但是是明文密码，不适用于 CI&#x2F;CD 构建。<br>使用 replace 的话需要指定一样的版本，而 <code>go get</code> 升级依赖的时候 replace 不会动。<br>写 shell 在 <code>go build</code> 前执行的话，怕正则边界和模糊匹配到了前缀一样的，并且 <code>go mod edit -json</code> 可以输出 json 信息，好在 golang 编译镜像是 ubuntu，内部有 python。</p><h3 id="脚本解决"><a href="#脚本解决" class="headerlink" title="脚本解决"></a>脚本解决</h3><p>花了点时间写了如下 python 脚本，执行方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -json | python3 scripts/golang-subgroup.py \</span><br><span class="line">  --repo xxx.xxxgitlab.net/x/xx/xxx \</span><br><span class="line">  --repo xxx.xxxgitlab.net/x/xx/xxx2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">go mod edit -json &gt; go.mod.json</span><br><span class="line">python3 scripts/golang-subgroup.py \</span><br><span class="line">  --repo xxx.xxxgitlab.net/x/xx/xxx \</span><br><span class="line">  --repo xxx.xxxgitlab.net/x/xx/xxx2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_args</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;解决 go.mod 里的 gitlab subgroups 问题&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--repo&#x27;</span>, action=<span class="string">&#x27;append&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;要处理的仓库名字，例如: xx.gitlab.cn/a/b/c&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--mod&#x27;</span>, default=<span class="string">&quot;./go.mod&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;go.mod path&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replace_repo</span>(<span class="params">repo_list, mod_json, mod_path</span>):</span><br><span class="line">    <span class="keyword">if</span> mod_json[<span class="string">&#x27;Replace&#x27;</span>]:</span><br><span class="line">        mod_replace_list = [ i[<span class="string">&#x27;Old&#x27;</span>][<span class="string">&#x27;Path&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> mod_json[<span class="string">&#x27;Replace&#x27;</span>]]</span><br><span class="line">        repo_list = [repo <span class="keyword">for</span> repo <span class="keyword">in</span> repo_list <span class="keyword">if</span> repo <span class="keyword">not</span> <span class="keyword">in</span> mod_replace_list]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(repo_list) == <span class="number">0</span>:</span><br><span class="line">            logging.info(<span class="string">&quot;已经全部替换&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    replace_list = [ i <span class="keyword">for</span> i <span class="keyword">in</span> mod_json[<span class="string">&#x27;Require&#x27;</span>] <span class="keyword">if</span> i[<span class="string">&#x27;Path&#x27;</span>] <span class="keyword">in</span> repo_list <span class="keyword">and</span> (<span class="keyword">not</span> i.get(<span class="string">&#x27;Indirect&#x27;</span>, <span class="literal">False</span>))]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(replace_list) == <span class="number">0</span>:</span><br><span class="line">        logging.error(<span class="string">&quot;未找到需要替换的仓库: %s&quot;</span>, <span class="string">&#x27;,&#x27;</span>.join(repo_list))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(mod_path, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> replace_list:</span><br><span class="line">            replace_str = <span class="string">&quot;replace &#123;0&#125; =&gt; &#123;0&#125;.git &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(item[<span class="string">&#x27;Path&#x27;</span>], item[<span class="string">&#x27;Version&#x27;</span>])</span><br><span class="line">            logging.info(<span class="string">&quot;添加 %s&quot;</span>, replace_str)</span><br><span class="line">            f.writelines(replace_str+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">    args = parse_args()</span><br><span class="line">    <span class="keyword">if</span> args.repo <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(args.repo) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    mod_json = &#123;&#125;</span><br><span class="line">    mod_json_path = <span class="string">&quot;go.mod.json&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.isatty(<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(mod_json_path):</span><br><span class="line">            logging.error(<span class="string">&quot;请以 go mod edit -json | python3 %s 运行&quot;</span>, __file__)</span><br><span class="line">            os._exit(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(mod_json_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            mod_json = json.load(file)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mod_json = json.loads(sys.stdin.read())</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">isinstance</span>(mod_json, <span class="built_in">dict</span>)) <span class="keyword">or</span> mod_json.get(<span class="string">&quot;Module&quot;</span>, <span class="string">&quot;&quot;</span>) == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        logging.error(<span class="string">&quot;请以 go mod edit -json | python3 %s 运行&quot;</span>, __file__)</span><br><span class="line">        os._exit(<span class="number">2</span>)</span><br><span class="line">    replace_repo(args.repo, mod_json, args.mod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近给同事解决的 subgroup 问题…..&lt;/p&gt;</summary>
    
    
    
    
    <category term="golang" scheme="http://zhangguanzhang.github.io/tags/golang/"/>
    
    <category term="gitlab" scheme="http://zhangguanzhang.github.io/tags/gitlab/"/>
    
    <category term="subgroup" scheme="http://zhangguanzhang.github.io/tags/subgroup/"/>
    
  </entry>
  
  <entry>
    <title>小白向的 kubernetes 证书讲解</title>
    <link href="http://zhangguanzhang.github.io/2025/06/02/kubernetes-cert/"/>
    <id>http://zhangguanzhang.github.io/2025/06/02/kubernetes-cert/</id>
    <published>2025-06-02T20:40:30.000Z</published>
    <updated>2025-06-02T20:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近同事遇到几起证书相关问题，从小白角度来写下 k8s 证书…..</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>很多人对  k8s 证书和 kubeconfig 望而却步，证书过期和相关报错就无从下手，市面上有写证书的文章博客，但是感觉很长的理论会让很多人看不下去，实际更需要的是解决问题时候的具体步骤和方向。</p><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><p>简单讲解证书理论部分。</p><h3 id="双向-SSL"><a href="#双向-SSL" class="headerlink" title="双向 SSL"></a>双向 SSL</h3><p>访问一个 https 网站，需要目标 web server 配置有 ssl 证书，而证书来源两种：</p><ol><li>CA（证书颁发机构）使用私钥签署出 根 CA 证书（公钥），浏览器和操作系统内置这些 根 CA 证书， 只有 CA 机构签署的证书才会是绿锁。</li><li>使用证书工具或者遵守证书规范的库生成的 CA 私钥自己签署出的证书，浏览器显示红色警告（连接不安全&#x2F;无效证书）</li></ol><p>k8s 采用的是基于 X.509 V3 标准的双向 SSL，客户端和服务端通信，都会验证双方证书，根据双方是否是一样的 CA 签署的证书，而 CA 私钥是自己生成的，你可以看到 k8s 组件的 cmdline 都有指定参数 <code>ca-file|cert-file</code> 相关。</p><h3 id="证书建议相关"><a href="#证书建议相关" class="headerlink" title="证书建议相关"></a>证书建议相关</h3><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>无论是 openssl 还是 cfssl，推荐都把过期时间设置高一些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -x509 ... -days 10000</span><br><span class="line">$ cat ca-config.json</span><br><span class="line">...</span><br><span class="line">  &quot;expiry&quot;: &quot;876000h&quot;</span><br></pre></td></tr></table></figure><p>而对于 kubeadm，网上有修改编译的，或者 go build 的时候注入覆盖默认的时间的，自行搜索。</p><h4 id="certSAN"><a href="#certSAN" class="headerlink" title="certSAN"></a>certSAN</h4><p>k8s 里 <code>kube-apiserver</code> 和 <code>etcd</code> 都是部署在多个机器上实现高可用的，在 <code>openssl/cfssl/kubeadm</code> 里推荐加 IP 以外还要加域名以防后续换 IP 相关：</p><ul><li>openssl 配置文件参考 <a href="https://github.com/kubernetes-sigs/kubespray/blob/master/roles/etcd/templates/openssl.conf.j2">kubernetes-sigs&#x2F;kubespray 的 openssl.conf</a></li><li>cfssl 使用的 json 文件里的 <code>hosts</code> 字段</li><li>kubeadm 的 <code>certSANs</code> 字段</li></ul><p>这里以 ipv4 下 kubeadm 的指定 yml 创建集群来举例一般写那些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ cat initconfig.yaml</span><br><span class="line">apiServer:</span><br><span class="line">  certSANs:</span><br><span class="line">  - 10.96.0.1 # service cidr的第一个ip</span><br><span class="line">  - 127.0.0.1 # 多个master的时候负载均衡出问题了能够快速使用localhost调试</span><br><span class="line">  - localhost</span><br><span class="line">  - apiserver.k8s.local # 负载均衡的域名或者vip</span><br><span class="line">  - 172.19.0.2 # 三台 kube-apiserver 的 IP</span><br><span class="line">  - 172.19.0.3</span><br><span class="line">  - 172.19.0.4</span><br><span class="line">  - apiserver01.k8s.local </span><br><span class="line">  - apiserver02.k8s.local</span><br><span class="line">  - apiserver03.k8s.local</span><br><span class="line">  - apiserver04.k8s.local # 预留域名</span><br><span class="line">  - apiserver05.k8s.local</span><br><span class="line">  - master</span><br><span class="line">  - kubernetes</span><br><span class="line">  - kubernetes.default</span><br><span class="line">  - kubernetes.default.svc</span><br><span class="line">  - kubernetes.default.svc.cluster.local # 集群内 dns search 和 clusterDomain</span><br><span class="line">...</span><br><span class="line">etcd: # https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2#Etcd</span><br><span class="line">  local:</span><br><span class="line">    serverCertSANs:</span><br><span class="line">    - localhost</span><br><span class="line">    - 127.0.0.1</span><br><span class="line">    - 172.19.0.2</span><br><span class="line">    - 172.19.0.3</span><br><span class="line">    - 172.19.0.4</span><br><span class="line">    - etcd01.k8s.local</span><br><span class="line">    - etcd02.k8s.local</span><br><span class="line">    - etcd03.k8s.local</span><br><span class="line">    - etcd04.k8s.local # 预留域名</span><br><span class="line">    - etcd05.k8s.local</span><br><span class="line">    peerCertSANs:</span><br><span class="line">    - localhost</span><br><span class="line">    - 127.0.0.1</span><br><span class="line">    - 172.19.0.2</span><br><span class="line">    - 172.19.0.3</span><br><span class="line">    - 172.19.0.4</span><br><span class="line">    - etcd01.k8s.local</span><br><span class="line">    - etcd02.k8s.local</span><br><span class="line">    - etcd03.k8s.local</span><br><span class="line">    - etcd04.k8s.local # 预留域名</span><br><span class="line">    - etcd05.k8s.local</span><br></pre></td></tr></table></figure><p>上面只列举 IPv4 的，如果后续有双栈啥的可以预先写上，如果写漏了域名和 IP，管理组件或者 pod 内通过 SDK 访问 kube-apiserver 的时候会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to connect to the server: tls: failed to verify certificate: x509: certificate is valid for 10.96.0.1, yyyy, not xxxx</span><br></pre></td></tr></table></figure><p>也就是证书的 certSANs 只有 <code>10.96.0.1, yyyy</code> 而没有 <code>xxxx</code>，可以使用原有 CA 证书签署下。命令行查看证书的 certSAN 可以使用 openssl ，编程语言的话推荐去使用库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一般会把证书放在 /etc/kubernetes/pki 找不到的找 apiserver cmdline 参数路径</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl x509 -noout -text -<span class="keyword">in</span> apiserver.crt</span></span><br><span class="line">X509v3 Subject Alternative Name:</span><br><span class="line">                DNS:localhost, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, IP Address:10.96.0.1, IP Address: 172.19.0.2</span><br></pre></td></tr></table></figure><p>openssl 上面的输出里很多信息，还包含证书过期时间，而且 openssl x509 下很多选项的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用 -certopt 和 -text 配合只打印 certSANs</span></span><br><span class="line">openssl x509 -noout  -in apiserver.crt  -certopt no_subject,no_header,no_version,no_serial,no_signame,no_validity,no_issuer,no_pubkey,no_sigdump,no_aux -text</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只查看证书时间</span></span><br><span class="line">openssl x509 -noout  -in apiserver.crt -dates</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只展示 subject</span></span><br><span class="line">openssl x509 -noout  -in apiserver.crt  -subject</span><br></pre></td></tr></table></figure><p>只有同一套 ca 签署证书才符合要求，可以使用 openssl 命令检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 apiserver.crt 是否是由 ca.key 签署</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl verify -CAfile ca.crt apiserver.crt</span></span><br><span class="line">apiserver.crt: OK</span><br></pre></td></tr></table></figure><h3 id="k8s-role-和-RBAC"><a href="#k8s-role-和-RBAC" class="headerlink" title="k8s role 和 RBAC"></a>k8s role 和 RBAC</h3><p>双向 TLS 过去了，但是具体权限控制 k8s 怎么做的呢，就是 X.509 证书签署（Subject 字段内）的 <code>CN(Common Name)</code> 与 <code>O(Organization)</code> 字段，对应 <code>User Name</code> 和 <code>Group</code>，也就是 k8s 的 RBAC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get clusterrolebinding</span><br><span class="line">NAME                                                   ROLE                                                                               AGE</span><br><span class="line">cluster-admin                                          ClusterRole/cluster-admin                                                          81m</span><br><span class="line">kubeadm:get-nodes                                      ClusterRole/kubeadm:get-nodes                                                      81m</span><br><span class="line">kubeadm:kubelet-bootstrap                              ClusterRole/system:node-bootstrapper                                               81m</span><br><span class="line">kubeadm:node-autoapprove-bootstrap                     ClusterRole/system:certificates.k8s.io:certificatesigningrequests:nodeclient       81m</span><br><span class="line">kubeadm:node-autoapprove-certificate-rotation          ClusterRole/system:certificates.k8s.io:certificatesigningrequests:selfnodeclient   81m</span><br><span class="line">kubeadm:node-proxier                                   ClusterRole/system:node-proxier                                                    81m</span><br><span class="line">...</span><br><span class="line">system:coredns                                         ClusterRole/system:coredns                                                         81m</span><br><span class="line">system:discovery                                       ClusterRole/system:discovery                                                       81m</span><br><span class="line">system:kube-controller-manager                         ClusterRole/system:kube-controller-manager                                         81m</span><br><span class="line">system:kube-dns                                        ClusterRole/system:kube-dns                                                        81m</span><br><span class="line">system:kube-scheduler                                  ClusterRole/system:kube-scheduler                                                  81m</span><br><span class="line">system:monitoring                                      ClusterRole/system:monitoring                                                      81m</span><br><span class="line">system:node                                            ClusterRole/system:node                                                            81m</span><br><span class="line">system:node-proxier                                    ClusterRole/system:node-proxier                                                    81m</span><br><span class="line">system:public-info-viewer                              ClusterRole/system:public-info-viewer                                              81m</span><br><span class="line">system:service-account-issuer-discovery                ClusterRole/system:service-account-issuer-discovery                                81m</span><br><span class="line">system:volume-scheduler                                ClusterRole/system:volume-scheduler                                                81m</span><br></pre></td></tr></table></figure><p>kube-apiserver 启动后会创建上面的 <code>clusterrolebinding</code>，kubectl 本质就是个 client + kubeconfig 访问 <code>kube-apiserver</code> 的，查看 kubectl 当前使用的 <code>kubeconfig</code> 可以通过 k8s 所有二进制的 cmdline 的 <code>-v</code> 选项，从详细信息里获取：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl config view -v=6</span></span><br><span class="line">I0604 10:40:46.836786   14513 loader.go:395] Config loaded from file:  /root/.kube/config</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以从上面看到是 <code>/root/.kube/config</code> ，以 kubeadm 的举例，该文件内容内有证书内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /root/.kube/config</span><br><span class="line">certificate-authority-data  /etc/kubernetes/pki/ca.crt 内容 base64 加密后的值</span><br><span class="line">client-certificate-data     /etc/kubernetes/pki/admin.crt 内容 base64 加密后的值</span><br><span class="line">client-key-data             /etc/kubernetes/pki/admin.key 内容 base64 加密后的值</span><br></pre></td></tr></table></figure><p>上面后面俩已经内嵌了，所以文件不存在，但是也会有些人自建集群上面的后面值是路径，是因为 kubectl config 生成 kubeconfig 的时候没指定选项 <code>--embed-certs</code>，内嵌的步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl --kubeconfig /etc/kubernetes/admin.conf config set-credentials admin \</span><br><span class="line">        --client-certificate=/etc/kubernetes/pki/admin.crt \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --client-key=/etc/kubernetes/pki/admin.key&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span> -f /etc/kubernetes/pki/admin.???</span></span><br></pre></td></tr></table></figure><p>kubeadm golang 直接没有落地文件，直接生成 yml 内容的，我们可以扣出证书信息看看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl x509 -<span class="keyword">in</span> &lt;(kubectl config view --raw -o jsonpath=<span class="string">&quot;&#123;.users[0][&#x27;user&#x27;][&#x27;client-certificate-data&#x27;]&#125;&quot;</span> | <span class="built_in">base64</span> -d ) -noout -text</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl x509 -<span class="keyword">in</span> &lt;(kubectl config view --raw -o jsonpath=<span class="string">&quot;&#123;.users[0][&#x27;user&#x27;][&#x27;client-certificate-data&#x27;]&#125;&quot;</span> | <span class="built_in">base64</span> -d ) -noout  -subject</span></span><br><span class="line">subject= /O=system:masters/CN=kubernetes-admin</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>O=system:masters</code> ，实际对应 <code>clusterrolebinding cluster-admin</code> 的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get clusterrolebinding cluster-admin -o yaml</span></span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span><br><span class="line">  creationTimestamp: &quot;2025-06-03T07:36:44Z&quot;</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/bootstrapping: rbac-defaults</span><br><span class="line">  name: cluster-admin</span><br><span class="line">  resourceVersion: &quot;160&quot;</span><br><span class="line">  uid: d5638680-38de-4010-a2c9-084645a8ad21</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: Group</span><br><span class="line">  name: system:masters</span><br></pre></td></tr></table></figure><p>也就是组 <code>system:masters</code> 具备 clusterrole <code>cluster-admin</code> 的权限。</p><p>本小结参考：</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/">使用 RBAC 鉴权</a></li><li><a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/implementation-details/">kubeadm 实现细节</a></li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>说完理论部分，来实战下，利用证书的 <code>CN(Common Name)</code> 与 <code>O(Organization)</code> 字段来创建两个权限证书测试下：</p><ul><li>用户 test1 具备 default ns 下的 pod list 权限</li><li>组 test2 具备所有 ns 的 pod list 权限</li></ul><p>避免路径、证书名字和后缀和习惯问题，实战部分以 cfssl 在 kubeadm 初始化后的文件目录内操作。</p><p>对证书做操作之前要有备份习惯，无论证书损坏还是过期：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kubernetes</span><br><span class="line">cp -a pki pki.bak</span><br></pre></td></tr></table></figure><h3 id="创建证书"><a href="#创建证书" class="headerlink" title="创建证书"></a>创建证书</h3><p>创建配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kubernetes/pki/</span><br><span class="line"></span><br><span class="line"># 创建 ca 签署证书签名配置文件，因为该证书是只 client 使用，不需要在 usages 里带 &quot;server auth&quot;</span><br><span class="line"># 如果所有证书手动生成时候用同一个 ca-config.json 可以偷懒带上 &quot;server auth&quot;</span><br><span class="line"></span><br><span class="line">cat &gt; ca-config.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;expiry&quot;: &quot;876000h&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;profiles&quot;: &#123;</span><br><span class="line">      &quot;kubernetes&quot;: &#123;</span><br><span class="line">        &quot;usages&quot;: [</span><br><span class="line">            &quot;signing&quot;,</span><br><span class="line">            &quot;key encipherment&quot;,</span><br><span class="line">            &quot;client auth&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;expiry&quot;: &quot;876000h&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># cn 对应 user o 对应 group</span><br><span class="line">cat &gt; test1-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;test1&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;O&quot;: &quot;test1&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>签署证书：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert \</span><br><span class="line">        -ca=ca.crt \</span><br><span class="line">        -ca-key=ca.key \</span><br><span class="line">        -config=ca-config.json \</span><br><span class="line">        -profile=kubernetes test1-csr.json | cfssljson -bare test1</span><br></pre></td></tr></table></figure><p>测试证书权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">避免 kubeconfig 干扰，改名下家目录文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> ~/.kube/config ~/.kube/config.bak</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">KUBECONFIG= kubectl --server=https://xxx:6443 \</span></span><br><span class="line"><span class="language-bash">  --certificate-authority=/etc/kubernetes/pki/ca.crt \</span></span><br><span class="line"><span class="language-bash">  --client-certificate=/etc/kubernetes/pki/test1.pem \</span></span><br><span class="line"><span class="language-bash">  --client-key=/etc/kubernetes/pki/test1-key.pem get pod</span></span><br><span class="line">Error from server (Forbidden): pods is forbidden: User &quot;test1&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;default&quot;</span><br></pre></td></tr></table></figure><p>kube-apiserver 本质是 http&#x2F;grpc server，我们也可以 curl 测下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -X GET \</span></span><br><span class="line"><span class="language-bash">  --cacert /etc/kubernetes/pki/ca.crt \</span></span><br><span class="line"><span class="language-bash">  --cert /etc/kubernetes/pki/test1.pem \</span></span><br><span class="line"><span class="language-bash">  --key /etc/kubernetes/pki/test1-key.pem \</span></span><br><span class="line"><span class="language-bash">  -H <span class="string">&quot;Accept: application/json&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  <span class="string">&quot;https://xxx:6443/api/v1/namespaces/default/pods?limit=500&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;&#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;pods is forbidden: User \&quot;test1\&quot; cannot list resource \&quot;pods\&quot; in API group \&quot;\&quot; in the namespace \&quot;default\&quot;&quot;,</span><br><span class="line">  &quot;reason&quot;: &quot;Forbidden&quot;,</span><br><span class="line">  &quot;details&quot;: &#123;</span><br><span class="line">    &quot;kind&quot;: &quot;pods&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;code&quot;: 403</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们没有创建 <code>test1</code> 的 <code>RBAC</code> ，也就是 <code>rolebinding</code>，创建下后再试试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> ~/.kube/config.bak ~/.kube/config</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt; test1-rbac.yml &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  name: test1-role</span><br><span class="line">  namespace: default</span><br><span class="line">rules:</span><br><span class="line">- apiGroups:</span><br><span class="line">  - &quot;&quot;</span><br><span class="line">  resources:</span><br><span class="line">  - pods</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">  - list</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: test1-rolebinding</span><br><span class="line">  namespace: default</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: Role</span><br><span class="line">  name: test1-role</span><br><span class="line">subjects:</span><br><span class="line">- apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: User</span><br><span class="line">  name: test1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">kubectl apply -f test1-rbac.yml</span></span></span><br></pre></td></tr></table></figure><p>然后再测试，可以列出 default 下的 pod 而不能列出 svc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> ~/.kube/config ~/.kube/config.bak</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">KUBECONFIG= kubectl --server=https://xxx:6443 \</span></span><br><span class="line"><span class="language-bash">  --certificate-authority=/etc/kubernetes/pki/ca.crt \</span></span><br><span class="line"><span class="language-bash">  --client-certificate=/etc/kubernetes/pki/test1.pem \</span></span><br><span class="line"><span class="language-bash">  --client-key=/etc/kubernetes/pki/test1-key.pem get pod</span></span><br><span class="line">No resources found in default namespace.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">KUBECONFIG= kubectl --server=https://xxx:6443   --certificate-authority=/etc/kubernetes/pki/ca.crt   --client-certificate=/etc/kubernetes/pki/test1.pem   --client-key=/etc/kubernetes/pki/test1-key.pem get svc</span></span><br><span class="line">Error from server (Forbidden): services is forbidden: User &quot;test1&quot; cannot list resource &quot;services&quot; in API group &quot;&quot; in the namespace &quot;default&quot;</span><br></pre></td></tr></table></figure><p>同样使用 curl 测下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -X GET  \</span></span><br><span class="line"><span class="language-bash">  --cacert /etc/kubernetes/pki/ca.crt  \</span></span><br><span class="line"><span class="language-bash">  --cert /etc/kubernetes/pki/test1.pem  \</span></span><br><span class="line"><span class="language-bash">  --key /etc/kubernetes/pki/test1-key.pem  \</span></span><br><span class="line"><span class="language-bash">   -H <span class="string">&quot;Accept: application/json&quot;</span>   <span class="string">&quot;https://10.xxx.xx.xxx:6443/api/v1/namespaces/default/pods?limit=500&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;PodList&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;resourceVersion&quot;: &quot;107116&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;items&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -X GET  \</span></span><br><span class="line"><span class="language-bash">  --cacert /etc/kubernetes/pki/ca.crt  \</span></span><br><span class="line"><span class="language-bash">  --cert /etc/kubernetes/pki/test1.pem  \</span></span><br><span class="line"><span class="language-bash">  --key /etc/kubernetes/pki/test1-key.pem  \</span></span><br><span class="line"><span class="language-bash">   -H <span class="string">&quot;Accept: application/json&quot;</span>   <span class="string">&quot;https://10.xxx.xx.xxx:6443/api/v1/namespaces/default/services?limit=500&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;&#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;services is forbidden: User \&quot;test1\&quot; cannot list resource \&quot;services\&quot; in API group \&quot;\&quot; in the namespace \&quot;default\&quot;&quot;,</span><br><span class="line">  &quot;reason&quot;: &quot;Forbidden&quot;,</span><br><span class="line">  &quot;details&quot;: &#123;</span><br><span class="line">    &quot;kind&quot;: &quot;services&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;code&quot;: 403</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到证书权限符合预期，kubeconfig 里可以包含多个配置段的，前面的证书生成 kubeconfig 可以使用 kubectl ，按照下面步骤生成对应配置段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置集群参数，指定CA证书和apiserver地址</span></span><br><span class="line">kubectl --kubeconfig=test1.kubeconfig config set-cluster kubernetes \</span><br><span class="line">    --certificate-authority=/etc/kubernetes/pki/ca.crt \</span><br><span class="line">    --embed-certs=true \</span><br><span class="line">    --server=https://xxx:6443</span><br><span class="line">        </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置客户端认证参数，指定使用证书和私钥</span></span><br><span class="line">kubectl --kubeconfig=test1.kubeconfig config set-credentials test1 \</span><br><span class="line">    --client-certificate=test1.pem \</span><br><span class="line">    --embed-certs=true \</span><br><span class="line">    --client-key=test1-key.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">追加一个名为 kubernetes 的上下文参数，指定它使用前面添加的 集群 kubernetes 和名为 test1 的凭据</span></span><br><span class="line">kubectl --kubeconfig=test1.kubeconfig config set-context kubernetes \</span><br><span class="line">    --cluster=kubernetes --user=test1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择默认的上下文</span></span><br><span class="line">kubectl --kubeconfig=test1.kubeconfig config use-context kubernetes</span><br></pre></td></tr></table></figure><p>然后使用该 kubeconfig 测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zgz pki]# kubectl --kubeconfig=test1.kubeconfig get pod</span><br><span class="line">No resources found in default namespace.</span><br><span class="line">[root@zgz pki]# kubectl --kubeconfig=test1.kubeconfig get svc</span><br><span class="line">Error from server (Forbidden): services is forbidden: User &quot;test1&quot; cannot list resource &quot;services&quot; in API group &quot;&quot; in the namespace &quot;default&quot;</span><br></pre></td></tr></table></figure><p>group test2 一样操作，就是注意 <code>O</code> 字段即可，然后是 <code>clusterrole</code> 和 <code>clusterrolebinding</code> ，自行挑战下。</p><h3 id="kube-apiserver-的-certSAN"><a href="#kube-apiserver-的-certSAN" class="headerlink" title="kube-apiserver 的 certSAN"></a>kube-apiserver 的 certSAN</h3><p>此部分解决 kube-apiserver 的证书（过期也可以按照如下步骤来），例如很多人 kubeadm 初始化后，certSAN 缺少 hosts 报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ echo &#x27;127.0.0.1 santest&#x27; &gt;&gt; /etc/hosts</span><br><span class="line">$ kubectl --server https://santest:6443 get pod</span><br><span class="line">...</span><br><span class="line">Unable to connect to the server: tls: </span><br><span class="line">    failed to verify certificate: x509: </span><br><span class="line">    certificate is valid for kubernetes, kubernetes.default, kubernetes.default.svc, kubernetes.default.svc.cluster.local, node, not santest</span><br></pre></td></tr></table></figure><p>这个时候可以用 ca 签署新证书来包含 santest ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kubernetes/pki/</span><br><span class="line"></span><br><span class="line"># 创建 ca 签署证书签名配置文件，因为该证书是只 server 使用，不需要在 usages 里带 &quot;client auth&quot;</span><br><span class="line"># 如果所有证书手动生成时候用同一个 ca-config.json 可以偷懒带上 &quot;client auth&quot;</span><br><span class="line"></span><br><span class="line">cat &gt; ca-config.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;expiry&quot;: &quot;876000h&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;profiles&quot;: &#123;</span><br><span class="line">      &quot;kubernetes&quot;: &#123;</span><br><span class="line">        &quot;usages&quot;: [</span><br><span class="line">            &quot;signing&quot;,</span><br><span class="line">            &quot;key encipherment&quot;,</span><br><span class="line">            &quot;server auth&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;expiry&quot;: &quot;876000h&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看现有 certSAN</span><br><span class="line">openssl x509 -noout  -in apiserver.crt  -certopt no_subject,no_header,no_version,no_serial,no_signame,no_validity,no_issuer,no_pubkey,no_sigdump,no_aux -text</span><br><span class="line"></span><br><span class="line"># 把上面老的和要添加的 写到文件里</span><br><span class="line">cat &gt; kubernetes-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kube-apiserver&quot;,</span><br><span class="line">  &quot;hosts&quot;: [</span><br><span class="line">    &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;::1&quot;,</span><br><span class="line">    &quot;localhost&quot;,</span><br><span class="line">    &quot;santest&quot;</span><br><span class="line">    &quot;10.xx&quot;,</span><br><span class="line">    &quot;10.96.0.1&quot;,</span><br><span class="line">    &quot;kubernetes&quot;,</span><br><span class="line">    &quot;kubernetes.default&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="line">    &quot;kubernetes.default.svc.cluster.local&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;Kubernetes&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 签署证书</span><br><span class="line"></span><br><span class="line">cfssl gencert \</span><br><span class="line">        -ca=ca.crt \</span><br><span class="line">        -ca-key=ca.key \</span><br><span class="line">        -config=ca-config.json \</span><br><span class="line">        -profile=kubernetes kubernetes-csr.json | cfssljson -bare apiserver2</span><br></pre></td></tr></table></figure><p>修改 kube-apiserver 的 cmdline 使用 <code>apiserver2.pem</code> 和 <code>apiserver2-key.pem</code> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /etc/kubernetes/manifests/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">&#x27;apiserver.(crt|key)&#x27;</span> /etc/kubernetes/manifests/kube-apiserver.yaml</span></span><br><span class="line">    - --tls-cert-file=/etc/kubernetes/pki/apiserver.crt</span><br><span class="line">    - --tls-private-key-file=/etc/kubernetes/pki/apiserver.key</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -ri -e <span class="string">&#x27;s#/apiserver.crt#/apiserver2.pem#&#x27;</span> -e <span class="string">&#x27;s#/apiserver.key#/apiserver2-key.pem#&#x27;</span> /etc/kubernetes/manifests/kube-apiserver.yaml</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E -- <span class="string">&#x27;--tls-(cert|private)&#x27;</span> /etc/kubernetes/manifests/kube-apiserver.yaml</span></span><br><span class="line">    - --tls-cert-file=/etc/kubernetes/pki/apiserver2.pem</span><br><span class="line">    - --tls-private-key-file=/etc/kubernetes/pki/apiserver2-key.pem</span><br></pre></td></tr></table></figure><p>然后用上面的 santest 域名测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl --server https://santest:6443 get pod</span><br><span class="line">No resources found in default namespace.</span><br><span class="line">$ kubectl --server https://santest:6443 get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   1h</span><br></pre></td></tr></table></figure><h2 id="故障案例"><a href="#故障案例" class="headerlink" title="故障案例"></a>故障案例</h2><h3 id="kubectl-证书过期"><a href="#kubectl-证书过期" class="headerlink" title="kubectl 证书过期"></a>kubectl 证书过期</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f /tmp/test-svc.yml</span></span><br><span class="line">... x509: certificate has exprired or is not yet valid: current time 2025-05-20T23:25:51+08:00 is after 2025-01-16T02:16:34Z</span><br></pre></td></tr></table></figure><p>查看 kubeconfig 内嵌的证书过期时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl x509 -<span class="keyword">in</span> &lt;(kubectl config view --raw -o jsonpath=<span class="string">&quot;&#123;.users[0][&#x27;user&#x27;][&#x27;client-certificate-data&#x27;]&#125;&quot;</span> | <span class="built_in">base64</span> -d ) -noout -enddate</span></span><br><span class="line">notAfter=Jan 16 02:16:34 2025 GMT</span><br></pre></td></tr></table></figure><p>而 <code>admin.pem</code> 看现场重新签署了下，时间没过期：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl x509 -<span class="keyword">in</span> admin.pem -noout -dates</span></span><br><span class="line">notBefore=Jan 17 03:05:00 2024 GMT</span><br><span class="line">notAfter=Dec 24 03:05:00 2123 GMT</span><br></pre></td></tr></table></figure><p>所以内嵌下证书生成新的 kubeconfig 即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们证书后缀和文件路径不一样，不要照抄，<span class="built_in">env</span> 和命令行指定生成的 kubeconfig 均一样</span></span><br><span class="line">cd /etc/kubernetes/cluster1/ssl</span><br><span class="line"></span><br><span class="line">KUBECONFIG=/etc/kubernetes/cluster1/.kube/config2 \</span><br><span class="line">        kubectl config set-cluster kubernetes \</span><br><span class="line">        --certificate-authority=ca.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --server=https://127.0.0.1:8443</span><br><span class="line">        </span><br><span class="line">KUBECONFIG=/etc/kubernetes/cluster1/.kube/config2 \</span><br><span class="line">        kubectl config set-credentials admin \</span><br><span class="line">        --client-certificate=admin.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --client-key=admin-key.pem</span><br><span class="line"></span><br><span class="line">KUBECONFIG=/etc/kubernetes/cluster1/.kube/config2 \</span><br><span class="line">        kubectl config set-context kubernetes \</span><br><span class="line">        --cluster=kubernetes --user=admin</span><br><span class="line"></span><br><span class="line">KUBECONFIG=/etc/kubernetes/cluster1/.kube/config2 \</span><br><span class="line">         kubectl config use-context kubernetes</span><br><span class="line"></span><br><span class="line">KUBECONFIG=/etc/kubernetes/cluster1/.kube/config2 kubectl get node</span><br></pre></td></tr></table></figure><h3 id="deploy-的-rs-创建报错过期"><a href="#deploy-的-rs-创建报错过期" class="headerlink" title="deploy 的 rs 创建报错过期"></a>deploy 的 rs 创建报错过期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n default describe deploy deployment-example</span><br><span class="line">Name:                   deployment-example</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Fri, 30 May 2025 15:45:03 +0800</span><br><span class="line">Labels:                 &lt;none&gt;</span><br><span class="line">Annotations:            &lt;none&gt;</span><br><span class="line">Selector:               app=nginx</span><br><span class="line">Replicas:               2 desired | 0 updated | 0 total | 0 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:1.19-alpine</span><br><span class="line">    Port:         12343/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Progressing    False   ReplicaSetCreateError</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   &lt;none&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason                 Age                From                   Message</span><br><span class="line">  ----     ------                 ----               ----                   -------</span><br><span class="line">  Warning  ReplicaSetCreateError  21s (x7 over 21s)  deployment-controller  Failed to create new replica set &quot;deployment-example-b4f6c7989&quot;: Get &quot;https://[::1]:6443/api/v1/namespaces/default/resourcequotas&quot;: x509: certificate has expired or is not yet valid: current time 2025-05-30T22:06:13+08:00 is after 2024-08-28T14:45:36Z</span><br><span class="line">  Warning  ReplicaSetCreateError  20s (x2 over 20s)  deployment-controller  Failed to create new replica set &quot;deployment-example-b4f6c7989&quot;: Get &quot;https://[::1]:6443/api/v1/namespaces/default/resourcequotas&quot;: x509: certificate has expired or is not yet valid: current time 2025-05-30T22:06:14+08:00 is after 2024-08-28T14:45:36Z</span><br><span class="line">  Warning  ReplicaSetCreateError  18s                deployment-controller  Failed to create new replica set &quot;deployment-example-b4f6c7989&quot;: Get &quot;https://[::1]:6443/api/v1/namespaces/default/resourcequotas&quot;: x509: certificate has expired or is not yet valid: current time 2025-05-30T22:06:16+08:00 is after 2024-08-28T14:45:36Z</span><br><span class="line">  Warning  ReplicaSetCreateError  16s                deployment-controller  Failed to create new replica set &quot;deployment-example-b4f6c7989&quot;: Get &quot;https://[::1]:6443/api/v1/namespaces/default/resourcequotas&quot;: x509: certificate has expired or is not yet valid: current time 2025-05-30T22:06:18+08:00 is after 2024-08-28T14:45:36Z</span><br><span class="line">  Warning  ReplicaSetCreateError  11s                deployment-controller  Failed to create new replica set &quot;deployment-example-b4f6c7989&quot;: Get &quot;https://[::1]:6443/api/v1/namespaces/default/resourcequotas&quot;: x509: certificate has expired or is not yet valid: current time 2025-05-30T22:06:23+08:00 is after 2024-08-28T14:45:36Z</span><br><span class="line">  Warning  ReplicaSetCreateError  0s                 deployment-controller  Failed to create new replica set &quot;deployment-example-b4f6c7989&quot;: Get &quot;https://[::1]:6443/api/v1/namespaces/default/resourcequotas&quot;: x509: certificate has expired or is not yet valid: current time 2025-05-30T22:06:34+08:00 is after 2024-08-28T14:45:36Z</span><br></pre></td></tr></table></figure><p>这套环境是二进制部署，ReplicaSet 是 <code>kube-controller-manager</code> 创建的，该报错需要看 kube-controller-manager 日志，然后 k8s 的管理组件是通过 lease 对象保证只有一个真正处理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl -n kube-system get lease</span></span><br><span class="line">NAME                      HOLDER                                                                     AGE</span><br><span class="line">kube-controller-manager   ubuntu-Standard-PC-i440FX-PIIX-1996_296a57fb-a219-4301-a0a6-62c3cd09e0f2   639d</span><br><span class="line">kube-scheduler            ubuntu-Standard-PC-i440FX-PIIX-1996_edd2caff-d647-4633-8bd5-2d9788986e1f   639d</span><br></pre></td></tr></table></figure><p>holder 的名字生成规则如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/kubernetes/kubernetes/blob/v1.29.5/cmd/kube-controller-manager/app/controllermanager.go#L256-L286</span></span><br><span class="line">id, err := os.Hostname()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add a uniquifier so that two processes on the same host don&#x27;t accidentally both become active</span></span><br><span class="line">id = id + <span class="string">&quot;_&quot;</span> + <span class="type">string</span>(uuid.NewUUID())</span><br></pre></td></tr></table></figure><p>发现每台机器的 hostname 一样的，完全不知道当前持有 lease 的 <code>kube-controller-manager</code> 是哪台，算了，每个去看日志吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -xe --no-pager -u kube-controller-manager.service</span> </span><br><span class="line">-- Logs begin at Fri 2025-05-09 14:24:19 CST, end at Fri 2025-05-30 22:21:03 CST. --</span><br><span class="line">May 22 00:01:48 ubuntu-Standard-PC-i440FX-PIIX-1996 kube-controller-manager[53418]: E0522 00:01:48.204891   53418 leaderelection.go:325] error retrieving resource lock kube-system/kube-controller-manager: etcdserver: leader changed</span><br><span class="line"></span><br><span class="line">May 30 22:08:57 ubuntu-Standard-PC-i440FX-PIIX-1996 kube-controller-manager[22314]: E0530 22:08:57.593721   22314 deployment_controller.go:495] Get &quot;https://[::1]:6443/api/v1/namespaces/default/resourcequotas&quot;: x509: certificate has expired or is not yet valid: current time 2025-05-30T22:08:57+08:00 is after 2024-08-28T14:45:36Z</span><br><span class="line">May 30 22:08:57 ubuntu-Standard-PC-i440FX-PIIX-1996 kube-controller-manager[22314]: I0530 22:08:57.593752   22314 deployment_controller.go:496] Dropping deployment &quot;default/deployment-example&quot; out of the queue: Get &quot;https://[::1]:6443/api/v1/namespaces/default/resourcequotas&quot;: x509: certificate has expired or is not yet valid: current time 2025-05-30T22:08:57+08:00 is after 2024-08-28T14:45:36Z</span><br><span class="line">May 30 22:08:57 ubuntu-Standard-PC-i440FX-PIIX-1996 kube-controller-manager[22314]: I0530 22:08:57.593824   22314 event.go:291] &quot;Event occurred&quot; object=&quot;default/deployment-example&quot; kind=&quot;Deployment&quot; apiVersion=&quot;apps/v1&quot; type=&quot;Warning&quot; reason=&quot;ReplicaSetCreateError&quot; message=&quot;Failed to create new replica set \&quot;deployment-example-b4f6c7989\&quot;: Get \&quot;https://[::1]:6443/api/v1/namespaces/default/resourcequotas\&quot;: x509: certificate has expired or is not yet valid: current time 2025-05-30T22:08:57+08:00 is after 2024-08-28T14:45:36Z&quot;</span><br></pre></td></tr></table></figure><p>从 cmdline 获取 kubeconfig 路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">cat</span> kube-controller-manager.service</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/systemd/system/kube-controller-manager.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Controller Manager</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/data/kube/bin/kube-controller-manager \</span><br><span class="line">  --address=127.0.0.1 \</span><br><span class="line">  --kubeconfig=/etc/kubernetes/cluster1/ssl/kube-controller-manager.kubeconfig \</span><br><span class="line">...</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>查看下时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl --kubeconfig  /etc/kubernetes/cluster1/ssl/kube-controller-manager.kubeconfig \</span></span><br><span class="line"><span class="language-bash">config view --raw -o jsonpath=<span class="string">&quot;&#123;.users[0][&#x27;user&#x27;][&#x27;client-certificate-data&#x27;]&#125;&quot;</span> | <span class="built_in">base64</span> -d &gt; test.pem</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl x509 -<span class="keyword">in</span> test.pem -noout -enddate</span></span><br><span class="line">notAfter=Aug  5 15:37:00 2123 GMT</span><br></pre></td></tr></table></figure><p>时间没问题，然后看了下每个 kube-controller-manager 都没问题，轮流间隔重启了下 <code>kube-controller-manager</code> 还是一样，然后重启了下 kube-apiserver 才好，感觉 kube-apiserver 缓存 bug。</p><h3 id="kubelet-轮转证书"><a href="#kubelet-轮转证书" class="headerlink" title="kubelet 轮转证书"></a>kubelet 轮转证书</h3><p>证书位于 <code>/var/lib/kubelet</code> ，有时候 kubelet 不会自动轮转，该目录内证书备份下后重启 kubelet 即可，以及推荐设置 kube-controller-manager 的轮转证书时间久些。</p><h2 id="一些其他的"><a href="#一些其他的" class="headerlink" title="一些其他的"></a>一些其他的</h2><p>不单单 k8s 证书， etcd 证书一样，k8s 访问 etcd 相关大同小异，上面实战部分如果理解能力不行，在关于 <code>ca-config.json</code> 的 usages 可以偷懒下面 client 和 server 都写上了，一个 ca 配置文件用于所有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;usages&quot;: [</span><br><span class="line">    &quot;signing&quot;,</span><br><span class="line">    &quot;key encipherment&quot;,</span><br><span class="line">    &quot;server auth&quot;,</span><br><span class="line">    &quot;client auth&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>任何关于证书报错的信息和日志仔细看，证书过期、 certSAN 不匹配和不是一套 ca 导致校验不通过等是不一样的事情，不要无脑找到啥证书文章博客就跟着瞎操作，证书操作前要备份已有证书，产生 kubeconfig 文件的时候，要使用 kubectl 指定新路径生成，不要动老的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近同事遇到几起证书相关问题，从小白角度来写下 k8s 证书…..&lt;/p&gt;</summary>
    
    
    
    
    <category term="ssl" scheme="http://zhangguanzhang.github.io/tags/ssl/"/>
    
    <category term="kubernetes" scheme="http://zhangguanzhang.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>开发一个让指定应用走代理的安卓 app 过程</title>
    <link href="http://zhangguanzhang.github.io/2025/04/27/android-tun2sock/"/>
    <id>http://zhangguanzhang.github.io/2025/04/27/android-tun2sock/</id>
    <published>2025-04-27T20:40:30.000Z</published>
    <updated>2025-04-27T20:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发一个让指定 app 走 http 代理的经过…..</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>想对网络做一些验证，初步想法是找下 golang socks5 代理 server 上对每个 conn 的字节流反序列化后做动作，然后发现如果设备多了的话，没有代理池基本源 IP 就是一个了，所以想着手机端上有没有非 root 下让指定 app 走代理的代理软件。</p><p>然后想起了 <code>v2rxxNG</code> 里可以指定 app 走代理，于是研究折腾了一番到学习 kotlin 和安卓 compose 自己开发安卓 app。</p><h2 id="底层探讨经过"><a href="#底层探讨经过" class="headerlink" title="底层探讨经过"></a>底层探讨经过</h2><p>先大致看了下 <code>v2rxxNG</code> 的代码，发现用的 <code>tun2socks</code> 技术，主要是 tun 接口，也就是 Linux 的 tun 技术。</p><h3 id="Tun"><a href="#Tun" class="headerlink" title="Tun"></a>Tun</h3><p>在 Linux 里一切皆文件，Tap&#x2F;Tun 是 Linux 提供的用户态封装报文的接口，Tap 是数据链路层二层，Tun 是网络 IP 层三层，Tun 一端连着内核的协议栈，另一端连着用户态的进程。使用流程是：</p><ol><li>程序使用现有或者创建的虚拟网卡（Tap&#x2F;Tun）</li><li>程序需要对收和发的报文进行处理（也就是读写 &#x2F;dev&#x2F;net&#x2F;tun 字符设备），程序的逻辑就像物理网卡的硬件功能一样</li></ol><p>详细流程见<a href="https://www.junmajinlong.com/virtual/network/all_about_tun_tap/">理解Linux虚拟网卡设备tun&#x2F;tap的一切</a>，不搞啥虚拟交换机，而是常规做软件代理隧道啥的一般都是使用 Tun。</p><p>例如 linux 机器使用 socks5 tun 模式代理：</p><ul><li>走路由或者 iptables fmark 匹配到发往 tun 网卡</li><li>Linux 协议栈会把 TCP&#x2F;IP 报文发到用户态程序的 socks5 client</li><li>client 程序解析 IP 层的数据，封装成 socks5 协议的包发出去</li><li>协议栈收到后发往物理网卡，物理网卡发出去</li><li>socks5 server 端收到报文，解析后，本机发往目标地址</li></ul><p>这样目标地址看到就是 socks5 server 的 IP 请求的自己了，和 socks5 无关，代理隧道啥的基本都是这样的工作原理。</p><p>更详细的图文见：</p><ul><li><a href="https://www.junmajinlong.com/virtual/network/data_flow_about_openvpn/">https://www.junmajinlong.com/virtual/network/data_flow_about_openvpn/</a></li><li><a href="https://www.zhaohuabing.com/post/2020-02-24-linux-taptun/">https://www.zhaohuabing.com/post/2020-02-24-linux-taptun/</a></li></ul><h3 id="安卓和-Tun"><a href="#安卓和-Tun" class="headerlink" title="安卓和 Tun"></a>安卓和 Tun</h3><p><a href="https://github.com/2dust/v2rayNG/blob/master/V2rayNG/app/src/main/java/com/v2ray/ang/service/V2RayVpnService.kt">v2rxxNG</a> 是把 <code>badvxn</code> 编译成二进制文件，放在 libs 下命名为 <code>libtun2socks.so</code>，这样 Android 在安装 app 的时候会自动给 <code>.so</code> 后缀的文件 <code>+rx</code> 执行权限，在没有 root 的情况下，应用程序是无法给一个文件增加 x 权限的，这也算是一个骚操作。</p><p>然后在安卓开发的时候，安卓提供了接口，需要继承 <a href="https://developer.android.com/reference/kotlin/android/net/VpnService">VxnService</a> ，在其类的内部使用 <code>Builder()</code> 创建 tun，只不过安卓上不再是 <code>/dev/net/tun</code> 而是文件描述符了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ParcelFileDescriptor tunDevice = new Builder()</span><br><span class="line">    .addAddress(VXN_ADDRESS, 32)</span><br><span class="line">    .addRoute(VXN_ROUTE, 0)</span><br><span class="line">    .addDnsServer(VXN_DNS)</span><br><span class="line">    .addAllowedApplication(&quot;com.google.android.tethering&quot;)</span><br><span class="line">    .addAllowedApplication(&quot;com.google.android.tethering2&quot;)</span><br><span class="line">    .establish();</span><br><span class="line"></span><br><span class="line">fd = tunDevice.getFd()</span><br></pre></td></tr></table></figure><p>然后 <code>libtun2socks</code> 使用这个 fd 运行，<code>badvxn</code> 是基于 <code>LwIP</code> 修改的实现，c 语言基本都忘光了，找了下 golang 的实现看看，找到了 <code>https://github.com/xjasonlyu/tun2socks</code> ，为啥选它是应为它内置了好几个模式，例如 direct ，修改起来应该比较简单（这里我不去追求性能极限，以需求优先而选型）。</p><h2 id="安卓开发"><a href="#安卓开发" class="headerlink" title="安卓开发"></a>安卓开发</h2><p>搜了下相关没有搜到现有的轮子，唯一一个比较接近我需求的 <a href="https://github.com/ys1231/appproxy/tree/iyue">appproxy</a> 是 flutter 写的，并且代理类型只有 http 和 socks5，没办法，就去学习了下 kotlin 和安卓开发。</p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><p>2025年，搞这种稍微偏向底层的对接的，当然是学习 kotlin 搞安卓开发了，之前看到的 <a href="https://kotlin.liying-cn.net/home.html">kotlin 中文翻译文档</a> 看了下感觉从学习路线来看好琐碎，安卓官方开发文档页面又对 kotlin 介绍很少，都是课程里穿插着基础知识。完整体系的还是要从互联网上找下看看，下面的 gist 是收藏的一些，基本都看过的：</p><p><a href="https://gist.github.com/zhangguanzhang/cd2f3eb20de5a1314e5d3802401aa192">https://gist.github.com/zhangguanzhang/cd2f3eb20de5a1314e5d3802401aa192</a></p><p>先学 kotlin，再去看安卓官方的教程，安卓官方文档是实战带你入门安卓开发，相对于完整安卓开发体系来说还是缺少很多内容，例如 Service、Intent 和 Flow 啥的讲解很少或者基本没讲。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>主要需求为如下：</p><ul><li>添加、修改、删除代理配置</li><li>通知栏的前台运行通知</li><li>右下角的浮动开关</li><li>tun2socks 对接启动</li><li>app 选择界面选择哪些 app 走代理</li></ul><p>快速看完官方文档的 compose 开发后，基于 <a href="https://github.com/google-developer-training/basic-android-kotlin-compose-training-inventory-app">inventory-app</a> 复制修改开始，各个界面跳转用 navigate ，另外还发现 <a href="https://github.com/tailscale/tailscale-android/tree/main/android">tailscale-android</a> 也是全部用 kotlin + jetpack compose 开发的，可以从里面学下代码。</p><h3 id="tun2socks-aar"><a href="#tun2socks-aar" class="headerlink" title="tun2socks aar"></a>tun2socks aar</h3><p>根据文档 tun2socks 的 <a href="https://github.com/xjasonlyu/tun2socks/issues/123">How to use file descriptor in Android</a> 得知，集成到安卓是要利用 gomobile 编译出安卓的 aar 后代码里加载（而不是 <code>v2rxxNG</code> 那样运行二进制文件）。先编译出来后写个最小 demo 试试看，需要 NDK 和 SDK_TOOLS 和 golang，搜索了下后制作了一个带环境的 docker 镜像，直接下面步骤快速编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xjasonlyu/tun2socks</span><br><span class="line"><span class="built_in">cd</span> tun2socks</span><br><span class="line"><span class="comment"># 不要在低配置机器上编译，会卡死机器</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -ti \</span><br><span class="line"> -e GOPROXY=<span class="string">&#x27;https://goproxy.cn,https://mirrors.aliyun.com/goproxy/,https://goproxy.io,https://proxy.golang.com.cn,direct&#x27;</span> \</span><br><span class="line">  --entrypoint bash -v <span class="variable">$PWD</span>:/w -w /w registry.aliyuncs.com/zhangguanzhang/gomobile</span><br><span class="line">go get golang.org/x/mobile/bind</span><br><span class="line"><span class="built_in">mkdir</span> -p build</span><br><span class="line"><span class="comment">#  也可以使用一些go build 参数 这里我指定-androidapi 24最低兼容安卓7，默认值是16，但是较新的 NDK 上无法编译， 23.1.7779620 可以编译</span></span><br><span class="line">gomobile <span class="built_in">bind</span> -ldflags=<span class="string">&quot;-s -w&quot;</span> -trimpath -o build/tun2socks.aar \</span><br><span class="line">-target android \</span><br><span class="line">-androidapi 24 \</span><br><span class="line">github.com/xjasonlyu/tun2socks/v2/engine</span><br><span class="line">$ <span class="built_in">ls</span> -l build/</span><br><span class="line">total 30580</span><br><span class="line">-rw-r--r-- 1 root root 31304576 Apr 27 11:50 tun2socks.aar</span><br><span class="line">-rw-r--r-- 1 root root     6927 Apr 27 11:50 tun2socks-sources.jar</span><br></pre></td></tr></table></figure><p>issue 里基本都是 java 开发的，我这里是 kotlin 和最新版本的 <code>Android Studio</code>，最新的版本里，都是用 kotlin 的 DSL gradle 了，按照 issue 里的添加后在 <code>Android Studio</code> 里一直报红，然后搜索后下面的才行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># app 下的 buid.grade.kts 的 依赖下添加</span><br><span class="line">implementation(files(&quot;libs/tun2socks.aar&quot;))</span><br></pre></td></tr></table></figure><p>把上面的 aar 文件放 <code>app/libs/</code> 下即可，使用和 issue 里一样。</p><p>gomobile 一些实践参考:</p><ul><li><a href="https://mbox.dev/dev/go/go-mobile/03/">GoMobile 3: 在 iOS &amp; Android 上的集成</a></li><li><a href="https://apkdv.com/creating-android-ios-cross-platform-libraries-with-gomobile.html">使用 GoMobile 创建 Android、iOS 跨平台 WebSocket Library</a></li></ul><h3 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h3><p>官方的 demo <a href="https://android.googlesource.com/platform/development/+/master/samples/ToyVpn">Toy</a> 非常老，而且是 java 的，这里是我找的官方文档和一些参考代码：</p><ul><li><a href="https://developer.android.com/develop/background-work/services/fgs?hl=zh-cn">前台服务</a></li><li><a href="https://github.com/satishnada/android-vpn-implementation-guide/blob/master/app/src/main/java/com/satish/vpnguide/service/LocalVpnService.kt">android-vxn-implementation-guide</a></li><li><a href="https://github.com/microsoft/HydraLab/blob/main/android_client/app/src/main/java/com/microsoft/hydralab/android/client/vpn/HydraLabVpnService.kt">https://github.com/microsoft/HydraLab/blob/main/android_client/app/src/main/java/com/microsoft/hydralab/android/client/vpn/HydraLabVpnService.kt</a></li></ul><p>前台服务运行需要 <code>Notification</code> ，参考下别人代码后 <code>Android Studio</code> 模拟器里状态栏前台需要的通知出不来，在真机安卓 11 试了下没问题，发现模拟器的安卓版本太高了，谷歌了下需要加下面代码申请：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.TIRAMISU)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNotificationPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> permission = android.Manifest.permission.POST_NOTIFICATIONS</span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        ContextCompat.checkSelfPermission(</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            permission</span><br><span class="line">        ) == PackageManager.PERMISSION_GRANTED -&gt; &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shouldShowRequestPermissionRationale(permission) -&gt; &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            requestNotificationPermission.launch(permission)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> requestNotificationPermission =</span><br><span class="line">    registerForActivityResult(ActivityResultContracts.RequestPermission()) &#123; isGranted -&gt;</span><br><span class="line">        <span class="keyword">if</span> (isGranted) Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;通知权限已授予&quot;</span>, Toast.LENGTH_SHORT)</span><br><span class="line">            .show()</span><br><span class="line">        <span class="keyword">else</span> Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;通知权限被拒绝&quot;</span>, Toast.LENGTH_SHORT)</span><br><span class="line">            .show()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后启动代理闪退，发现没有像以前用的 app 那样弹窗口和钥匙，就是说该 app 申请 <code>vpn</code> 接口，会对啥啥的，需要调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VpnService.prepare(this)</span><br></pre></td></tr></table></figure><h3 id="一些其他细节问题"><a href="#一些其他细节问题" class="headerlink" title="一些其他细节问题"></a>一些其他细节问题</h3><p>启动后，切出去，再从通知栏进来，发现浮动按钮状态和实际不一致，最后还是按照 Binder 和 Service 通信才行，以及 <code>Broadcast</code> 让按钮状态和实际一致。<br>完整代码在 <a href="https://github.com/zhangguanzhang/appproxy">appproxy</a></p><p>打包发给其他人，发现安装不上，最后发现是签名问题，没签名安装不了，偷懒可以暂时 <code>Build -&gt; Generate App Bundles or APKs -&gt; Generate APKs</code> 弹出的点 locate 里。还可以分架构打非一体包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">splits &#123;</span><br><span class="line">    abi &#123;</span><br><span class="line">        isEnable = true</span><br><span class="line">        reset()</span><br><span class="line">        include(&quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;x86_64&quot;)</span><br><span class="line">        isUniversalApk = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>app 开发完成后，后续就是 fork tun2socks 复制 direct 后在 conn 对流解析和修改发送 ，当然可以天马行空下不要局限在代理层面，例如用户态 kotlin 直接对 fd 的流转发下只统计访问 ip，就可以做一个简单的网络访问统计了。</p><p>tun2socks 好多全局变量和 init 里做操作，这里记录下梳理的一些启动流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. main.go 里的 engine.Start()</span><br><span class="line">2. engine/engine.go 里的 start()</span><br><span class="line">3. engine/engine.go 里的 netstack() 内的 `tunnel.T().SetDialer(_defaultProxy)`</span><br><span class="line">4. 上面 import 了 tunnel 执行了 tunnel/global.go 内的 init() 的 T().ProcessAsync()</span><br><span class="line">5. go t.process(ctx)</span><br><span class="line">func (t *Tunnel) process(ctx context.Context) &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case conn := &lt;-t.tcpQueue:</span><br><span class="line">go t.handleTCPConn(conn)</span><br><span class="line">case conn := &lt;-t.udpQueue:</span><br><span class="line">go t.handleUDPConn(conn)</span><br><span class="line">case &lt;-ctx.Done():</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是 aar 引用，入口是 <code>engine/engine.go</code> 内的 <code>engine.Start()</code> 方法，对于日志，如果有打印到文件的需求的要在这个文件里修改，由于默认 <code>cwd</code> 是 <code>/</code> 会报错只读，推荐给 Key 添加 <code>Dir</code> 参数在 <code>engine/engine.go</code> 里：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">general</span><span class="params">(k *Key)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">level, err := log.ParseLevel(k.LogLevel)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filename := path.Join(_defaultKey.Dir, <span class="string">&quot;tun2socks.log&quot;</span>)</span><br><span class="line">cfg := zap.NewProductionConfig()</span><br><span class="line">cfg.OutputPaths = []<span class="type">string</span>&#123;filename&#125;</span><br><span class="line">cfg.Level.SetLevel(level)</span><br><span class="line">log.SetLogger(zap.Must(cfg.Build()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// log.SetLogger(log.Must(log.NewLeveled(level)))</span></span><br></pre></td></tr></table></figure><p>然后在 service 里给 <code>key.dir</code> 传递 <code>getExternalFilesDir(null)?.absolutePath</code>，也就是下面路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/storage/emulated/0/Android/data/&lt;package_name&gt;/files/</span><br></pre></td></tr></table></figure><p>这样 engine 日志就可以打印在上面目录内，另外对于 tcp 链接，核心就是这块代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span></span> handleTCPConn(originConn adapter.TCPConn) &#123;</span><br><span class="line"><span class="keyword">defer</span> originConn.Close()</span><br><span class="line"></span><br><span class="line">id := originConn.ID()</span><br><span class="line">metadata := &amp;M.Metadata&#123;</span><br><span class="line">Network: M.TCP,</span><br><span class="line">SrcIP:   parseTCPIPAddress(id.RemoteAddress),</span><br><span class="line">SrcPort: id.RemotePort,</span><br><span class="line">DstIP:   parseTCPIPAddress(id.LocalAddress),</span><br><span class="line">DstPort: id.LocalPort,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), tcpConnectTimeout)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">remoteConn, err := t.Dialer().DialContext(ctx, metadata)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warnf(<span class="string">&quot;[TCP] dial %s: %v&quot;</span>, metadata.DestinationAddress(), err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">metadata.MidIP, metadata.MidPort = parseNetAddr(remoteConn.LocalAddr())</span><br><span class="line"></span><br><span class="line">remoteConn = statistic.NewTCPTracker(remoteConn, metadata, t.manager)</span><br><span class="line"><span class="keyword">defer</span> remoteConn.Close()</span><br><span class="line"></span><br><span class="line">log.Infof(<span class="string">&quot;[TCP] %s &lt;-&gt; %s&quot;</span>, metadata.SourceAddress(), metadata.DestinationAddress())</span><br><span class="line">pipe(originConn, remoteConn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作流程如下，客户端发起连接到 tun2socks，然后 tun2socks <code>t.Dialer().DialContext(ctx, metadata)</code> 连接目标地址，然后 pipe 两个 conn</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 也可以去看看 core/tcp.go</span><br><span class="line">client ----originConn----&gt; tun2socks -----remoteConn----&gt; server</span><br></pre></td></tr></table></figure><p>如果需要 tun2socks 主动给 client 回包，需要把 remoteConn 传递过去，同时在 <code>t.Dialer().DialContext</code> 内产生的 <code>net.Conn</code> 的 <code>Read</code> 的 <code>[]byte</code> len 发现有点小，我自己维护了个 buf 做处理：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mirrorStream)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(p))</span><br><span class="line">n, err := m.rawConn.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(p, tmp[:n])</span><br><span class="line">m.buf = <span class="built_in">append</span>(m.buf, tmp[:n]...)</span><br><span class="line">m.mirrorMessages()</span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/qq_45649553/article/details/136543933">安卓基础-application详解</a></li><li><a href="https://github.com/xjasonlyu/tun2socks/discussions/139">tun2socks 自定义代理</a></li><li><a href="https://ivanfan.site/2022/01/05/Android/VPN%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/">代理加速</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近开发一个让指定 app 走 http 代理的经过…..&lt;/p&gt;</summary>
    
    
    
    
    <category term="android" scheme="http://zhangguanzhang.github.io/tags/android/"/>
    
    <category term="tun2sock2" scheme="http://zhangguanzhang.github.io/tags/tun2sock2/"/>
    
  </entry>
  
  <entry>
    <title>kube-log-runner 使用和适配 logrotate 改造</title>
    <link href="http://zhangguanzhang.github.io/2025/04/21/kube-log-runner/"/>
    <id>http://zhangguanzhang.github.io/2025/04/21/kube-log-runner/</id>
    <published>2025-04-21T10:40:30.000Z</published>
    <updated>2025-04-21T10:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用 kube-log-runner 的经历…..</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>kubelet 和一些 kube 组件在二进制 systemd service 管理下，日志最终会在 <code>/var/log/messages</code> 里，我们的客户对该文件会有关键字（Error、Failed …）监控，让我们把相关组件日志写到其他文件里去。</p><h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><h3 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h3><p>根据官方文档 <a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/system-logs/">系统日志</a> 得知 <code>v1.26</code> 开始移除了以前的日志文件、目录和轮转之类的参数，而是让使用 <code>kube-log-runner</code> 代替，该二进制已经内置在二进制下载压缩包里了。如果是使用镜像，官方的容器镜像内置了，只是名字叫做 <code>/go-runner</code>。</p><p>根据 <a href="https://github.com/kubernetes/component-base/tree/master/logs/kube-log-runner">github kube-log-runner</a> 得知使用方式和源码，它就是 golang 写的一个简单工具，启动命令，把命令的标准输出和错误输出捕获写到文件，然后转发信号给进程。</p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl cat --no-pager kube-apiserver</span><br><span class="line">...</span><br><span class="line">ExecStart=/usr/local/bin/kube-log-runner \</span><br><span class="line">  --log-file=/var/logs/kube-apiserver.log \</span><br><span class="line">  /usr/local/bin/kube-apiserver </span><br></pre></td></tr></table></figure><p>直接测试了下发现启动报错下面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4月 18 10:30:25 xxx systemd[1]: Got notification message from PID 9885, but reception only permitted for main PID 9880</span><br></pre></td></tr></table></figure><p>如果对 systemd 比较熟悉，可以直接看出问题。因为我们这边用的 <code>Type=notify</code>，该设置下，服务启动后会发送 <code>sd_notify</code> 给 systemd，这样 systemd 确认该服务正常启动。这个报错就是：</p><ol><li>systemd 拉起的主进程 Pid 是 9880</li><li>从非主进程的 9885 收到了 notification 消息</li></ol><p>解决该问题很简单，systemd 给了配置选项接收所有的 notify ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NotifyAccess=all</span><br></pre></td></tr></table></figure><h3 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h3><p>日志要写入到文件，那就一定要遵守 Linux 规范配置 logrotate 避免日志写满分区。然后相关配置完，写完配置用一个小的 size 参数测试了 logrotate 发现不行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logrotate -v /etc/logrotate.d/kube-apiserver</span><br></pre></td></tr></table></figure><p>logrotate 轮转日志分为两种模式，create 和 copytruncate，默认是 create，两种大致原理如下：</p><ul><li>create：重命名日志文件，再创建原有的日志文件，等同于 mv + touch</li><li>copytruncate：<code>cp xx.log xx.log.1 &amp;&amp; truncate -s 0 xx.log</code></li></ul><p>Linux 上打开文件名实际是操作 inode，文件名在打开 inode 后改名或者删掉文件 path 对进程并不会有影响，create 方式需要进程支持 reopen 日志文件路径使用新的 inode，类似 nginx 的 logrotate 配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/var/log/nginx/*.log /var/log/nginx/*/*.log&#123;</span><br><span class="line">daily</span><br><span class="line">missingok</span><br><span class="line">rotate 14</span><br><span class="line">compress</span><br><span class="line">delaycompress</span><br><span class="line">notifempty</span><br><span class="line">create 640 root adm</span><br><span class="line">sharedscripts</span><br><span class="line">postrotate</span><br><span class="line">[ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid`</span><br><span class="line">endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kube-apiserver 并没有支持这种行为，就尝试了下 <code>copytruncate</code> 发现也不行，然后去 <a href="https://github.com/kubernetes/enhancements/issues/2845">kep 的 kube-log-runner</a> 下回复了下请求添加 logrotate 支持。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>等官方估计很久了，先自己修改下源码支持下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line"><span class="string">&quot;os/signal&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">logFilePath    = flag.String(<span class="string">&quot;log-file&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;If non-empty, save stdout to this file&quot;</span>)</span><br><span class="line">alsoToStdOut   = flag.Bool(<span class="string">&quot;also-stdout&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;useful with log-file, log to standard output as well as the log file&quot;</span>)</span><br><span class="line">redirectStderr = flag.Bool(<span class="string">&quot;redirect-stderr&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;treat stderr same as stdout&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增全局变量</span></span><br><span class="line">logFile         *os.File</span><br><span class="line">logFileMu       sync.Mutex</span><br><span class="line">globalLogFile   <span class="type">string</span></span><br><span class="line">globalAlsoStdOut <span class="type">bool</span></span><br><span class="line">globalRedirectStderr <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyncWriter 支持动态切换 Writer</span></span><br><span class="line"><span class="keyword">type</span> SyncWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex</span><br><span class="line">w  io.Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sw *SyncWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">sw.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> sw.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> sw.w.Write(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sw *SyncWriter)</span></span> SetWriter(w io.Writer) &#123;</span><br><span class="line">sw.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> sw.mu.Unlock()</span><br><span class="line">sw.w = w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">outputSync = &amp;SyncWriter&#123;w: os.Stdout&#125;</span><br><span class="line">errSync    = &amp;SyncWriter&#123;w: os.Stderr&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := configureAndRun(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configureAndRun</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 保存参数到全局变量</span></span><br><span class="line">globalLogFile = *logFilePath</span><br><span class="line">globalAlsoStdOut = *alsoToStdOut</span><br><span class="line">globalRedirectStderr = *redirectStderr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化日志文件</span></span><br><span class="line"><span class="keyword">if</span> globalLogFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">logFile, err = os.OpenFile(globalLogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to open log file: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> globalAlsoStdOut &#123;</span><br><span class="line">outputSync.SetWriter(io.MultiWriter(os.Stdout, logFile))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">outputSync.SetWriter(logFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> globalRedirectStderr &#123;</span><br><span class="line">errSync.SetWriter(outputSync)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">args := flag.Args()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not enough arguments to run&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exe := args[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> exeArgs []<span class="type">string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">exeArgs = args[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line">cmd := exec.Command(exe, exeArgs...)</span><br><span class="line">cmd.Stdout = outputSync</span><br><span class="line">cmd.Stderr = errStream()</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Running command:\n%v&quot;</span>, cmdInfo(cmd))</span><br><span class="line">err := cmd.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;starting command: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理</span></span><br><span class="line"><span class="keyword">go</span> setupSigHandler(cmd.Process)</span><br><span class="line"><span class="keyword">if</span> err := cmd.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;running command: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errStream</span><span class="params">()</span></span> io.Writer &#123;</span><br><span class="line"><span class="keyword">if</span> *redirectStderr &#123;</span><br><span class="line"><span class="keyword">return</span> outputSync</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> os.Stderr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdInfo</span><span class="params">(cmd *exec.Cmd)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(</span><br><span class="line"><span class="string">`Command env: (log-file=%v, also-stdout=%v, redirect-stderr=%v)</span></span><br><span class="line"><span class="string">Run from directory: %v</span></span><br><span class="line"><span class="string">Executable path: %v</span></span><br><span class="line"><span class="string">Args (comma-delimited): %v`</span>, *logFilePath, *alsoToStdOut, *redirectStderr,</span><br><span class="line">cmd.Dir, cmd.Path, strings.Join(cmd.Args, <span class="string">&quot;,&quot;</span>),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后的信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupSigHandler</span><span class="params">(process *os.Process)</span></span> &#123;</span><br><span class="line">signals := []os.Signal&#123;</span><br><span class="line">syscall.SIGHUP, syscall.SIGINT,</span><br><span class="line">syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGUSR1,</span><br><span class="line">&#125;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(c, signals...)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Now listening for signals&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> s := <span class="keyword">range</span> c &#123;</span><br><span class="line"><span class="keyword">if</span> s == syscall.SIGUSR1 &#123;</span><br><span class="line">handleLogRotate()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">forwardSignal(process, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理日志轮转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleLogRotate</span><span class="params">()</span></span> &#123;</span><br><span class="line">logFileMu.Lock()</span><br><span class="line"><span class="keyword">defer</span> logFileMu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> globalLogFile == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;No log file configured, ignoring SIGUSR1&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭旧文件</span></span><br><span class="line"><span class="keyword">if</span> logFile != <span class="literal">nil</span> &#123;</span><br><span class="line">logFile.Sync()</span><br><span class="line"><span class="keyword">if</span> err := logFile.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error closing log file: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开新文件</span></span><br><span class="line">newFile, err := os.OpenFile(globalLogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;ERROR: Failed to reopen log file: %v (logging to stdout)&quot;</span>, err)</span><br><span class="line">outputSync.SetWriter(os.Stdout)</span><br><span class="line"><span class="keyword">if</span> globalRedirectStderr &#123;</span><br><span class="line">errSync.SetWriter(os.Stdout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logFile = newFile</span><br><span class="line">log.SetOutput(logFile)</span><br><span class="line">log.Println(<span class="string">&quot;Successfully reopened log file&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新输出流</span></span><br><span class="line"><span class="keyword">if</span> globalAlsoStdOut &#123;</span><br><span class="line">outputSync.SetWriter(io.MultiWriter(os.Stdout, logFile))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">outputSync.SetWriter(logFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> globalRedirectStderr &#123;</span><br><span class="line">errSync.SetWriter(outputSync)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forwardSignal</span><span class="params">(process *os.Process, s os.Signal)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Forwarding signal %v to PID %v&quot;</span>, s, process.Pid)</span><br><span class="line"><span class="keyword">if</span> err := process.Signal(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error forwarding signal %v: %v&quot;</span>, s, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码不转发 USR1 信号给套娃的进程，自身处理 USR1 信号就是 reopen 日志文件。然后 logrotate 触发需要 pid 文件，systemd 里增加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStartPost=/bin/sh -c &quot;echo $MAINPID &gt; /var/run/kube-apiserver.pid&quot;</span><br></pre></td></tr></table></figure><p>logrotate 配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/var/logs/kube-apiserver.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    rotate 5</span><br><span class="line">    size 400M</span><br><span class="line">    missingok</span><br><span class="line">    compress</span><br><span class="line">    nomail</span><br><span class="line">    delaycompress</span><br><span class="line">    create</span><br><span class="line">    postrotate</span><br><span class="line">        [ ! -f /var/run/kube-apiserver.pid ] || kill -USR1 `cat /var/run/kube-apiserver.pid`</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://wsgzao.github.io/post/logrotate/">https://wsgzao.github.io/post/logrotate/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近使用 kube-log-runner 的经历…..&lt;/p&gt;</summary>
    
    
    
    
    <category term="kube-log-runner" scheme="http://zhangguanzhang.github.io/tags/kube-log-runner/"/>
    
    <category term="logrotate" scheme="http://zhangguanzhang.github.io/tags/logrotate/"/>
    
  </entry>
  
  <entry>
    <title>阿里云 ecs 上 etcd SSL reset</title>
    <link href="http://zhangguanzhang.github.io/2025/02/14/aliyun-ecs-ssl/"/>
    <id>http://zhangguanzhang.github.io/2025/02/14/aliyun-ecs-ssl/</id>
    <published>2025-02-14T13:40:30.000Z</published>
    <updated>2025-02-14T13:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>折腾一些时间的 etcd ssl reset 问题…..</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>几年前的 120 块的腾讯云轻量应用服务器买了后再 240 块续费两年，快到期了后阿里云 90 快去买了一年。然后上面把我之前的 etcd 迁移过去了，证书当初生成的时候可以预留了 cert SAN 域名相关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># openssl  x509 -in s1.pem -noout -text | grep -A1 &#x27;X509v3 Subject Alternative Name&#x27;</span><br><span class="line">            X509v3 Subject Alternative Name: </span><br><span class="line">                DNS:localhost, DNS:xxx.com, IP Address:127.0.0.1, IP Address:10.0.x.x, IP Address:10.2.0.1</span><br></pre></td></tr></table></figure><p>避免其他 etcd 客户端换证书的，一些非云上会用到该 etcd 的直接本地配置 hosts xxx.com ，这样后续 ecs 换 ip 了直接改 hosts 文件即可。</p><h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p>过年放假之前 etcd 整到阿里云 ecs 上了，然后看着也正常，后面突然几个 agent 连不上 etcd，包括 curl 也有问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v https://xxx.com:22379 --resolve xxx.com:22379:x.x.x.x</span><br><span class="line">* Added xxx.com:22379:x.x.x.x to DNS cache</span><br><span class="line">* Hostname xxx.com was found <span class="keyword">in</span> DNS cache</span><br><span class="line">*   Trying x.x.x.x:22379...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to xxx.com (x.x.x.x) port 22379 (#0)</span><br><span class="line">* ALPN, offering h2</span><br><span class="line">* ALPN, offering http/1.1</span><br><span class="line">* successfully <span class="built_in">set</span> certificate verify locations:</span><br><span class="line">*   CAfile: /etc/ssl/certs/ca-certificates.crt</span><br><span class="line">  CApath: /etc/ssl/certs</span><br><span class="line">* TLSv1.3 (OUT), TLS handshake, Client hello (1):</span><br><span class="line">* OpenSSL SSL_connect: SSL_ERROR_SYSCALL <span class="keyword">in</span> connection to xxx.com:22379 </span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (35) OpenSSL SSL_connect: SSL_ERROR_SYSCALL <span class="keyword">in</span> connection to xxx.com:22379</span><br></pre></td></tr></table></figure><p>但是直接 ip 就没问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v https://x.x.x.x:22379 --resolve xxx.com:22379:x.x.x.x</span><br><span class="line">* Added xxx.com:22379:x.x.x.x to DNS cache</span><br><span class="line">*   Trying x.x.x.x:22379...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to x.x.x.x (x.x.x.x) port 22379 (#0)</span><br><span class="line">* ALPN, offering h2</span><br><span class="line">* ALPN, offering http/1.1</span><br><span class="line">* successfully set certificate verify locations:</span><br><span class="line">*   CAfile: /etc/ssl/certs/ca-certificates.crt</span><br><span class="line">  CApath: /etc/ssl/certs</span><br><span class="line">* TLSv1.3 (OUT), TLS handshake, Client hello (1):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Server hello (2):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Request CERT (13):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Certificate (11):</span><br><span class="line">* TLSv1.3 (OUT), TLS alert, unknown CA (560):</span><br><span class="line">* SSL certificate problem: unable to get local issuer certificate</span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (60) SSL certificate problem: unable to get local issuer certificate</span><br><span class="line">More details here: https://curl.haxx.se/docs/sslcerts.html</span><br><span class="line"></span><br><span class="line">curl failed to verify the legitimacy of the server and therefore could not</span><br><span class="line">establish a secure connection to it. To learn more about this situation and</span><br><span class="line">how to fix it, please visit the web page mentioned above.</span><br></pre></td></tr></table></figure><p>这些日子没那么忙了就看了下，发现好几个地方网络访问都这样，根据排除法一定是阿里云有问题了。搜了下 aliyun ssl reset 搜到果然是阿里云有问题。访问阿里云 ecs 的流量会先进云盾，会根据 SSL 的 SNI 域名做判断，如果没备案则 tcp reset。无语了，我这又不是 80、8080、443 端口，没办法暂时用 IP 吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.aliyun.com/article/708243">https://developer.aliyun.com/article/708243</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;折腾一些时间的 etcd ssl reset 问题…..&lt;/p&gt;</summary>
    
    
    
    
    <category term="etcd" scheme="http://zhangguanzhang.github.io/tags/etcd/"/>
    
    <category term="ssl" scheme="http://zhangguanzhang.github.io/tags/ssl/"/>
    
    <category term="aliyun" scheme="http://zhangguanzhang.github.io/tags/aliyun/"/>
    
  </entry>
  
  <entry>
    <title>给鲲鹏920和低版本飞腾编译arm64 clickhouse</title>
    <link href="http://zhangguanzhang.github.io/2025/02/13/clickhouse-arm64-v8.0-build/"/>
    <id>http://zhangguanzhang.github.io/2025/02/13/clickhouse-arm64-v8.0-build/</id>
    <published>2025-02-13T12:10:30.000Z</published>
    <updated>2025-02-13T12:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>clickhouse 官方 docker 镜像无法在老的 arm64 cpu 上运行，需要编译</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>业务方有在使用 clickhouse，当时版本是 <code>22.8.5.29</code>，随着后面也有 arm64 需求，在 arm64 机器上部署了 ck 后即使没有业务数据内存占用也非常高，在持续刷下面日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__1::__function::__policy_storage const*) @ 0x8e8379c in /usr/bin/clickhouse</span><br><span class="line">26. ThreadPoolImpl&lt;std::__1::thread&gt;::worker(std::__1::__list_iterator&lt;std::__1::thread, void*&gt;) @ 0x8e7f950 in /usr/bin/clickhouse</span><br><span class="line">27. ? @ 0x8e82844 in /usr/bin/clickhouse</span><br><span class="line">28. start_thread @ 0x7624 in /usr/lib/aarch64-linux-gnu/libpthread-2.31.so</span><br><span class="line">29. ? @ 0xd149c in /usr/lib/aarch64-linux-gnu/libc-2.31.so</span><br><span class="line"> (version 22.8.5.29 (official build))</span><br><span class="line">2025.02.08 16:10:33.504961 [ 54 ] &#123;&#125; &lt;Error&gt; void DB::MergeTreeBackgroundExecutor&lt;DB::MergeMutateRuntimeQueue&gt;::routine(DB::TaskRuntimeDataPtr) [Queue = DB::MergeMutateRuntimeQueue]: Code: 241. DB::Exception: Memory limit (total) exceeded: would use 18.44 GiB (attempt to allocate chunk of 8709611 bytes), maximum: 18.00 GiB. OvercommitTracker decision: Memory overcommit isn&#x27;t used. Waiting time or overcommit denominator are set to zero. (MEMORY_LIMIT_EXCEEDED), Stack trace (when copying this message, always include the lines below):</span><br><span class="line"></span><br><span class="line">0. DB::Exception::Exception(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, int, bool) @ 0x8dcd368 in /usr/bin/clickhouse</span><br><span class="line">1. DB::Exception::Exception&lt;char const*, char const*, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;, long&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;, std::__1::basic_string_view&lt;char, std::__1::char_traits&lt;char&gt; &gt; &gt;(int, fmt::v8::basic_format_string&lt;char, fmt::v8::type_identity&lt;char const*&gt;::type, fmt::v8::type_identity&lt;char const*&gt;::type, fmt::v8::type_identity&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt;::type, fmt::v8::type_identity&lt;long&amp;&gt;::type, fmt::v8::type_identity&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt;::type, fmt::v8::type_identity&lt;std::__1::basic_string_view&lt;char, std::__1::char_traits&lt;char&gt; &gt; &gt;::type&gt;, char const*&amp;&amp;, char const*&amp;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;&amp;&amp;, long&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;&amp;&amp;, std::__1::basic_string_view&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;&amp;) @ 0x8dbfe08 in /usr/bin/clickhouse</span><br><span class="line">2. MemoryTracker::allocImpl(long, bool, MemoryTracker*) @ 0x8dbf6d4 in /usr/bin/clickhouse</span><br><span class="line">3. MemoryTracker::allocImpl(long, bool, MemoryTracker*) @ 0x8dbf0f0 in /usr/bin/clickhouse</span><br><span class="line">4. MemoryTracker::allocImpl(long, bool, MemoryTracker*) @ 0x8dbf0f0 in /usr/bin/clickhouse</span><br><span class="line">5. DB::Memory&lt;Allocator&lt;false, false&gt; &gt;::alloc(unsigned long) @ 0x8e26118 in /usr/bin/clickhouse</span><br><span class="line">6. DB::WriteBufferFromFile::WriteBufferFromFile(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned long, int, unsigned int, char*, unsigned long) @ 0x8e46138 in /usr/bin/clickhouse</span><br><span class="line">7. DB::DiskLocal::writeFile(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned long, DB::WriteMode, DB::WriteSettings const&amp;) @ 0x1141bc88 in /usr/bin/clickhouse</span><br><span class="line">8. DB::DataPartStorageBuilderOnDisk::writeFile(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned long, DB::WriteSettings const&amp;) @ 0x1230e6e8 in /usr/bin/clickhouse</span><br><span class="line">9. DB::MergeTreeDataPartWriterOnDisk::Stream::Stream(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::shared_ptr&lt;DB::IDataPartStorageBuilder&gt; const&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::shared_ptr&lt;DB::ICompressionCodec&gt; const&amp;, unsigned long, DB::WriteSettings const&amp;) @ 0x12441ef0 in /usr/bin/clickhouse</span><br></pre></td></tr></table></figure><p>搜索了看到几个 issue 都建议升级版本：</p><ul><li><a href="https://github.com/ClickHouse/ClickHouse/issues/47642">https://github.com/ClickHouse/ClickHouse/issues/47642</a></li><li><a href="https://github.com/ClickHouse/ClickHouse/issues/40215">https://github.com/ClickHouse/ClickHouse/issues/40215</a></li></ul><p>后续也发现了部分国产 cpu 上无法启动，使用本文编译的后才可以启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs xxxxx</span></span><br><span class="line">Merging configuration file &#x27;/etc/clickhouse-server/config.d/docker_related_config.xml&#x27;.</span><br><span class="line">Including configuration file &#x27;/etc/metrika.xml&#x27;.</span><br><span class="line">2025.06.25 14:40:21.352040 [ 1 ] &#123;&#125; &lt;Information&gt; : Starting ClickHouse 22.8.5.29 with revision 54465, build id: 30D2CCC2A2FE0DE0, PID 1</span><br><span class="line">2025.06.25 14:40:21.352181 [ 1 ] &#123;&#125; &lt;Information&gt; Application: starting up</span><br><span class="line">2025.06.25 14:40:21.352201 [ 1 ] &#123;&#125; &lt;Information&gt; Application: OS name: Linux, version: 4.19.90-24.4.v2101.ky10.aarch64, architecture: aarch64</span><br><span class="line">2025.06.25 14:40:21.385220 [ 40 ] &#123;&#125; &lt;Fatal&gt; BaseDaemon: ########################################</span><br><span class="line">2025.06.25 14:40:21.385298 [ 40 ] &#123;&#125; &lt;Fatal&gt; BaseDaemon: (version 22.8.5.29 (official build), build id: 30D2CCC2A2FE0DE0) (from thread 1) (no query) Received signal Illegal instruction (4)</span><br><span class="line">2025.06.25 14:40:21.385327 [ 40 ] &#123;&#125; &lt;Fatal&gt; BaseDaemon: Illegal opcode.</span><br><span class="line">2025.06.25 14:40:21.385358 [ 40 ] &#123;&#125; &lt;Fatal&gt; BaseDaemon: Stack trace: 0xaaabccb2b12c 0xfffc5cb307c0</span><br><span class="line">2025.06.25 14:40:21.385459 [ 40 ] &#123;&#125; &lt;Fatal&gt; BaseDaemon: 0. ? @ 0x8fdb12c in /usr/bin/clickhouse</span><br><span class="line">2025.06.25 14:40:21.385562 [ 40 ] &#123;&#125; &lt;Fatal&gt; BaseDaemon: 1. ? @ 0xfffc5cb307c0 in ?</span><br><span class="line">2025.06.25 14:40:21.554513 [ 40 ] &#123;&#125; &lt;Fatal&gt; BaseDaemon: Integrity check of the executable skipped because the reference checksum could not be read. (calculated checksum: 05AC43DEA3E119694BFE830A4D95</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lscpu</span></span><br><span class="line">架构：                           aarch64</span><br><span class="line">CPU 运行模式：                   64-bit</span><br><span class="line">字节序：                         Little Endian</span><br><span class="line">CPU:                             16</span><br><span class="line">在线 CPU 列表：                  0-15</span><br><span class="line">每个核的线程数：                 1</span><br><span class="line">每个座的核数：                   1</span><br><span class="line">座：                             16</span><br><span class="line">NUMA 节点：                      1</span><br><span class="line">厂商 ID：                        Phytium</span><br><span class="line">型号：                           2</span><br><span class="line">型号名称：                       FT-2000+/64</span><br><span class="line">步进：                           0x1</span><br><span class="line">BogoMIPS：                       100.00</span><br><span class="line">L1d 缓存：                       1 MiB</span><br><span class="line">L1i 缓存：                       1 MiB</span><br><span class="line">L2 缓存：                        8 MiB</span><br><span class="line">L3 缓存：                        512 MiB</span><br><span class="line">NUMA 节点0 CPU：                 0-15</span><br><span class="line">Vulnerability Itlb multihit:     Not affected</span><br><span class="line">Vulnerability L1tf:              Not affected</span><br><span class="line">Vulnerability Mds:               Not affected</span><br><span class="line">Vulnerability Meltdown:          Not affected</span><br><span class="line">Vulnerability Spec store bypass: Not affected</span><br><span class="line">Vulnerability Spectre v1:        Mitigation; __user pointer sanitization</span><br><span class="line">Vulnerability Spectre v2:        Not affected</span><br><span class="line">Vulnerability Srbds:             Not affected</span><br><span class="line">Vulnerability Tsx async abort:   Not affected</span><br><span class="line">标记：                           fp asimd evtstrm crc32 cpuid</span><br></pre></td></tr></table></figure><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="arm64-运行环境"><a href="#arm64-运行环境" class="headerlink" title="arm64 运行环境"></a>arm64 运行环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ lscpu</span><br><span class="line">架构：                           aarch64</span><br><span class="line">CPU 运行模式：                   64-bit</span><br><span class="line">字节序：                         Little Endian</span><br><span class="line">CPU:                             16</span><br><span class="line">在线 CPU 列表：                  0-15</span><br><span class="line">每个核的线程数：                 1</span><br><span class="line">每个座的核数：                   1</span><br><span class="line">座：                             16</span><br><span class="line">NUMA 节点：                      1</span><br><span class="line">厂商 ID：                        Phytium</span><br><span class="line">型号：                           3</span><br><span class="line">型号名称：                       ARMv8 CPU</span><br><span class="line">步进：                           0x1</span><br><span class="line">CPU 最大 MHz：                   2100.0000</span><br><span class="line">CPU 最小 MHz：                   2100.0000</span><br><span class="line">BogoMIPS：                       100.00</span><br><span class="line">L1d 缓存：                       1 MiB</span><br><span class="line">L1i 缓存：                       1 MiB</span><br><span class="line">L2 缓存：                        8 MiB</span><br><span class="line">L3 缓存：                        512 MiB</span><br><span class="line">NUMA 节点0 CPU：                 0-15</span><br><span class="line">Vulnerability Itlb multihit:     Not affected</span><br><span class="line">Vulnerability L1tf:              Not affected</span><br><span class="line">Vulnerability Mds:               Not affected</span><br><span class="line">Vulnerability Meltdown:          Not affected</span><br><span class="line">Vulnerability Mmio stale data:   Not affected</span><br><span class="line">Vulnerability Spec store bypass: Not affected</span><br><span class="line">Vulnerability Spectre v1:        Mitigation; __user pointer sanitization</span><br><span class="line">Vulnerability Spectre v2:        Not affected</span><br><span class="line">Vulnerability Srbds:             Not affected</span><br><span class="line">Vulnerability Tsx async abort:   Not affected</span><br><span class="line">标记：                           fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid</span><br></pre></td></tr></table></figure><h3 id="升级后起不来"><a href="#升级后起不来" class="headerlink" title="升级后起不来"></a>升级后起不来</h3><p>根据 ck <a href="https://clickhouse.com/docs/en/operations/update">官方 update 文档</a> 里可知官方努力保持一年兼容期，两个版本之前差异小于一年或者 LTS 版本少于两个可以升级。而 23 的 LTS 版本是 <code>v23.8.16.40-lts</code> 。然后换了镜像后运行不起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/entrypoint.sh: line 40:    23 Illegal instruction     (core dumped) clickhouse extract-from-config --config-file &quot;$CLICKHOUSE_CONFIG&quot; --key=&#x27;storage_configuration.disks.*.path&#x27;</span><br><span class="line">/entrypoint.sh: line 41:    25 Illegal instruction     (core dumped) clickhouse extract-from-config --config-file &quot;$CLICKHOUSE_CONFIG&quot; --key=&#x27;storage_configuration.disks.*.metadata_path&#x27;</span><br></pre></td></tr></table></figure><p>然后尝试了下列版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">23.5.5.92</span><br><span class="line">23.3.22.3</span><br><span class="line">23.3.9.55</span><br><span class="line">23.3.1</span><br><span class="line">22.12.6.22</span><br><span class="line">22.8.21.38</span><br><span class="line">22.10.7.13</span><br><span class="line">22.10.1</span><br><span class="line">22.9.1.2603</span><br><span class="line">22.9.7.34</span><br></pre></td></tr></table></figure><p>发现 22.9 才能启动，查看 changelog <a href="https://clickhouse.com/docs/en/whats-new/changelog/2022#-clickhouse-release-2210-2022-10-25">https://clickhouse.com/docs/en/whats-new/changelog/2022#-clickhouse-release-2210-2022-10-25</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Aarch64 binaries now require at least ARMv8.2, released in 2016. Most notably, this enables use of ARM LSE, i.e. native atomic operations. \</span><br><span class="line">Also, CMake build option &quot;NO_ARMV81_OR_HIGHER&quot; has been added to allow compilation of binaries for older ARMv8.0 hardware, e.g. Raspberry Pi 4. #41610 (Robert Schulze).</span><br></pre></td></tr></table></figure><p>22.10 开始使用 arm LSE 指令集做原子操作，但是该指令集 armv8.2 才有，但是也在 Cmake 添加了选项 <code>NO_ARMV81_OR_HIGHER</code> 对于 armv8.0 编译支持。</p><h3 id="查看编译文档"><a href="#查看编译文档" class="headerlink" title="查看编译文档"></a>查看编译文档</h3><p>官方虽然文档写得比较多，但是感觉比较琐碎。跟着前面 changelog 的 pr <a href="https://github.com/ClickHouse/ClickHouse/pull/41987">#41987</a> 看了下官方是 github action 编译的。github action 构建历史有上限，找 pr 里的 <code>BuilderBinAarch64V80Compat</code> 找不到，然后在新版本 <code>.github/workflows/master.yml</code> 里找到了 <code>build_arm_v80compat</code>。但是用的是下面编译命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m praktika run &#x27;Build (arm_v80compat)&#x27; --workflow &quot;MasterCI&quot; --ci</span><br></pre></td></tr></table></figure><p><code>praktika</code> 这个 pip 仓库上找不到，于是找到相关最新的 action 里看下具体怎么编译的，找到了相关日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INFO:root:Pulling image clickhouse/binary-builder:54b46bb22708 - done</span><br><span class="line">INFO:root:Going to run packager with cd /home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/docker/packager &amp;&amp; \</span><br><span class="line">  CMAKE_FLAGS=&#x27;-DENABLE_CLICKHOUSE_SELF_EXTRACTING=1&#x27; ./packager \</span><br><span class="line">  --output-dir=/home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/ci/tmp/build \</span><br><span class="line">  --package-type=binary --compiler=clang-19-aarch64-v80compat \</span><br><span class="line">  --cache=sccache --s3-rw-access --s3-bucket=clickhouse-builds \</span><br><span class="line">  --docker-image-version=54b46bb22708 --with-profiler --with-buzzhouse --version=25.2.1.1773 --official</span><br><span class="line"></span><br><span class="line">2025-02-10 22:37:56,547 Will build ClickHouse pkg with cmd: &#x27;docker run --network=host --user=1000:1000 --rm  \</span><br><span class="line">  --volume=/home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/ci/tmp/build:/output \</span><br><span class="line">  --volume=/home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse:/build \</span><br><span class="line">   -e OUTPUT_DIR=/output -e DEB_ARCH=arm64 -e CC=clang-19 -e CXX=clang++-19 \</span><br><span class="line">   -e BUILD_TYPE=None -e SCCACHE_BUCKET=clickhouse-builds -e SCCACHE_S3_KEY_PREFIX=ccache/sccache \</span><br><span class="line">   -e VERSION_STRING=&#x27;25.2.1.1773&#x27; \</span><br><span class="line">   -e CMAKE_FLAGS=&quot;$CMAKE_FLAGS -DCMAKE_TOOLCHAIN_FILE=/build/cmake/linux/toolchain-aarch64.cmake \</span><br><span class="line">   -DNO_ARMV81_OR_HIGHER=1 -DCMAKE_C_COMPILER=clang-19 -DCMAKE_CXX_COMPILER=clang++-19 \</span><br><span class="line">   -DCOMPILER_CACHE=sccache -DENABLE_BUILD_PROFILING=1 \</span><br><span class="line">   -DENABLE_BUZZHOUSE=1 -DCLICKHOUSE_OFFICIAL_BUILD=1&quot; \</span><br><span class="line">   -e BUILD_TARGET=&#x27;clickhouse-bundle&#x27; --volume=/home/ubuntu/.cargo/registry:/rust/cargo/registry  \</span><br><span class="line">   clickhouse/binary-builder:54b46bb22708&#x27;</span><br></pre></td></tr></table></figure><p>搜了下相关源码相关关键字 <code>binary-builder</code>，大体了解了下官方编译步骤：</p><ul><li><code>docker/packager</code> 下提供了 <code>packager</code> 二进制(实际是python脚本)来编译</li><li><code>docker/packager/binary-builder</code> 是利用 docker 打包一个镜像，里面包含 llvm、rust、clang 之类的编译环境</li></ul><p>该容器镜像由 CI 构建定期推送到 dockerhub 上，然后不想宿主机上安装环境可以使用它来进行编译，具体参数查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd docker/packager</span><br><span class="line">$ packager --help</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>并且官方文档有 <a href="https://clickhouse.com/docs/en/development/build#building-in-docker">building-in-docker</a> ，所以打算使用官方的 docker 镜像构建，机器要提前安装好 docker，硬盘最好有 50G 容量，源码非常大，自备稳定猫咪之类的。拉取源码和编译全程建议开个 screen 里操作：</p><h4 id="拉取源码"><a href="#拉取源码" class="headerlink" title="拉取源码"></a>拉取源码</h4><p>因为子模块非常多，建议使用 git2 避免一些奇怪问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ClickHouse/ClickHouse.git</span><br></pre></td></tr></table></figure><p>切到指定分支和拉取子模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout v23.8.16.40-lts</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>查看子模块完整性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git submodule status</span><br></pre></td></tr></table></figure><p>确认拉取完成后再开始后面操作</p><h4 id="失败的编译"><a href="#失败的编译" class="headerlink" title="失败的编译"></a>失败的编译</h4><p>查看 <code>docker/packager/packager</code> 内容编译 arm64v8.0 执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./docker/packager</span><br><span class="line">packager --package-type=binary --output-dir=build_results \</span><br><span class="line"> --compiler=clang-16-aarch64-v80compat</span><br></pre></td></tr></table></figure><p>然后报错 clang 版本相关，默认拉取的 <code>clickhouse/binary-builder:latest</code>，查看了下 <code>packager</code> 源码和 <code>--help</code> 有选项 <code>--docker-image-version</code> 指定镜像 tag，去 dockerhub 上找了下 <code>clickhouse/binary-builder</code> 的 clang 16 版本，发现 tag 好像是 commitid 相关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log -n1</span><br><span class="line">commit e143a9039ba36ad0c25f2ed85503f36e88f61063 (HEAD, tag: v23.8.16.40-lts)</span><br><span class="line">Merge: 8afc5bd5d1c a60c914df11</span><br><span class="line">Author: Antonio Andelic &lt;antonio2368@users.noreply.github.com&gt;</span><br><span class="line">Date:   Thu Jul 25 20:50:17 2024 +0100</span><br><span class="line"></span><br><span class="line">    Merge pull request #66717 from ClickHouse/backport/23.8/66548</span><br><span class="line">    </span><br><span class="line">    Backport #66548 to 23.8: Correctly track memory for `Allocator::realloc`</span><br></pre></td></tr></table></figure><p>搜索了下 <a href="https://hub.docker.com/r/clickhouse/binary-builder/tags?name=e143a903">e143a903</a> 找到了 tag <code>54187-e143a9039ba36ad0c25f2ed85503f36e88f61063</code>，但是镜像比较大，然后用 daoCloud 的同步了下，拉取下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull m.daocloud.io/docker.io/clickhouse/binary-builder:54187-e143a9039ba36ad0c25f2ed85503f36e88f61063</span><br><span class="line">docker tag m.daocloud.io/docker.io/clickhouse/binary-builder:54187-e143a9039ba36ad0c25f2ed85503f36e88f61063 \</span><br><span class="line">        clickhouse/binary-builder:54187-e143a9039ba36ad0c25f2ed85503f36e88f61063</span><br></pre></td></tr></table></figure><p>然后编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./docker/packager/packager --package-type=binary --compiler=clang-16-aarch64-v80compat  \</span><br><span class="line">  --output-dir=build_results --docker-image-version 54187-e143a9039ba36ad0c25f2ed85503f36e88f61063</span><br></pre></td></tr></table></figure><p>相关报错一直无法解决，提了 <a href="https://github.com/ClickHouse/ClickHouse/issues/75923">issue 75923</a>，官方说该版本已经不维护不提供帮助，让我不要自己编译，而是去下载官方编译的。下载了当然是 core dump。然后自己找了下官方编译的 <code>build_arm_v80compat</code> ，只有一个下载直链，不存在老版本，action 里可以看到下载链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">2025-02-10 22:46:45,343 Output placed into /home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/ci/tmp/build</span><br><span class="line">INFO:root:Built successfully</span><br><span class="line">INFO:root:Build finished as success, log path /home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/ci/tmp/build_log/build_log.log</span><br><span class="line">INFO:botocore.credentials:Found credentials from IAM Role: ec2_admin</span><br><span class="line">INFO:root:Processing file without compression</span><br><span class="line">INFO:root:File is too large, do not provide content type</span><br><span class="line">INFO:root:Upload /home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/ci/tmp/build/clickhouse to https://s3.amazonaws.com/clickhouse-builds/master/aarch64v80compat/clickhouse-full Meta: &#123;&#125;</span><br><span class="line">Notice: Binary static URL (with debug info): https://s3.amazonaws.com/clickhouse-builds/master/aarch64v80compat/clickhouse-full</span><br><span class="line">INFO:root:Processing file without compression</span><br><span class="line">INFO:root:File is too large, do not provide content type</span><br><span class="line">INFO:root:Upload /home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/ci/tmp/build/clickhouse-stripped to https://s3.amazonaws.com/clickhouse-builds/master/aarch64v80compat/clickhouse Meta: &#123;&#125;</span><br><span class="line">Notice: Binary static URL (compact): https://s3.amazonaws.com/clickhouse-builds/master/aarch64v80compat/clickhouse</span><br><span class="line">Run action done for: [binary_aarch64_v80compat]</span><br><span class="line">INFO:botocore.credentials:Found credentials from IAM Role: ec2_admin</span><br><span class="line">INFO:root:Get token with 4322 remaining requests</span><br><span class="line">INFO:root:User robot-clickhouse-ci-1 with 4322 remaining requests is used</span><br><span class="line">&#123;&#125;</span><br><span class="line">=== Run script finished ===</span><br></pre></td></tr></table></figure><p>每个 action 里都有链接，但是太早的就没有了，因为 github action 只保留上限的构建历史。看了下应该是构建都存在 s3 上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=== Post run script [Build (arm_v80compat)], workflow [MasterCI] ===</span><br><span class="line">Job provides s3 artifacts [[Artifact.Config(name=&#x27;CH_ARMV80C_DARWIN_BIN&#x27;, type=&#x27;s3&#x27;, path=&#x27;/home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/ci/tmp/build/clickhouse&#x27;, _provided_by=&#x27;Build (arm_v80compat)&#x27;, _s3_path=&#x27;&#x27;)]]</span><br><span class="line">Run command: [ls -l /home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/ci/tmp/build/clickhouse]</span><br><span class="line">-rwxr-xr-x 1 ubuntu ubuntu 770032980 Feb 10 23:27 /home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/ci/tmp/build/clickhouse</span><br><span class="line">Run command [aws s3 cp /home/ubuntu/actions-runner/_work/ClickHouse/ClickHouse/ci/tmp/build/clickhouse s3://clickhouse-builds/REFs/master/57b1cafdcb704280f05ee61345e8fbad9a6af5ed/build_arm_v80compat/clickhouse]</span><br><span class="line">Artifact report enabled and will be uploaded: [&#123;&#x27;build_urls&#x27;: [&#x27;https://clickhouse-builds.s3.amazonaws.com/REFs/master/57b1cafdcb704280f05ee61345e8fbad9a6af5ed/build_arm_v80compat/clickhouse&#x27;]&#125;]</span><br><span class="line">Run command [aws s3 cp ./ci/tmp/artifact_report_build_arm_v80compat.json s3://clickhouse-builds/REFs/master/57b1cafdcb704280f05ee61345e8fbad9a6af5ed/build_arm_v80compat/artifact_report_build_arm_v80compat.json]</span><br><span class="line">Insert results to CIDB</span><br></pre></td></tr></table></figure><p>根据链接规则推断了下下载 url，发现 403：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://clickhouse-builds.s3.amazonaws.com/REFs/master/e143a9039ba36ad0c25f2ed85503f36e88f61063/build_arm_v80compat/clickhouse</span><br></pre></td></tr></table></figure><p>既然说 v23 不维护，然后尝试了 v24 的 lts 版本也一样，相关报错也提了 <a href="https://github.com/ClickHouse/ClickHouse/issues/75960">issue 75960</a></p><h4 id="成功的编译"><a href="#成功的编译" class="headerlink" title="成功的编译"></a>成功的编译</h4><p>报错都是 <code>contrib/sysroot</code> 和 <code>contrib/thrift</code> 这俩子模块，github 上看了下历史记录，这俩模块基本没怎么更新到新版本，感觉不是模块问题。搜了一些相关编译，发现都是编译 22.10 之前的版本居多。麒麟的 yum 源里版本也比较老，联系了麒麟有没有新版本 rpm 包，然后麒麟发了个新版本源码编译安装的文档过来，看了下是在 arm64 上编译的 25 版本，大体步骤为：</p><ul><li>rpm 包安装 cmake 3.26</li><li>编译安装 gcc-11.3.0 并换 std 库</li><li>编译安装 clang-18.1.0</li><li>编译安装 llvm-18.1.0</li><li>安装 rust 1.80.0</li><li>安装 ccache src.rpm</li><li>声明 CC&#x3D;clang CXX&#x3D;clang++ 后<ul><li><code>mkdir build &amp;&amp; cd build</code></li><li><code>cmake .. -DCMAKE_INSTALL_PREFIX=/opt/clickhouse-bin -DNO_ARMV81_OR_HIGHER=1</code></li><li><code>ninja -j32</code></li><li><code>ninja install</code></li></ul></li></ul><p>根据编译相关，<code>packager</code> 的 <code>--compiler=clang-16-aarch64-v80compat</code> 相关逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ARM_V80COMPAT_SUFFIX = <span class="string">&quot;-aarch64-v80compat&quot;</span></span><br><span class="line">...</span><br><span class="line">is_cross_arm_v80compat = compiler.endswith(ARM_V80COMPAT_SUFFIX)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">elif</span> is_cross_arm_v80compat:</span><br><span class="line">        cc = compiler[: -<span class="built_in">len</span>(ARM_V80COMPAT_SUFFIX)]</span><br><span class="line">        cmake_flags.append(</span><br><span class="line">            <span class="string">&quot;-DCMAKE_TOOLCHAIN_FILE=/build/cmake/linux/toolchain-aarch64.cmake&quot;</span></span><br><span class="line">        )</span><br><span class="line">        cmake_flags.append(<span class="string">&quot;-DNO_ARMV81_OR_HIGHER=1&quot;</span>)</span><br><span class="line">        result.append(<span class="string">&quot;DEB_ARCH=arm64&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>-DNO_ARMV81_OR_HIGHER=1</code> 是必填的，而插入的 <code>-DCMAKE_TOOLCHAIN_FILE</code> 则是配置使用交叉编译工具链。交叉编译一直失败，是不是可以 arm64 机器上和麒麟那样源码编译 clang 等相关再尝试编译 ck，但是新开的麒麟 arm64 机器上没猫咪 gcc 和 llvm 下载非常慢。就同步看了下 <code>clickhouse/binary-builder</code> 发现还提供了 arm64 的镜像，想着直接 arm64 上不指定 <code>ARM_V80COMPAT_SUFFIX</code> 那就会用内置的 arm64 gcc 了，然后再指定 <code>-DNO_ARMV81_OR_HIGHER=1</code> 编译选项那就和麒麟一样了。和之前一样找了个高配置 arm64 机器上：</p><ul><li>拉源码，进去 checkout 到 <code>v23.8.16.40-lts</code>，拉取子模块源码</li><li>拉取对应的 <code>clickhouse/binary-builder</code> 并 tag</li></ul><p>查看脚本得到编译命令和选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_FLAGS=<span class="string">&#x27;-DNO_ARMV81_OR_HIGHER=1&#x27;</span> ./docker/packager/packager --package-type=binary \</span><br><span class="line">  --output-dir=build_results --docker-image-version 54187-e143a9039ba36ad0c25f2ed85503f36e88f61063</span><br></pre></td></tr></table></figure><p>执行后终于没卡在 <code>contrib/sysroot</code> 和 <code>contrib/thrift</code> 了，但是最后报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Feb 12 08:22:09 [3590/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/SubtargetFeatureInfo.cpp.o</span><br><span class="line">Feb 12 08:22:10 [3591/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/CompressInstEmitter.cpp.o</span><br><span class="line">Feb 12 08:22:10 [3592/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/X86DisassemblerTables.cpp.o</span><br><span class="line">Feb 12 08:22:10 [3593/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/GlobalISel/CMakeFiles/LLVMTableGenGlobalISel.dir/CodeExpander.cpp.o</span><br><span class="line">Feb 12 08:22:11 [3594/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/GlobalISel/CMakeFiles/LLVMTableGenGlobalISel.dir/GIMatchDagEdge.cpp.o</span><br><span class="line">Feb 12 08:22:11 [3595/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/WebAssemblyDisassemblerEmitter.cpp.o</span><br><span class="line">Feb 12 08:22:11 [3596/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/X86RecognizableInstr.cpp.o</span><br><span class="line">Feb 12 08:22:11 [3596/10884] cd /build/build_docker/rust/skim &amp;&amp; /usr/bin/cmake -E make_directory /build/build_docker/rust/skim/RelWithDebInfo &amp;&amp; /usr/bin/cmake -E env CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=/usr/bin/clang++-16 CC_aarch64-unknown-linux-gnu=/usr/bin/clang-16 HOST_CC=/usr/bin/clang-16 CXX_aarch64-unknown-linux-gnu=/usr/bin/clang++-16 HOST_CXX=/usr/bin/clang++-16 CORROSION_BUILD_DIR=/build/build_docker/rust/skim CARGO_BUILD_RUSTC=/rust/rustup/toolchains/nightly-2023-07-04-aarch64-unknown-linux-gnu/bin/rustc /rust/rustup/toolchains/nightly-2023-07-04-aarch64-unknown-linux-gnu/bin/cargo rustc --target=aarch64-unknown-linux-gnu --package _ch_rust_skim_rust --manifest-path /build/build_docker/rust/skim/Cargo.toml --target-dir /build/build_docker/RelWithDebInfo/cargo/build --profile=release -- -Cdefault-linker-libraries=no -Clink-args=--target=aarch64-linux-gnu &amp;&amp; /usr/bin/cmake -E copy_if_different /build/build_docker/RelWithDebInfo/cargo/build/aarch64-unknown-linux-gnu/release/lib_ch_rust_skim_rust.a /build/build_docker/rust/skim/RelWithDebInfo</span><br><span class="line">Feb 12 08:22:11 error: package `cxx v1.0.140` cannot be built because it requires rustc 1.73 or newer, while the currently active rustc version is 1.72.0-nightly</span><br><span class="line">Feb 12 08:22:11 Either upgrade to rustc 1.73 or newer, or use</span><br><span class="line">Feb 12 08:22:11 cargo update -p cxx@1.0.140 --precise ver</span><br><span class="line">Feb 12 08:22:11 where `ver` is the latest version of `cxx` supporting rustc 1.72.0-nightly</span><br><span class="line">Feb 12 08:22:12 [3600/10884] Linking CXX static library contrib/ulid-c-cmake/lib_ulid.a</span><br><span class="line">Feb 12 08:22:12 FAILED: rust/skim/CMakeFiles/cargo-build__ch_rust_skim_rust rust/skim/RelWithDebInfo/lib_ch_rust_skim_rust.a /build/build_docker/rust/skim/CMakeFiles/cargo-build__ch_rust_skim_rust /build/build_docker/rust/skim/RelWithDebInfo/lib_ch_rust_skim_rust.a </span><br><span class="line">Feb 12 08:22:12 cd /build/build_docker/rust/skim &amp;&amp; /usr/bin/cmake -E make_directory /build/build_docker/rust/skim/RelWithDebInfo &amp;&amp; /usr/bin/cmake -E env CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=/usr/bin/clang++-16 CC_aarch64-unknown-linux-gnu=/usr/bin/clang-16 HOST_CC=/usr/bin/clang-16 CXX_aarch64-unknown-linux-gnu=/usr/bin/clang++-16 HOST_CXX=/usr/bin/clang++-16 CORROSION_BUILD_DIR=/build/build_docker/rust/skim CARGO_BUILD_RUSTC=/rust/rustup/toolchains/nightly-2023-07-04-aarch64-unknown-linux-gnu/bin/rustc /rust/rustup/toolchains/nightly-2023-07-04-aarch64-unknown-linux-gnu/bin/cargo rustc --target=aarch64-unknown-linux-gnu --package _ch_rust_skim_rust --manifest-path /build/build_docker/rust/skim/Cargo.toml --target-dir /build/build_docker/RelWithDebInfo/cargo/build --profile=release -- -Cdefault-linker-libraries=no -Clink-args=--target=aarch64-linux-gnu &amp;&amp; /usr/bin/cmake -E copy_if_different /build/build_docker/RelWithDebInfo/cargo/build/aarch64-unknown-linux-gnu/release/lib_ch_rust_skim_rust.a /build/build_docker/rust/skim/RelWithDebInfo</span><br><span class="line">Feb 12 08:22:12 [3602/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/SearchableTableEmitter.cpp.o</span><br><span class="line">Feb 12 08:22:12 [3603/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/CTagsEmitter.cpp.o</span><br><span class="line">Feb 12 08:22:12 [3604/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/VarLenCodeEmitterGen.cpp.o</span><br><span class="line">Feb 12 08:22:12 [3605/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/InstrInfoEmitter.cpp.o</span><br><span class="line">Feb 12 08:22:12 [3606/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/GlobalISel/CMakeFiles/LLVMTableGenGlobalISel.dir/GIMatchDagOperands.cpp.o</span><br><span class="line">Feb 12 08:22:12 [3607/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/GlobalISel/CMakeFiles/LLVMTableGenGlobalISel.dir/GIMatchDagInstr.cpp.o</span><br><span class="line">Feb 12 08:22:12 [3608/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/GlobalISel/CMakeFiles/LLVMTableGenGlobalISel.dir/GIMatchDag.cpp.o</span><br><span class="line">Feb 12 08:22:12 [3609/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/X86FoldTablesEmitter.cpp.o</span><br><span class="line">Feb 12 08:22:12 [3610/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/GlobalISel/CMakeFiles/LLVMTableGenGlobalISel.dir/GIMatchDagPredicateDependencyEdge.cpp.o</span><br><span class="line">Feb 12 08:22:12 [3611/10884] Building CXX object contrib/llvm-project/llvm/lib/BinaryFormat/CMakeFiles/LLVMBinaryFormat.dir/COFF.cpp.o</span><br><span class="line">Feb 12 08:22:13 [3612/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/GlobalISel/CMakeFiles/LLVMTableGenGlobalISel.dir/GIMatchDagPredicate.cpp.o</span><br><span class="line">Feb 12 08:22:13 [3613/10884] Building CXX object contrib/llvm-project/llvm/lib/BinaryFormat/CMakeFiles/LLVMBinaryFormat.dir/AMDGPUMetadataVerifier.cpp.o</span><br><span class="line">Feb 12 08:22:14 [3614/10884] Building CXX object contrib/llvm-project/llvm/lib/BinaryFormat/CMakeFiles/LLVMBinaryFormat.dir/Dwarf.cpp.o</span><br><span class="line">Feb 12 08:22:15 [3615/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/SubtargetEmitter.cpp.o</span><br><span class="line">Feb 12 08:22:18 [3616/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/RegisterInfoEmitter.cpp.o</span><br><span class="line">Feb 12 08:22:19 [3617/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/GlobalISel/CMakeFiles/LLVMTableGenGlobalISel.dir/GIMatchTree.cpp.o</span><br><span class="line">Feb 12 08:22:24 [3618/10884] Building CXX object contrib/llvm-project/llvm/utils/TableGen/CMakeFiles/llvm-tblgen.dir/GlobalISelEmitter.cpp.o</span><br></pre></td></tr></table></figure><p>报错说 rust 版本 1.72 低了，要求 1.73，搜了下 <code>nightly-2023-07-04</code> 搜不到有用的，<code>nightly</code> 是每日发行版本，找不到对应的 <code>1.73</code> 是啥日期。如果直接使用新版本 <code>binary-builder</code> ，里面的 clang 和要编译的 ck 版本对不上，于是根据 <code>clickhouse/binary-builder</code> 的 Dockerfile 找了下 rust 的临近更新是 <code>nightly-2024-12-01</code>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl https://sh.rustup.rs -sSf | bash -s -- -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 777 -R /rust &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    rustup toolchain install nightly-2024-12-01 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    rustup default nightly-2024-12-01 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    rustup toolchain remove stable &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    rustup component add rust-src &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    rustup target add x86_64-unknown-linux-gnu &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    rustup target add aarch64-unknown-linux-gnu &amp;&amp; \</span></span><br></pre></td></tr></table></figure><p>前面编译报错结尾会有一个 <code>docker run ...</code> 完整命令，结尾加一个 <code>bash</code> run 起来后内部升级下 rust 尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记得依旧使用 screen</span></span><br><span class="line">docker run .... bash</span><br><span class="line"><span class="comment"># export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup # 没有下面的nightly</span></span><br><span class="line">rustup toolchain install nightly-2024-12-01</span><br><span class="line">rustup default nightly-2024-12-01</span><br><span class="line">rustup component add rust-src <span class="comment">#&lt;--- 似乎没必要执行</span></span><br><span class="line">rustup target add aarch64-unknown-linux-gnu <span class="comment">#&lt;--- 似乎没必要执行</span></span><br></pre></td></tr></table></figure><p>实际 <code>clickhouse/binary-builder</code> 和 它的 Dockerfile CMD 都是执行：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;bash&quot;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;/build.sh 2&gt;&amp;1&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>所以上面的容器里继续执行 <code>bash /build.sh</code> 就可以编译了，最后编译出来 2.9G 大小:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Feb 12 10:39:51 Average compiler                  0.000 s</span><br><span class="line">Feb 12 10:39:51 Average cache read hit            0.000 s</span><br><span class="line">Feb 12 10:39:51 Failed distributed compilations       0</span><br><span class="line">Feb 12 10:39:51 Cache location                  Local disk: &quot;/root/.cache/sccache&quot;</span><br><span class="line">Feb 12 10:39:51 Version (client)                0.5.4</span><br><span class="line">Feb 12 10:39:51 + ccache --evict-older-than 1d</span><br><span class="line">Feb 12 10:39:51 + &#x27;[&#x27; &#x27;&#x27; == 1 &#x27;]&#x27;</span><br><span class="line">Feb 12 10:39:51 + &#x27;[&#x27; -n &#x27;&#x27; &#x27;]&#x27;</span><br><span class="line">Feb 12 10:39:51 + ls -l /output</span><br><span class="line">Feb 12 10:39:51 total 6200956</span><br><span class="line">Feb 12 10:39:51 -rwxr-xr-x 1 root root 3336977696 Feb 12 10:39 clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-benchmark -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-client -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-compressor -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-copier -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-disks -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-extract-from-config -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-format -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-git-import -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-keeper -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-keeper-client -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-keeper-converter -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-local -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-obfuscator -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-server -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-static-files-disk-uploader -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 lrwxrwxrwx 1 root root         10 Feb 12 10:39 clickhouse-su -&gt; clickhouse</span><br><span class="line">Feb 12 10:39:51 -rwxr-xr-x 1 root root 3012799232 Feb 12 10:39 unit_tests_dbms</span><br></pre></td></tr></table></figure><p>然后加一些选项编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_FLAGS=<span class="string">&#x27;-DNO_ARMV81_OR_HIGHER=1 -DCMAKE_BUILD_TYPE=Release -DENABLE_TESTS=OFF -DENABLE_DEBUG=OFF -DSPLIT_DEBUG_SYMBOLS=ON&#x27;</span> \</span><br><span class="line">  ./docker/packager/packager --package-type=binary \</span><br><span class="line">  --output-dir=build_results --docker-image-version 54187-e143a9039ba36ad0c25f2ed85503f36e88f61063</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Feb 13 01:24:21 Failed distributed compilations       0</span><br><span class="line">Feb 13 01:24:21 Cache location                  Local disk: &quot;/root/.cache/sccache&quot;</span><br><span class="line">Feb 13 01:24:21 Version (client)                0.5.4</span><br><span class="line">Feb 13 01:24:21 + ccache --evict-older-than 1d</span><br><span class="line">Feb 13 01:24:21 + &#x27;[&#x27; &#x27;&#x27; == 1 &#x27;]&#x27;</span><br><span class="line">Feb 13 01:24:21 + &#x27;[&#x27; -n &#x27;&#x27; &#x27;]&#x27;</span><br><span class="line">Feb 13 01:24:21 + ls -l /output</span><br><span class="line">Feb 13 01:24:21 total 680996</span><br><span class="line">Feb 13 01:24:21 -rwxr-xr-x 1 root root 697336944 Feb 13 01:24 clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-benchmark -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-client -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-compressor -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-copier -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-disks -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-extract-from-config -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-format -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-git-import -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-keeper -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-keeper-client -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-keeper-converter -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-local -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-obfuscator -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-server -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-static-files-disk-uploader -&gt; clickhouse</span><br><span class="line">Feb 13 01:24:21 lrwxrwxrwx 1 root root        10 Feb 13 01:24 clickhouse-su -&gt; clickhouse</span><br></pre></td></tr></table></figure><p>上面的文件打包，然后 core dump 机器上测试下没问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./clickhouse <span class="built_in">local</span> -q <span class="string">&#x27;select 1&#x27;</span></span><br><span class="line">1</span><br><span class="line">./clickhouse-server --version</span><br><span class="line">ClickHouse server version 23.8.16.1.</span><br></pre></td></tr></table></figure><p>这里版本有问题不是 <code>23.8.16.40</code>，找下发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ find . -type f -exec grep -wl 23.8.16.1 &#123;&#125; \; </span><br><span class="line">./cmake/autogenerated_versions.txt</span><br><span class="line">^C</span><br><span class="line">$ cat cmake/autogenerated_versions.txt </span><br><span class="line"># This variables autochanged by tests/ci/version_helper.py:</span><br><span class="line"></span><br><span class="line"># NOTE: VERSION_REVISION has nothing common with DBMS_TCP_PROTOCOL_VERSION,</span><br><span class="line"># only DBMS_TCP_PROTOCOL_VERSION should be incremented on protocol changes.</span><br><span class="line">SET(VERSION_REVISION 54477)</span><br><span class="line">SET(VERSION_MAJOR 23)</span><br><span class="line">SET(VERSION_MINOR 8)</span><br><span class="line">SET(VERSION_PATCH 16)</span><br><span class="line">SET(VERSION_GITHASH 060ff8e813a4a16a540063127f8c91e2108d9adf)</span><br><span class="line">SET(VERSION_DESCRIBE v23.8.16.1-lts)</span><br><span class="line">SET(VERSION_STRING 23.8.16.1)</span><br><span class="line"># end of autochange</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后构建脚本里 <code>docker/packager/packager</code> 看到有:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> with_coverage:</span><br><span class="line">        cmake_flags.append(<span class="string">&quot;-DWITH_COVERAGE=1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> version:</span><br><span class="line">        result.append(<span class="string">f&quot;VERSION_STRING=&#x27;<span class="subst">&#123;version&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    env_prepared = parse_env_variables(</span><br><span class="line">...</span><br><span class="line">        args.version,</span><br></pre></td></tr></table></figure><p>然后在前面的编译选项加上 <code>args.version</code> ，测试了下发现还是不行，就修改 <code>cmake/autogenerated_versions.txt</code> 才可以，完整编译流程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vi cmake/autogenerated_versions.txt </span><br><span class="line"><span class="built_in">export</span> CMAKE_FLAGS=<span class="string">&#x27;-DNO_ARMV81_OR_HIGHER=1 -DCMAKE_BUILD_TYPE=Release -DENABLE_TESTS=OFF -DENABLE_DEBUG=OFF -DSPLIT_DEBUG_SYMBOLS=ON -DRust_TOOLCHAIN=nightly-2024-12-01 -DCLICKHOUSE_OFFICIAL_BUILD=ON&#x27;</span></span><br><span class="line"></span><br><span class="line">./docker/packager/packager --package-type=binary \</span><br><span class="line">  --version 23.8.16.40 \</span><br><span class="line">  --output-dir=build_results --docker-image-version 54187-e143a9039ba36ad0c25f2ed85503f36e88f61063</span><br><span class="line"><span class="comment"># 等报错，赋值docker run</span></span><br><span class="line">docker run .... bash</span><br><span class="line"><span class="comment"># export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup # 没有下面的nightly</span></span><br><span class="line">rustup toolchain install nightly-2024-12-01</span><br><span class="line">rustup default nightly-2024-12-01</span><br><span class="line">bash /build.sh</span><br></pre></td></tr></table></figure><p>上面选项 <code>Rust_TOOLCHAIN=nightly-2024-12-01</code> 是因为报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">info: This is the version for the rustup toolchain manager, not the rustc compiler.</span><br><span class="line">info: The currently active `rustc` version is `rustc 1.85.0-nightly (7442931d4 2024-11-30)`</span><br><span class="line">-- Rust Toolchain: </span><br><span class="line">Could not find toolchain &#x27;&#x27;</span><br><span class="line">Available toolchains:</span><br><span class="line">  nightly-2023-07-04-aarch64-unknown-linux-gnu</span><br><span class="line">  nightly-2024-12-01-aarch64-unknown-linux-gnu</span><br></pre></td></tr></table></figure><p>find grep 了下找到是 <a href="https://github.com/corrosion-rs/corrosion/blob/d9dfdefaa3d9ec4ba1245c7070727359c65c7869/cmake/FindRust.cmake#L140">corrosion-rs&#x2F;corrosion&#x2F;cmake&#x2F;FindRust.cmake</a></p><h3 id="打包-Docker-镜像"><a href="#打包-Docker-镜像" class="headerlink" title="打包 Docker 镜像"></a>打包 Docker 镜像</h3><p>根据 <code>docker histort --no-trunc</code> 确认了 Dockerfile 是用的 <a href="https://github.com/ClickHouse/ClickHouse/blob/v23.8.16.40-lts/docker/server/Dockerfile.ubuntu">docker&#x2F;server&#x2F;Dockerfile.ubuntu</a>，但是编译的镜像是基于 ubuntu:22.04 的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/os-release </span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;Ubuntu 22.04.4 LTS&quot;</span></span><br><span class="line">NAME=<span class="string">&quot;Ubuntu&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;22.04&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;22.04.4 LTS (Jammy Jellyfish)&quot;</span></span><br><span class="line">VERSION_CODENAME=jammy</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.ubuntu.com/&quot;</span></span><br><span class="line">SUPPORT_URL=<span class="string">&quot;https://help.ubuntu.com/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span></span><br><span class="line">UBUNTU_CODENAME=jammy</span><br></pre></td></tr></table></figure><p>避免意外和 CVE，还是用 <code>ubuntu:22.04</code> 稳妥些，参考了下最新的 master 分支上的 22.04 整了下 <code>docker/server/Dockerfile.fix</code>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># see https://github.com/moby/moby/issues/4032#issuecomment-192327844</span></span><br><span class="line"><span class="comment"># It could be removed after we move on a version 23:04+</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"><span class="comment"># ARG for quick switch to a given ubuntu mirror</span></span><br><span class="line"><span class="keyword">ARG</span> apt_archive=<span class="string">&quot;http://archive.ubuntu.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We shouldn&#x27;t use `apt upgrade` to not change the upstream image. It&#x27;s updated biweekly</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># user/group precreated explicitly with fixed uid/gid on purpose.</span></span><br><span class="line"><span class="comment"># It is especially important for rootless containers: in that case entrypoint</span></span><br><span class="line"><span class="comment"># can&#x27;t do chown and owners of mounted volumes should be configured externally.</span></span><br><span class="line"><span class="comment"># We do that in advance at the begining of Dockerfile before any packages will be</span></span><br><span class="line"><span class="comment"># installed to prevent picking those uid / gid by some unrelated software.</span></span><br><span class="line"><span class="comment"># The same uid / gid (101) is used both for alpine and ubuntu.</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s|http://archive.ubuntu.com|<span class="variable">$&#123;apt_archive&#125;</span>|g&quot;</span> /etc/apt/sources.list \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; groupadd -r clickhouse --gid=101 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; useradd -r -g clickhouse --uid=101 --home-dir=/var/lib/clickhouse --shell=/bin/bash clickhouse \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install --<span class="built_in">yes</span> --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">        ca-certificates \</span></span><br><span class="line"><span class="language-bash">        locales \</span></span><br><span class="line"><span class="language-bash">        tzdata \</span></span><br><span class="line"><span class="language-bash">        wget \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* /var/cache/debconf /tmp/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> VERSION=<span class="string">&quot;23.8.16.40&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> single_binary_location_url=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install from a single binary</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$&#123;single_binary_location_url&#125;</span>&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="built_in">echo</span> <span class="string">&quot;installing from single binary url: <span class="variable">$&#123;single_binary_location_url&#125;</span>&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; <span class="built_in">rm</span> -rf /tmp/clickhouse_binary \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; <span class="built_in">mkdir</span> -p /tmp/clickhouse_binary \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; wget --progress=bar:force:noscroll <span class="string">&quot;<span class="variable">$&#123;single_binary_location_url&#125;</span>&quot;</span> -O /tmp/clickhouse_binary/clickhouse \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; <span class="built_in">chmod</span> +x /tmp/clickhouse_binary/clickhouse \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; /tmp/clickhouse_binary/clickhouse install --user <span class="string">&quot;clickhouse&quot;</span> --group <span class="string">&quot;clickhouse&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; <span class="built_in">rm</span> -rf /tmp/* ; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">fi</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The rest is the same in the official docker and in our build system</span></span><br><span class="line"><span class="comment">#docker-official-library:on</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># post install</span></span><br><span class="line"><span class="comment"># we need to allow &quot;others&quot; access to clickhouse folder, because docker container</span></span><br><span class="line"><span class="comment"># can be started with arbitrary uid (openshift usecase)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> clickhouse-local -q <span class="string">&#x27;SELECT * FROM system.build_options&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /var/lib/clickhouse /var/log/clickhouse-server /etc/clickhouse-server /etc/clickhouse-client \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> ugo+Xrw -R /var/lib/clickhouse /var/log/clickhouse-server /etc/clickhouse-server /etc/clickhouse-client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> locale-gen en_US.UTF-8</span></span><br><span class="line"><span class="keyword">ENV</span> LANG=en_US.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=UTC</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /docker-entrypoint-initdb.d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker_related_config.xml /etc/clickhouse-server/config.d/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> entrypoint.sh /entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9000</span> <span class="number">8123</span> <span class="number">9009</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /var/lib/clickhouse</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> CLICKHOUSE_CONFIG=/etc/clickhouse-server/config.xml</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>直接拷贝二进制进去执行 clickhouse install 会造成 overlay diff 浪费，所以需要起一个 web 下载，编译容器镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RANDOM_PORT=50358</span><br><span class="line">docker run -d --name ck -v <span class="variable">$PWD</span>/build_results:/usr/share/nginx/html/ \</span><br><span class="line">    -p 50358:80 \</span><br><span class="line">    m.daocloud.io/docker.io/library/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> docker/server/</span><br><span class="line">docker build . --build-arg VERSION=<span class="string">&quot;23.8.16.40&quot;</span> --network host \</span><br><span class="line">  --build-arg single_binary_location_url=http://127.0.0.1:50358/clickhouse \</span><br><span class="line">   -t clickhouse/clickhouse-server:23.8.16.40 -f Dockerfile.fix</span><br></pre></td></tr></table></figure><h3 id="一些其他信息"><a href="#一些其他信息" class="headerlink" title="一些其他信息"></a>一些其他信息</h3><p><code>clickhouse/binary-builder</code> 新版本的 tag 似乎不是 commidID 了，找了下一些版本 tag 和 clang 对应：</p><ul><li>dd5e777b6745 18</li><li>54187-e143a9039ba36ad0c25f2ed85503f36e88f61063 16</li></ul><p>官方和编译的二进制文件 file 信息对比：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clickhouse: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, <span class="keyword">for</span> GNU/Linux 3.7.0, BuildID[sha1]=3e70066de2db0f08f97ca310827184d61111dc22, not stripped</span><br><span class="line">clickhouse: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 3.7.0, BuildID[sha1]=586fe5a059c988b60f99dcd794e68f0e4cf69619, not stripped</span><br></pre></td></tr></table></figure><p>切换其他版本的时候要处理下子模块，相关命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --recursive --checkout</span><br><span class="line"></span><br><span class="line">git submodule foreach --recursive git reset --hard</span><br><span class="line">git submodule update  --recursive</span><br></pre></td></tr></table></figure><p>切版本还要记得清理 <code>build_docker</code> 目录</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>其实也没参考多少，就是这些是能搜到的 arm64 编译相关</p><ul><li><a href="https://clickhouse.com/docs/en/development/build#building-in-docker">https://clickhouse.com/docs/en/development/build#building-in-docker</a></li><li><a href="http://www.shadow-li.com.cn/kunpeng/">http://www.shadow-li.com.cn/kunpeng/</a></li><li><a href="https://blog.csdn.net/pzz490/article/details/103574403">https://blog.csdn.net/pzz490/article/details/103574403</a></li><li><a href="https://www.bookstack.cn/read/clickhouse-20.3-en/a6fe877844d4f2ad.md">https://www.bookstack.cn/read/clickhouse-20.3-en/a6fe877844d4f2ad.md</a></li><li><a href="https://programmersought.com/article/22059609594/">https://programmersought.com/article/22059609594/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;clickhouse 官方 docker 镜像无法在老的 arm64 cpu 上运行，需要编译&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://zhangguanzhang.github.io/tags/docker/"/>
    
    <category term="clickhouse" scheme="http://zhangguanzhang.github.io/tags/clickhouse/"/>
    
    <category term="arm64" scheme="http://zhangguanzhang.github.io/tags/arm64/"/>
    
  </entry>
  
  <entry>
    <title>docker login hang</title>
    <link href="http://zhangguanzhang.github.io/2025/01/08/docker-login-hang/"/>
    <id>http://zhangguanzhang.github.io/2025/01/08/docker-login-hang/</id>
    <published>2025-01-08T17:10:30.000Z</published>
    <updated>2025-01-08T17:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>docker login 和 pod 拉取镜像非常慢的排查</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>现场客户单机测试环境，反馈 docker login 和 docker pull 和 pod 拉取镜像非常慢，现场大致查了下查不出来后我上去远程查了下。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>我们私有化都会部署一个镜像仓库的，镜像都推送到仓库上，现场说拉取镜像很慢和 docker login 很慢</p><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/redhat-release </span><br><span class="line">Red Hat Enterprise Linux Server release 7.8 (Maipo)</span><br><span class="line">$ uname -a</span><br><span class="line">Linux poc-xxxx 3.10.0-1127.el7.x86_64 #1 SMP Tue Feb 18 16:39:12 EST 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p>上去看了下，login 非常慢：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login -u xxx -p xxxx reg.xxx.lan:5000</span><br></pre></td></tr></table></figure><p>strace 看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ strace docker login -u xxx -p xxxx reg.xxx.lan:5000</span><br><span class="line">...</span><br><span class="line">write(3, &quot;HEAD /_ping HTTP/1.1\r\nHost: api.&quot;..., 92) = 92</span><br><span class="line">futex(0xc000700148, FUTEX_WAKE_PRIVATE, 1) = 1</span><br><span class="line">futex(0x1ac5448, FUTEX_WAIT_PRIVATE, 0, NULLWARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">) = 0</span><br><span class="line">futex(0x1ac5448, FUTEX_WAIT_PRIVATE, 0, NULL) = 0</span><br><span class="line">futex(0x1ac5448, FUTEX_WAIT_PRIVATE, 0, NULL) = 0</span><br></pre></td></tr></table></figure><p>发现卡在上面，但是 curl 发下 HEAD 请求正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v reg.xxx.lan:5000/_ping -I</span></span><br><span class="line">* About to connect() to reg.xxx.lan port 5000 (#0)</span><br><span class="line">*   Trying 7.xx.x.125...</span><br><span class="line">* Connected to reg.xxx.lan (7.xx.x.125) port 5000 (#0)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET /_ping HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.29.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: reg.xxx.lan:5000</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt; HTTP/1.1 404 Not Found</span></span><br><span class="line">&lt; Content-Type: text/plain; charset=utf-8</span><br><span class="line">&lt; Docker-Distribution-Api-Version: registry/2.0</span><br><span class="line">&lt; X-Content-Type-Options: nosniff</span><br><span class="line">&lt; Date: Wed, 08 Jan 2025 07:05:33 GMT</span><br><span class="line">&lt; Content-Length: 19</span><br><span class="line">&lt;</span><br><span class="line">404 page not found</span><br><span class="line">* Connection #0 to host reg.xxx.lan left intact</span><br></pre></td></tr></table></figure><p>然后让客户准备第二台机器只安装同样的 docker 版本 ，上去 docker login 就很快，排除掉镜像仓库问题。看了下这块代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/moby/moby/blob/6c523afaedcbb2e3e219dbf4d417efad5b9397b3/client/ping.go#L21</span><br></pre></td></tr></table></figure><p>发现代码逻辑也没啥逻辑问题，先发 HEAD 请求有问题再尝试 GET 请求。机器上看了下也没安全软件啥的。最后尝试下 127 访问试试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login -u xxx -p xxxx 127.0.0.1:5000</span><br></pre></td></tr></table></figure><p>发现很快，感觉不会是 hosts 解析相关吧，<code>tcpdump -nn -i ens224 port 53 -v | grep -A2 reg.xxx.lan</code> 看了下果然发往外面了。查看下 <code>/etc/nsswitch.conf</code> 发现果然被修改了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep hosts /etc/nsswitch.conf</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hosts:     db files nisplus nis dns</span></span><br><span class="line">hosts:      dns files myhostname</span><br></pre></td></tr></table></figure><p>改回就正常了，询问客户没有人改，应该是他们制作虚机模板时候修改的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;docker login 和 pod 拉取镜像非常慢的排查&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://zhangguanzhang.github.io/tags/docker/"/>
    
    <category term="net" scheme="http://zhangguanzhang.github.io/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>inotifywait 和 confd 在一起踩的坑</title>
    <link href="http://zhangguanzhang.github.io/2024/11/24/inotifywait-and-confd/"/>
    <id>http://zhangguanzhang.github.io/2024/11/24/inotifywait-and-confd/</id>
    <published>2024-11-24T20:10:30.000Z</published>
    <updated>2024-11-24T20:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录最近碰到的一次 confd 和 inotifywait 配合踩的坑</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>版本快发版的时候，测试测出来经常部署应用阶段 sql 初始化服务偶现连接数据库 mysql 超时，导致没有创建库或者表，而业务功能不正常。然后临近发版测试人员上报了高风险。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p>复现非常麻烦，不是一直超时是偶先。没办法询问了 sql 初始化业务的开发人员，和多个环境得到以下对比信息：</p><ul><li>最近无改动，初始化服务回退到上个版本依旧</li><li>每次超时是不同的库，并不是固定的，慢 sql 看了没有</li><li>k8s&#x2F;docker 部署均会发生</li></ul><p>就在一筹莫展之际，另一个部门的测试人员找过来，他们部署后，浏览器上测试很多接口报错超时（主要是内部涉及到的调用链长），有了稳定复现的环境真好。上去排查了下，发现 ipset 的条目被频繁清空和创建导致的。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们 toB 和 toG 为了避免客户现场漏扫和安全相关，每台机器起了容器，利用 ipset 和 iptables 做白名单端口策略。相关规则为如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -w -N BASE-RULE</span><br><span class="line">iptables -w -A BASE-RULE -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -w -A BASE-RULE -m set ! --match-set whiteiplist src -m set  --match-set whiteportlist dst -j DROP</span><br><span class="line">iptables -w -A BASE-RULE -j RETURN</span><br><span class="line">iptables -A INPUT -j BASE-RULE</span><br></pre></td></tr></table></figure><p>默认行为是 DROP，也就是白名单实现。在每个节点机器都部署有 ipset 容器，内部 <code>entrypoint.sh</code> 内容大致如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exec inotifywait -mrq \</span><br><span class="line">    --timefmt &#x27;%d/%m/%y/%H:%M&#x27; \</span><br><span class="line">    --format &#x27;%T %w %f&#x27; \</span><br><span class="line">    -e modify,delete,close_write,move /data/kube/ | while read line;do</span><br><span class="line">        bash /iptables.sh</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><code>/iptables.sh</code> 内部就是检查链和每次清空 ipset 条目和创建。之前的逻辑是 ansible 分发 rule 文件，上个版本被其他同事修改成使用 confd 从 redis 内读取更新到该文件：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># confd 容器内目录</span></span><br><span class="line"><span class="section">[template]</span></span><br><span class="line"><span class="attr">src</span> = <span class="string">&quot;ipsets-whiteiplist.tmpl&quot;</span></span><br><span class="line"><span class="attr">dest</span> = <span class="string">&quot;/root/kube/rule/whiteiplist.txt&quot;</span>  <span class="comment"># 配置文件地址</span></span><br><span class="line"><span class="attr">keys</span> = [                 <span class="comment"># 监听的key</span></span><br><span class="line">    <span class="string">&quot;/ipsets/whiteiplist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/ipsets/mark&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="根源"><a href="#根源" class="headerlink" title="根源"></a>根源</h3><p>然后我在 ipset 容器内使用 inotifywait 观察了下发现一直产生临时文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">inotifywait -mrq     --timefmt <span class="string">&#x27;%d/%m/%y/%H:%M&#x27;</span>     --format <span class="string">&#x27;%T %w %f&#x27;</span> -e modify,delete,close_write,move /data/kube/</span></span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br><span class="line">26/11/24/14:51 /data/kube/ .whiteportlist.txt3298417101</span><br></pre></td></tr></table></figure><p>看这个文件名就是 confd 生成的对比临时文件，查看了下文档并没有发现有设置临时文件的 dir 相关参数，然后找到了相关逻辑：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/kelseyhightower/confd/blob/master/resource/template/resource.go#L138</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TemplateResource)</span></span> createStageFile() <span class="type">error</span> &#123;</span><br><span class="line">log.Debug(<span class="string">&quot;Using source template &quot;</span> + t.Src)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !util.IsFileExist(t.Src) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;Missing template: &quot;</span> + t.Src)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Debug(<span class="string">&quot;Compiling source template &quot;</span> + t.Src)</span><br><span class="line"></span><br><span class="line">tmpl, err := template.New(filepath.Base(t.Src)).Funcs(t.funcMap).ParseFiles(t.Src)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Unable to process template %s, %s&quot;</span>, t.Src, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create TempFile in Dest directory to avoid cross-filesystem issues</span></span><br><span class="line">temp, err := ioutil.TempFile(filepath.Dir(t.Dest), <span class="string">&quot;.&quot;</span>+filepath.Base(t.Dest))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = tmpl.Execute(temp, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">temp.Close()</span><br><span class="line">os.Remove(temp.Name())</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> temp.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the owner, group, and mode on the stage file now to make it easier to</span></span><br><span class="line"><span class="comment">// compare against the destination configuration file later.</span></span><br><span class="line">os.Chmod(temp.Name(), t.FileMode)</span><br><span class="line">os.Chown(temp.Name(), t.Uid, t.Gid)</span><br><span class="line">t.StageFile = temp</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TemplateResource)</span></span> sync() <span class="type">error</span> &#123;</span><br><span class="line">staged := t.StageFile.Name()</span><br><span class="line"><span class="keyword">if</span> t.keepStageFile &#123;</span><br><span class="line">log.Info(<span class="string">&quot;Keeping staged file: &quot;</span> + staged)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> os.Remove(staged)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是这行 <code>ioutil.TempFile(filepath.Dir(t.Dest), &quot;.&quot;+filepath.Base(t.Dest))</code> 相当于 <code>目录下 + .文件名字 + TempFile随机后缀</code>，在下面的 sync 方法里对比后再删掉 stageFile。</p><p>从源码了解到并没有相关 StageFileDir 参数，没办法让同事把文件放其他地方， 在 reload_cmd cp 过去，大概类似这样：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[template]</span></span><br><span class="line"><span class="attr">src</span> = <span class="string">&quot;ipsets-whiteiplist.tmpl&quot;</span></span><br><span class="line"><span class="attr">dest</span> = <span class="string">&quot;/root/kube/whiteiplist.txt&quot;</span>  <span class="comment"># 配置文件地址</span></span><br><span class="line"><span class="attr">keys</span> = [                 <span class="comment"># 监听的key</span></span><br><span class="line">    <span class="string">&quot;/ipsets/whiteiplist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/ipsets/mark&quot;</span>,</span><br><span class="line">]</span><br><span class="line"><span class="attr">check_cmd</span> = <span class="string">&quot;&quot;</span>    <span class="comment"># 服务配置检查命令</span></span><br><span class="line"><span class="attr">reload_cmd</span> = <span class="string">&quot;cp -f /root/kube/whiteiplist.txt /root/kube/rule/whiteiplist.txt&quot;</span> </span><br></pre></td></tr></table></figure><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>重写了那个 while 内过滤掉.开头的文件，然后 ipset 清空逻辑使用 swap 方式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录最近碰到的一次 confd 和 inotifywait 配合踩的坑&lt;/p&gt;</summary>
    
    
    
    
    <category term="iptables" scheme="http://zhangguanzhang.github.io/tags/iptables/"/>
    
    <category term="ipset" scheme="http://zhangguanzhang.github.io/tags/ipset/"/>
    
    <category term="inotifywait" scheme="http://zhangguanzhang.github.io/tags/inotifywait/"/>
    
    <category term="confd" scheme="http://zhangguanzhang.github.io/tags/confd/"/>
    
  </entry>
  
  <entry>
    <title>hostPort 不通排查，以及挖掘问题根源</title>
    <link href="http://zhangguanzhang.github.io/2024/09/16/hostPort-problem/"/>
    <id>http://zhangguanzhang.github.io/2024/09/16/hostPort-problem/</id>
    <published>2024-09-16T18:10:30.000Z</published>
    <updated>2024-09-16T18:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录最近碰到的一次 hostPort 不通排查的信息记录</p><span id="more"></span><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>内部有服务通过 hostPort 暴漏的，之前每次出问题都是有人去清理相关，这次完整记录下我处理过程</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="iptables-相关"><a href="#iptables-相关" class="headerlink" title="iptables 相关"></a>iptables 相关</h3><p>只有一个服务 hostPort 暴漏的，测试反馈部署了后无法访问，查看了下 iptables 的 nat 表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t nat -S CNI-HOSTPORT-DNAT</span></span><br><span class="line">-N CNI-HOSTPORT-DNAT</span><br><span class="line">-A CNI-HOSTPORT-DNAT -p tcp -m comment --comment &quot;dnat name: \&quot;cbr0\&quot; id: \&quot;fb7cdb0a4f8da673da0a9818ec9a1576f953a8e8decf87a081827c11e4aa7138\&quot;&quot; \</span><br><span class="line">   -m multiport --dports 443,9001,80,9002,9003,19004,19003,50051,25,465,993,995,7010,7020,12321 -j CNI-DN-b24a4eb3a38dc5843c23a</span><br><span class="line">-A CNI-HOSTPORT-DNAT -p tcp -m comment --comment &quot;dnat name: \&quot;cbr0\&quot; id: \&quot;fb7cdb0a4f8da673da0a9818ec9a1576f953a8e8decf87a081827c11e4aa7138\&quot;&quot; \</span><br><span class="line">   -m multiport --dports 10001 -j CNI-DN-b24a4eb3a38dc5843c23a</span><br><span class="line">-A CNI-HOSTPORT-DNAT -p tcp -m comment --comment &quot;dnat name: \&quot;cbr0\&quot; id: \&quot;0961bad27f1a52a28701b7038120b8188e7a78df21f57a08428f021ab3c071e2\&quot;&quot; \</span><br><span class="line">   -m multiport --dports 443,9001,80,9002,9003,19004,19003,50051,25,465,993,995,7010,7020,12321 -j CNI-DN-f2390ee4e08c581b1ea73</span><br><span class="line">-A CNI-HOSTPORT-DNAT -p tcp -m comment --comment &quot;dnat name: \&quot;cbr0\&quot; id: \&quot;0961bad27f1a52a28701b7038120b8188e7a78df21f57a08428f021ab3c071e2\&quot;&quot; \</span><br><span class="line">   -m multiport --dports 10001 -j CNI-DN-f2390ee4e08c581b1ea73</span><br></pre></td></tr></table></figure><p>相关 PodIP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -o wide | grep xxxx-gateway</span></span><br><span class="line">xxxx-gateway-55fc694d76-rbxc7                   1/1     Running     0               3h53m   10.187.2.34   xxx.xx.xx.26   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>而两个 CNI-DN 链的最终 IP 为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t nat -S CNI-DN-b24a4eb3a38dc5843c23a | grep -m1 to-destination</span></span><br><span class="line">-A CNI-DN-b24a4eb3a38dc5843c23a -p tcp -m tcp --dport 443 -j DNAT --to-destination 10.187.2.36:443</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t nat -S CNI-DN-f2390ee4e08c581b1ea73 | grep -m1 to-destination</span></span><br><span class="line">-A CNI-DN-f2390ee4e08c581b1ea73 -p tcp -m tcp --dport 443 -j DNAT --to-destination 10.187.2.34:443</span><br></pre></td></tr></table></figure><p>后者的才是实际的 PodIP，前者的是没清理的，通过 cni plugin 文件也可以确认：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /var/lib/cni/networks/cbr0/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -l fb7cdb0a *</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -l 0961bad27f *</span></span><br><span class="line">10.187.2.34</span><br></pre></td></tr></table></figure><p>先匹配到第一个不存在 Pod 的 <code>CNI-DN-b24a4eb3a38dc5843c23a</code> 导致 dnat 到不存在的 PodIP 而无法访问到。清理掉它相关就行。但是根源要排查。</p><h2 id="排查相关"><a href="#排查相关" class="headerlink" title="排查相关"></a>排查相关</h2><p>根据 cni 配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/cni/net.d/10-flannel.conflist</span> </span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;cbr0&quot;,</span><br><span class="line">  &quot;cniVersion&quot;: &quot;0.3.1&quot;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;flannel&quot;,</span><br><span class="line">      &quot;delegate&quot;: &#123;</span><br><span class="line">        &quot;hairpinMode&quot;: true,</span><br><span class="line">        &quot;isDefaultGateway&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="line">      &quot;capabilities&quot;: &#123;</span><br><span class="line">        &quot;portMappings&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用的 cni-plugins 只有 flannel 和 portmap，portmap 已经是最新版本 1.5.1 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">portmap --version</span></span><br><span class="line">CNI portmap plugin v1.5.1</span><br><span class="line">CNI protocol versions supported: 0.1.0, 0.2.0, 0.3.0, 0.3.1, 0.4.0, 1.0.0</span><br></pre></td></tr></table></figure><p>集群和内核信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux centos79 3.10.0-1160.el7.x86_64 #1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl  get node -o wide</span></span><br><span class="line">NAME          STATUS   ROLES         AGE     VERSION    INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION           CONTAINER-RUNTIME</span><br><span class="line">xx.xx.xx.37   Ready    master,node   4h10m   v1.27.16   xx.xx.xx.37   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-1160.el7.x86_64   docker://26.1.4</span><br><span class="line">xx.xx.xx.38   Ready    master,node   4h10m   v1.27.16   xx.xx.xx.38   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-1160.el7.x86_64   docker://26.1.4</span><br><span class="line">xx.xx.xx.26   Ready    master,node   4h10m   v1.27.16   xx.xx.xx.26   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-1160.el7.x86_64   docker://26.1.4</span><br></pre></td></tr></table></figure><p>大概看了下 cni-plugin 的 portmap 源码，添加和删除逻辑都没问题，删除的时候检测链存在否，存在就删除，不存在则跳过。是 container runtime 调用的 cni-plugins，按照前面 iptables 的注释里的容器 ID 查看下 cri-dockerd 日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">journalctl -xe --no-pager -u cri-dockerd | grep fb7cdb0a4f8da</span></span><br><span class="line">9月 14 11:39:49 centos79 cri-dockerd[9246]: &#123;&quot;cniVersion&quot;:&quot;0.3.1&quot;,&quot;hairpinMode&quot;:true,&quot;ipMasq&quot;:false,&quot;ipam&quot;:&#123;&quot;ranges&quot;:[[&#123;&quot;subnet&quot;:&quot;10.187.2.0/24&quot;&#125;]],&quot;routes&quot;:[&#123;&quot;dst&quot;:&quot;10.187.0.0/16&quot;&#125;],&quot;type&quot;:&quot;host-local&quot;&#125;,&quot;isDefaultGateway&quot;:true,&quot;isGateway&quot;:true,&quot;mtu&quot;:1450,&quot;name&quot;:&quot;cbr0&quot;,&quot;type&quot;:&quot;bridge&quot;&#125;time=&quot;2024-09-14T11:39:49+08:00&quot; level=info msg=&quot;Will attempt to re-write config file /data/kube/docker/containers/fb7cdb0a4f8da673da0a9818ec9a1576f953a8e8decf87a081827c11e4aa7138/resolv.conf as [nameserver 10.186.0.2 search default123.svc.cluster1.local. svc.cluster1.local. cluster1.local. options ndots:5]&quot;</span><br></pre></td></tr></table></figure><p>跳转的链名字 <code>CNI-DN-XXX</code> 看了下 portmap 源码是根据 名字+ 容器ID sha512 生成的，手动计算如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -n <span class="string">&#x27;cbr0fb7cdb0a4f8da673da0a9818ec9a1576f953a8e8decf87a081827c11e4aa7138&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">   | <span class="built_in">sha512sum</span> | <span class="built_in">cut</span> -c 1-21</span></span><br><span class="line">b24a4eb3a38dc5843c23a</span><br></pre></td></tr></table></figure><p>说明确实是这个容器。看了下 portmap 源码使用的 iptables 库封装的命令选项是有带 <code>--wait</code> 选项的，即使 iptables 数量多也没问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -w -t nat -S | <span class="built_in">wc</span> -l</span></span><br><span class="line">1705</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -w -t nat -S | grep -Pv <span class="string">&#x27;KUBE-SVC|KUBE-SEP&#x27;</span> | <span class="built_in">wc</span> -l</span></span><br><span class="line">180</span><br></pre></td></tr></table></figure><p>理论上发生的可能性是 cri-dockerd 清理掉老 Pod 的时候没清理，但是看代码是有清理的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/Mirantis/cri-dockerd/blob/v0.3.14/core/sandbox_stop.go#L87-L92</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *dockerService)</span></span> StopPodSandbox(</span><br><span class="line">   ...</span><br><span class="line">ready, ok := ds.getNetworkReady(podSandboxID)</span><br><span class="line"><span class="keyword">if</span> !hostNetwork &amp;&amp; (ready || !ok) &#123;</span><br><span class="line"><span class="comment">// Only tear down the pod network if we haven&#x27;t done so already</span></span><br><span class="line">cID := config.BuildContainerID(runtimeName, podSandboxID)</span><br><span class="line">err := ds.network.TearDownPod(namespace, name, cID)</span><br></pre></td></tr></table></figure><p>清理的时候会打日志，也存在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -xe --no-pager -u docker | grep fb7cdb0a4f8da</span><br><span class="line">9月 14 11:44:13 centos79 dockerd[2708]: time=&quot;2024-09-14T11:44:12.872235404+08:00&quot; level=warning msg=&quot;cleaning up after shim disconnected&quot; id=fb7cdb0a4f8da673da0a9818ec9a1576f953a8e8decf87a081827c11e4aa7138 namespace=moby</span><br></pre></td></tr></table></figure><p>而查看部署日志，相关时间点 <code>11:44:13</code> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-09-14 11:44:02,249 - xxx INFO - 开始卸载docker...</span><br></pre></td></tr></table></figure><p>询问了下测试人员，说这个时间点执行了卸载步骤，所以整个问题流程是:</p><ul><li>执行卸载流程，会先kubectl delete 删掉所有资源，触发 pod 删除</li><li>kubelet 调用 cri-dockerd 清理下线相关容器，但是同步的我们卸载步骤会停止了 docker 和删了 docker 目录</li><li>cri-dockerd 清理过程中连不上 docker ，导致 cri-dockerd 清理容器的时候无法执行完整的 <code>StopPodSandbox</code> 流程清理掉 nat 表的 <code>CNI-HOSTPORT-DNAT</code> 链规则。</li><li>卸载过程会完成后再部署环境，最后 hostPort 老规则还在先匹配</li></ul><p>避免就是卸载 docker 过程中，清理掉 nat 表的相关规则。</p><h2 id="类似的情况"><a href="#类似的情况" class="headerlink" title="类似的情况"></a>类似的情况</h2><ul><li><a href="https://github.com/rancher/rke/issues/3440">Kube-proxy doesn’t remove stale CNI-HOSTPORT-DNAT</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录最近碰到的一次 hostPort 不通排查的信息记录&lt;/p&gt;</summary>
    
    
    
    
    <category term="kubernetes" scheme="http://zhangguanzhang.github.io/tags/kubernetes/"/>
    
    <category term="hostPort" scheme="http://zhangguanzhang.github.io/tags/hostPort/"/>
    
    <category term="iptables" scheme="http://zhangguanzhang.github.io/tags/iptables/"/>
    
  </entry>
  
</feed>
